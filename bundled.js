// deno-fmt-ignore-file
// deno-lint-ignore-file
// This code was bundled using `deno bundle` and it's not recommended to edit it manually

const osType = (()=>{
    const { Deno: Deno1  } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator  } = globalThis;
    if (navigator?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows = osType === "windows";
const CHAR_FORWARD_SLASH = 47;
function assertPath(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator(code) {
    return code === 47;
}
function isPathSeparator(code) {
    return isPosixPathSeparator(code) || code === 92;
}
function isWindowsDeviceRoot(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS[c] ?? c;
    });
}
class DenoStdInternalError extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError(msg);
    }
}
const sep = "\\";
const delimiter = ";";
function resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1  } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator(code)) {
                isAbsolute = true;
                if (isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            isAbsolute = true;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator(code)) {
        return true;
    } else if (isWindowsDeviceRoot(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert(firstPart != null);
    if (isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize(joined);
}
function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    const fromOrig = resolve(from);
    const toOrig = resolve(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path.slice(0, end);
}
function basename(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= start; --i){
            const code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= start; --i){
            if (isPathSeparator(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname(path) {
    assertPath(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("\\", pathObject);
}
function parse(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        ret.root = ret.dir = path;
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl(path) {
    if (!isAbsolute(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod = {
    sep: sep,
    delimiter: delimiter,
    resolve: resolve,
    normalize: normalize,
    isAbsolute: isAbsolute,
    join: join,
    relative: relative,
    toNamespacedPath: toNamespacedPath,
    dirname: dirname,
    basename: basename,
    extname: extname,
    format: format,
    parse: parse,
    fromFileUrl: fromFileUrl,
    toFileUrl: toFileUrl
};
const sep1 = "/";
const delimiter1 = ":";
function resolve1(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1  } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize1(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const isAbsolute = path.charCodeAt(0) === 47;
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeString(path, !isAbsolute, "/", isPosixPathSeparator);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute1(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47;
}
function join1(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize1(joined);
}
function relative1(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    from = resolve1(from);
    to = resolve1(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath1(path) {
    return path;
}
function dirname1(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const hasRoot = path.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i = path.length - 1; i >= 1; --i){
        if (path.charCodeAt(i) === 47) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path.slice(0, end);
}
function basename1(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= 0; --i){
            const code = path.charCodeAt(i);
            if (code === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= 0; --i){
            if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname1(path) {
    assertPath(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format1(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("/", pathObject);
}
function parse1(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = path.charCodeAt(0) === 47;
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl1(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl1(path) {
    if (!isAbsolute1(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod1 = {
    sep: sep1,
    delimiter: delimiter1,
    resolve: resolve1,
    normalize: normalize1,
    isAbsolute: isAbsolute1,
    join: join1,
    relative: relative1,
    toNamespacedPath: toNamespacedPath1,
    dirname: dirname1,
    basename: basename1,
    extname: extname1,
    format: format1,
    parse: parse1,
    fromFileUrl: fromFileUrl1,
    toFileUrl: toFileUrl1
};
const path = isWindows ? mod : mod1;
const { join: join2 , normalize: normalize2  } = path;
const path1 = isWindows ? mod : mod1;
const { basename: basename2 , delimiter: delimiter2 , dirname: dirname2 , extname: extname2 , format: format2 , fromFileUrl: fromFileUrl2 , isAbsolute: isAbsolute2 , join: join3 , normalize: normalize3 , parse: parse2 , relative: relative2 , resolve: resolve2 , sep: sep2 , toFileUrl: toFileUrl2 , toNamespacedPath: toNamespacedPath2 ,  } = path1;
function slashTrim(s) {
    let start = 0;
    let end = s.length;
    if (s[start] === '/') start++;
    if (s[end - 1] === '/') end--;
    if (end <= start) return '';
    return s.substring(start, end);
}
function slashTrimLeft(s) {
    return s.startsWith('/') ? s.substr(1) : s;
}
function pathToArray(path) {
    return slashTrim(path).split('/').filter((s)=>!!s);
}
function pathCombine(...args) {
    const stripped = args.filter((a)=>!!a);
    if (stripped.length === 0) return '';
    const startSlash = stripped[0].startsWith('/');
    const endSlash = stripped[stripped.length - 1].endsWith('/');
    let joined = stripped.map((a)=>slashTrim(a)).filter((a)=>!!a).join('/');
    if (startSlash) joined = '/' + joined;
    if (endSlash && joined !== '/') joined += '/';
    return joined;
}
function decodeURIComponentAndPlus(x) {
    return decodeURIComponent(x.replace(/\+/g, '%20'));
}
function jsonQuote(s) {
    if (s == null || s.length == 0) {
        return "";
    }
    let sb = '';
    for(let i = 0; i < s.length; i++){
        const c = s.charAt(i);
        switch(c){
            case '\\':
            case '"':
                sb += '\\' + c;
                break;
            case '\b':
                sb += "\\b";
                break;
            case '\t':
                sb += "\\t";
                break;
            case '\n':
                sb += "\\n";
                break;
            case '\f':
                sb += "\\f";
                break;
            case '\r':
                sb += "\\r";
                break;
            default:
                if (c.charCodeAt(0) < ' '.charCodeAt(0)) {
                    const t = "000" + c.charCodeAt(0).toString(16);
                    sb += "\\u" + t.slice(-4);
                } else {
                    sb += c;
                }
        }
    }
    return sb;
}
function last(arr) {
    return arr[arr.length - 1];
}
function arrayEqual(arr0, arr1) {
    if (arr0.length !== arr1.length) return false;
    for(let i = 0; i < arr0.length; i++){
        if (arr0[i] !== arr1[i]) return false;
    }
    return true;
}
function isObject(item) {
    return item && typeof item === 'object' && !Array.isArray(item);
}
function arrayify(item) {
    if (!item) return [];
    if (!Array.isArray(item)) return [
        item
    ];
    return item;
}
function hex2array(hex) {
    if (hex.length % 2 !== 0) throw new Error('hex string with uneven length');
    const arr = new Uint8Array(hex.length / 2);
    for(let i = 0; i < hex.length / 2; i++){
        arr[i] = parseInt(hex.substring(i + i, i + i + 2), 16);
    }
    return arr;
}
function mergeDeep(target, ...sources) {
    if (!sources.length) return target;
    const source = sources.shift();
    if (isObject(target) && isObject(source)) {
        for(const key in source){
            if (isObject(source[key])) {
                if (!target[key]) Object.assign(target, {
                    [key]: {}
                });
                mergeDeep(target[key], source[key]);
            } else {
                Object.assign(target, {
                    [key]: source[key]
                });
            }
        }
    }
    return mergeDeep(target, ...sources);
}
const strategies = [
    'replace',
    'append',
    'prepend',
    'positional',
    'id-replace',
    'id-patch'
];
function removePatchConfig(patchData) {
    if (Array.isArray(patchData)) {
        if (typeof patchData[0] === 'object' && '$strategy' in patchData[0] && strategies.includes(patchData[0].$strategy)) {
            patchData.shift();
        }
        return patchData.map((item)=>removePatchConfig(item));
    } else if (typeof patchData === 'object') {
        return Object.fromEntries(Object.entries(patchData).map(([k, v])=>[
                k,
                removePatchConfig(v)
            ]));
    } else {
        return patchData;
    }
}
function patch(target, patchData) {
    if (Array.isArray(patchData)) {
        if (!Array.isArray(target)) return removePatchConfig(patchData);
        let strategy = "positional";
        let id = "";
        if (patchData[0]) {
            let config = null;
            if (typeof patchData[0] === 'object' && '$strategy' in patchData[0] && strategies.includes(patchData[0].$strategy)) {
                strategy = patchData[0].$strategy;
                config = patchData.shift();
            }
            if (config && '$id' in config && strategy.startsWith('id-')) {
                id = config.$id;
            }
        }
        switch(strategy){
            case 'positional':
                for(let idx = 0; idx < patchData.length; idx++){
                    if (idx < target.length) {
                        target[idx] = patch(target[idx], patchData[idx]);
                    } else {
                        target.push(removePatchConfig(patchData[idx]));
                    }
                }
                return target;
            case 'replace':
                return [
                    ...removePatchConfig(patchData)
                ];
            case 'append':
                patchData.forEach((val)=>target.push(removePatchConfig(val)));
                return target;
            case 'prepend':
                {
                    for(let idx1 = patchData.length - 1; idx1 >= 0; idx1--){
                        target.unshift(removePatchConfig(patchData[idx1]));
                    }
                    return target;
                }
            case 'id-replace':
                {
                    const newList = [];
                    patchData.forEach((val)=>{
                        if (val[id]) {
                            const targetItem = target.find((ti)=>ti[id] === val[id]);
                            if (targetItem) {
                                newList.push(patch(targetItem, val));
                            } else {
                                newList.push(removePatchConfig(val));
                            }
                        }
                    });
                    return newList;
                }
            case 'id-patch':
                {
                    const newList1 = [
                        ...target
                    ];
                    patchData.forEach((val)=>{
                        if (val[id]) {
                            const targetIdx = newList1.findIndex((nl)=>nl[id] === val[id]);
                            if (targetIdx >= 0) {
                                newList1[targetIdx] = patch(newList1[targetIdx], val);
                            } else {
                                newList1.push(removePatchConfig(val));
                            }
                        }
                    });
                    return newList1;
                }
        }
    } else if (typeof patchData === "object") {
        if (Array.isArray(target) || !(typeof target === "object")) return removePatchConfig(patchData);
        for(const prop in patchData){
            if (target[prop]) {
                if (patchData[prop] === undefined) {
                    delete target[prop];
                } else {
                    target[prop] = patch(target[prop], patchData[prop]);
                }
            } else {
                target[prop] = removePatchConfig(patchData[prop]);
            }
        }
        return target;
    } else {
        return removePatchConfig(patchData);
    }
}
function deepEqualIfPresent(objSuper, objSub) {
    if (objSuper === objSub) return true;
    if (isPrimitive(objSuper) && isPrimitive(objSub)) return objSuper === objSub;
    if (Array.isArray(objSuper) && Array.isArray(objSub) && objSuper.length !== objSub.length) return false;
    for(const key in objSub){
        if (!deepEqualIfPresent(objSuper[key], objSub[key])) return false;
    }
    return true;
}
function isPrimitive(obj) {
    return obj !== Object(obj);
}
function shallowCopy(value) {
    if (Array.isArray(value)) return [
        ...value
    ];
    if (typeof value === 'object') return {
        ...value
    };
    return value;
}
function getProp(object, path, defaultVal) {
    if (!Array.isArray(path)) path = path.toString().match(/[^.[\]]+/g) || [];
    if (!path.length) {
        return object === undefined ? defaultVal : object;
    }
    return getProp(object[path.shift()], path, defaultVal);
}
function deleteProp(object, path) {
    if (!path.length) return;
    const parent = getProp(object, path.slice(0, -1));
    if (parent === undefined) return;
    delete parent[path.slice(-1)[0]];
}
const setProp = (obj, path, value)=>{
    if (Object(obj) !== obj) return obj;
    if (!Array.isArray(path)) path = path.toString().match(/[^.[\]]+/g) || [];
    path.slice(0, -1).reduce((a, c, i)=>Object(a[c]) === a[c] ? a[c] : a[c] = /^\+?(0|[1-9]\d*)$/.test(path[i + 1]) ? [] : {}, obj)[path[path.length - 1]] = value;
    return obj;
};
const scanFirst = (str, start, searches)=>{
    const matches = [];
    for(let idx = start; idx < str.length; idx++){
        for(let matchIdx = 0; matchIdx < matches.length; matchIdx++){
            const [srchIdx, pos] = matches[matchIdx];
            if (searches[srchIdx][pos + 1] === str[idx]) {
                matches[matchIdx][1]++;
                if (pos + 2 === searches[srchIdx].length) {
                    return [
                        searches[srchIdx],
                        idx + 1
                    ];
                }
            } else {
                matches.splice(matchIdx, 1);
                matchIdx--;
            }
        }
        for(let srchIdx1 = 0; srchIdx1 < searches.length; srchIdx1++){
            if (searches[srchIdx1][0] === str[idx]) {
                matches.push([
                    srchIdx1,
                    0
                ]);
                if (1 === searches[srchIdx1].length) {
                    return [
                        searches[srchIdx1],
                        idx + 1
                    ];
                }
            }
        }
    }
    return [
        "",
        -1
    ];
};
const scanCloseJsString = (str, start, quote)=>{
    const escaped = "\\" + quote;
    let [match, pos] = [
        escaped,
        start
    ];
    while(match === escaped){
        [match, pos] = scanFirst(str, pos, [
            escaped,
            quote
        ]);
    }
    return pos;
};
const scanCloseJsBracket = (str, start, brackets)=>{
    let [match, pos] = [
        "",
        start
    ];
    const quotes = "'\"`";
    while(match !== brackets[1] && pos > 0){
        [match, pos] = scanFirst(str, pos, [
            brackets[0],
            brackets[1],
            ...quotes
        ]);
        if (quotes.includes(match) && pos > 0) {
            pos = scanCloseJsString(str, pos, match);
        } else if (match === brackets[0]) {
            pos = scanCloseJsBracket(str, pos, brackets);
        }
    }
    return pos;
};
const skipWhitespace = (str, start)=>{
    let pos = start;
    while(' \t\n\r\v'.indexOf(str[pos]) > -1 && pos < str.length)pos++;
    return pos;
};
const matchFirst = (str, start, matches)=>{
    if (matches.length === 0) return [
        "",
        -1
    ];
    const match = matches.find((m)=>str.startsWith(m, start));
    return match ? [
        match,
        start + match.length
    ] : [
        "",
        -1
    ];
};
const upTo = (str, match, start)=>{
    const pos = str.indexOf(match, start);
    return pos < 0 ? str.substring(start || 0) : str.substring(start || 0, pos);
};
const upToLast = (str, match, end)=>{
    const pos = str.lastIndexOf(match, end);
    return pos < 0 ? str.substring(0, end || str.length) : str.substring(0, pos);
};
const after = (str, match, start)=>{
    const pos = str.indexOf(match, start);
    return pos < 0 ? '' : str.substring(pos + match.length);
};
function queryString(args) {
    return Object.entries(args || {}).flatMap(([key, vals])=>vals.map((val)=>key + (val ? '=' + encodeURIComponent(val) : ''))).join('&');
}
function fullQueryString(args) {
    return args && Object.values(args).length !== 0 ? "?" + queryString(args) : '';
}
function resolvePathPattern(pathPattern, currentPath, basePath, subPath, fullUrl, query, name, isDirectory, decode) {
    if (!pathPattern) return '';
    const getParts = (path)=>slashTrim(path || '').split('/').filter((part)=>part !== '').map((part)=>decode ? decodeURIComponent(part) : part);
    const pathParts = getParts(currentPath);
    const basePathParts = getParts(basePath);
    const subPathParts = getParts(subPath);
    const fullPathParts = basePathParts.concat(pathParts);
    const nameParts = getParts(name);
    const getPartsMatch = (section, position0, position1)=>{
        try {
            let parts = pathParts;
            if (section === 'B') parts = basePathParts;
            if (section === 'S') parts = subPathParts;
            if (section === 'N') parts = nameParts;
            if (section === 'P') parts = fullPathParts;
            let pos0 = parseInt(position0.substr(1));
            if (position0.startsWith('<')) pos0 = -pos0 - 1;
            let match = '';
            if (position1) {
                let pos1 = parseInt(position1.substr(1));
                if (position1.startsWith('<')) pos1 = -pos1 - 1;
                match = (pos1 === -1 ? parts.slice(pos0) : parts.slice(pos0, pos1 + 1)).join('/');
            } else {
                match = pos0 >= 0 ? parts[pos0] : parts[parts.length + pos0];
            }
            return match || '';
        } catch  {
            return '';
        }
    };
    const result = pathPattern.replace('$*', currentPath + (isDirectory ? "/" : "") + fullQueryString(query)).replace('$$', encodeURIComponent(fullUrl || '')).replace('$P*', fullPathParts.join('/') + (isDirectory ? "/" : "") + fullQueryString(query)).replace('$N*', name || '').replace(/\$([BSNP])?([<>]\d+)([<>]\d+)?(:\((.+?)\)|:\$([BSNP])?([<>]\d+)([<>]\d+)?)?/g, (_match, p1, p2, p3, p4, p5, p6, p7, p8)=>{
        const partsMatch = getPartsMatch(p1, p2, p3);
        if (partsMatch || !p4) return partsMatch || '$$';
        if (p4.startsWith(':(')) return p5;
        return getPartsMatch(p6, p7, p8) || '$$';
    }).replace(/\$\?(\*|\((.+?)\))/g, (_match, p1, p2)=>{
        if (p1 === '*') return queryString(query);
        return (query || {})[p2] === [] ? '$$' : ((query || {})[p2] || []).join(',') || '$$';
    }).replace('/$$', '').replace('$$', '');
    return result;
}
function resolvePathPatternWithUrl(pathPattern, url, obj, name, decode) {
    if (obj) {
        return resolvePathPatternWithObject(pathPattern, obj, [], url.servicePath, url.basePathElements.join('/'), url.subPathElements.join('/'), url.toString(), url.query, name, url.isDirectory, decode);
    } else {
        return resolvePathPattern(pathPattern, url.servicePath, url.basePathElements.join('/'), url.subPathElements.join('/'), url.toString(), url.query, name, url.isDirectory, decode);
    }
}
function multiplyVariableSegments(currentSegments, newSegment, sourceObject) {
    return currentSegments.flatMap((seg)=>{
        const valAtSeg = seg ? getProp(sourceObject, seg) : sourceObject;
        return Object.keys(valAtSeg).map((key)=>`${seg}[${key}]${newSegment}`);
    });
}
function resolvePathPatternWithObjectInner(pathPattern, regex, partialResolutions, sourceObject, sourcePath) {
    const match = regex.exec(pathPattern);
    if (match) {
        const path = match[1];
        const pathConstantSegments = path.split('[]');
        const isMultiplied = pathConstantSegments.length > 1;
        const enumeratedPaths = pathConstantSegments.reduce((result, seg)=>result.length === 0 ? [
                seg
            ] : multiplyVariableSegments(result, seg, sourceObject), []);
        const substitutions = enumeratedPaths.map((path)=>{
            const val = path ? getProp(sourceObject, path) : sourceObject;
            if (val === undefined || val === null) {
                throw new Error(`In path pattern, the data path '${path}' is not present in the data`);
            }
            return val.toString();
        });
        const newPartialResolutions = partialResolutions.flatMap((pr)=>substitutions.map((subs)=>pr.replace(new RegExp(regex.source), subs)));
        const [prs, wasMultiplied] = resolvePathPatternWithObjectInner(pathPattern, regex, newPartialResolutions, sourceObject, sourcePath);
        return [
            prs,
            wasMultiplied || isMultiplied
        ];
    } else {
        return [
            partialResolutions,
            false
        ];
    }
}
function resolvePathPatternWithObject(pathPattern, sourceObject, sourcePath, currentPath, basePath, subPath, fullUrl, query, name, isDirectory, decode) {
    const regex = /\${([\w\[\].]*)}/g;
    const partResolvedPattern = resolvePathPattern(pathPattern, currentPath, basePath, subPath, fullUrl, query, name, isDirectory, decode);
    const [resolved, wasMultiplied] = resolvePathPatternWithObjectInner(partResolvedPattern, regex, [
        partResolvedPattern
    ], sourceObject, sourcePath);
    return wasMultiplied ? resolved : resolved[0];
}
class Url {
    scheme = '';
    domain = '';
    isRelative = false;
    _fragment = '';
    get fragment() {
        return this._fragment || this.query['$fragment']?.[0] || '';
    }
    set fragment(val) {
        this._fragment = val;
    }
    get path() {
        return (this.isRelative ? '' : '/') + this.pathElements.join('/') + (this.isDirectory && this.pathElements.length > 0 ? '/' : '');
    }
    set path(val) {
        this.pathElements = decodeURI(slashTrim(val)).split('/').filter((el)=>!!el);
        this._isDirectory = val.endsWith('/') || val === '';
    }
    pathElements = [];
    _isDirectory = false;
    get isDirectory() {
        return this._isDirectory;
    }
    get resourceName() {
        return this._isDirectory ? '' : last(this.pathElements);
    }
    set resourceName(val) {
        let resName = val;
        const wasDirectory = this._isDirectory;
        if (val.endsWith('/')) {
            this._isDirectory = true;
            resName = val.slice(0, -1);
        } else {
            this._isDirectory = false;
        }
        if (wasDirectory) {
            this.pathElements.push(val);
        } else {
            this.pathElements[this.pathElements.length - 1] = resName;
        }
    }
    get resourcePath() {
        const resPathEls = this._isDirectory ? this.pathElements : this.pathElements.slice(0, -1);
        return '/' + resPathEls.join('/');
    }
    get resourceParts() {
        return this.resourceName.split('.');
    }
    get resourceExtension() {
        return this.resourceParts.length > 1 ? last(this.resourceParts) : '';
    }
    query = {};
    encodeQueryValue(s) {
        return s.replace('&', '%26').replace('=', '%3D').replace('#', '%23');
    }
    get queryString() {
        return Object.entries(this.query).flatMap(([key, vals])=>vals.map((val)=>`${key}=${this.encodeQueryValue(val)}`)).join('&') || '';
    }
    set queryString(qs) {
        this.query = !qs ? {} : qs.split('&').filter((part)=>!!part).reduce((res, queryPart)=>{
            const [key, val] = queryPart.split('=');
            if (res[key]) {
                if (val) res[key].push(decodeURIComponentAndPlus(val));
            } else {
                res[key] = val ? [
                    decodeURIComponentAndPlus(val)
                ] : [];
            }
            return res;
        }, {});
    }
    basePathElementCount = 0;
    get basePathElements() {
        return this.pathElements.slice(0, this.basePathElementCount);
    }
    set basePathElements(els) {
        if (els.length <= this.pathElements.length && arrayEqual(els, this.pathElements.slice(0, els.length))) this.basePathElementCount = els.length;
        else this.basePathElementCount = 0;
    }
    get servicePath() {
        return this.servicePathElements.join('/') + (this.isDirectory ? '/' : '');
    }
    set servicePath(path) {
        this.pathElements = [
            ...this.basePathElements,
            ...pathToArray(path)
        ];
        this._isDirectory = path.endsWith('/') || this.pathElements.length === 0 && path === '';
    }
    get adapterPath() {
        return this.servicePath + (this.queryString ? '?' + this.queryString : '');
    }
    get servicePathElements() {
        return this.pathElements.slice(this.basePathElementCount);
    }
    subPathElementCount = null;
    get subPathElements() {
        return this.subPathElementCount === null || this.subPathElementCount <= 0 ? [] : this.pathElements.slice(-this.subPathElementCount);
    }
    set subPathElements(els) {
        if (els.length <= this.pathElements.length && arrayEqual(els, els.length === 0 ? [] : this.pathElements.slice(-els.length))) this.subPathElementCount = els.length;
        else this.subPathElementCount = null;
    }
    get mainPathElementCount() {
        return this.pathElements.length - this.basePathElementCount - (this.subPathElementCount || 0);
    }
    set mainPathElementCount(count) {
        this.subPathElementCount = this.pathElements.length - this.basePathElementCount - count;
    }
    constructor(urlString){
        if (!urlString) return;
        if (typeof urlString !== 'string') urlString = urlString.toString();
        const urlParse = urlString.match(Url.urlRegex);
        if (!urlParse) throw new Error('bad url');
        this.scheme = urlParse[2];
        this.domain = urlParse[3];
        this.isRelative = !this.domain && urlParse[1] !== '/';
        this.path = urlParse[4];
        this._isDirectory = this.path.endsWith('/');
        const qs = urlParse[5];
        this.queryString = qs ? decodeURI(qs.substr(1)) : '';
        const frag = urlParse[6];
        this.fragment = frag ? frag.substr(1) : '';
    }
    hasBase(base) {
        return this.path.startsWith(base === '/' ? base : base + '/') || this.path === base;
    }
    copy() {
        const newUrl = new Url();
        newUrl.scheme = this.scheme;
        newUrl.domain = this.domain;
        newUrl.path = this.path;
        newUrl.queryString = this.queryString;
        newUrl.basePathElementCount = this.basePathElementCount;
        newUrl.subPathElementCount = this.subPathElementCount;
        newUrl.fragment = this.fragment;
        newUrl.isRelative = this.isRelative;
        return newUrl;
    }
    toString(mode = "absolute url") {
        const host = `${this.scheme || ''}${this.domain || ''}`;
        return `${this.isRelative || mode === "absolute path" ? '' : host}${this.path}${this.queryString ? '?' + this.queryString : ''}${this.fragment ? '#' + this.fragment : ''}`;
    }
    baseUrl() {
        return `${this.scheme || ''}${this.domain || ''}/${this.basePathElements.join('/')}`;
    }
    setSubpathFromUrl(servicePathUrl) {
        if (servicePathUrl === undefined) return;
        if (typeof servicePathUrl === 'string') {
            servicePathUrl = servicePathUrl ? new Url(servicePathUrl) : this;
        }
        this.subPathElementCount = this.pathElements.length - servicePathUrl.pathElements.length;
        return this;
    }
    follow(relativeUrl) {
        const newUrl = this.copy();
        if (!relativeUrl) return newUrl;
        for (const part of relativeUrl.split('/')){
            if (part === '..') {
                newUrl.pathElements.pop();
            } else if (part && part !== '.') {
                newUrl.pathElements.push(part);
            }
        }
        newUrl._isDirectory = relativeUrl.endsWith('/');
        return newUrl;
    }
    static urlRegex = /^((https?:\/\/)([^?#\/]+)|\/)?([^?#]*)(\?[^#]*)?(#.*)?$/;
    static fromPath(path) {
        return new Url(pathCombine('/', path));
    }
    static fromPathPattern(pathPattern, url, obj) {
        return new Url(resolvePathPatternWithUrl(pathPattern, url, obj));
    }
    static inheritingBase(baseUrl, url) {
        const newUrl = new Url(url);
        if (baseUrl) {
            baseUrl = new Url(baseUrl);
            newUrl.scheme = newUrl.scheme || baseUrl.scheme;
            newUrl.domain = newUrl.domain || baseUrl.domain;
        }
        return newUrl;
    }
}
const osType1 = (()=>{
    const { Deno: Deno1  } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator  } = globalThis;
    if (navigator?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows1 = osType1 === "windows";
const CHAR_FORWARD_SLASH1 = 47;
function assertPath1(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator1(code) {
    return code === 47;
}
function isPathSeparator1(code) {
    return isPosixPathSeparator1(code) || code === 92;
}
function isWindowsDeviceRoot1(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString1(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH1;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format1(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS1 = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace1(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS1[c] ?? c;
    });
}
class DenoStdInternalError1 extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert1(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError1(msg);
    }
}
const sep3 = "\\";
const delimiter3 = ";";
function resolve3(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1  } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath1(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator1(code)) {
                isAbsolute = true;
                if (isPathSeparator1(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator1(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot1(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator1(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator1(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString1(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator1);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize4(path) {
    assertPath1(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            isAbsolute = true;
            if (isPathSeparator1(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString1(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator1);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator1(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute3(path) {
    assertPath1(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator1(code)) {
        return true;
    } else if (isWindowsDeviceRoot1(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator1(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join4(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath1(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert1(firstPart != null);
    if (isPathSeparator1(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator1(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator1(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator1(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize4(joined);
}
function relative3(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    const fromOrig = resolve3(from);
    const toOrig = resolve3(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath3(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve3(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot1(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname3(path) {
    assertPath1(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator1(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator1(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator1(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path.slice(0, end);
}
function basename3(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath1(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot1(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= start; --i){
            const code = path.charCodeAt(i);
            if (isPathSeparator1(code)) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= start; --i){
            if (isPathSeparator1(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname3(path) {
    assertPath1(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot1(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format3(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format1("\\", pathObject);
}
function parse3(path) {
    assertPath1(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            rootEnd = 1;
            if (isPathSeparator1(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        ret.root = ret.dir = path;
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl3(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl3(path) {
    if (!isAbsolute3(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace1(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod2 = {
    sep: sep3,
    delimiter: delimiter3,
    resolve: resolve3,
    normalize: normalize4,
    isAbsolute: isAbsolute3,
    join: join4,
    relative: relative3,
    toNamespacedPath: toNamespacedPath3,
    dirname: dirname3,
    basename: basename3,
    extname: extname3,
    format: format3,
    parse: parse3,
    fromFileUrl: fromFileUrl3,
    toFileUrl: toFileUrl3
};
const sep4 = "/";
const delimiter4 = ":";
function resolve4(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1  } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath1(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH1;
    }
    resolvedPath = normalizeString1(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator1);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize5(path) {
    assertPath1(path);
    if (path.length === 0) return ".";
    const isAbsolute = path.charCodeAt(0) === 47;
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeString1(path, !isAbsolute, "/", isPosixPathSeparator1);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute4(path) {
    assertPath1(path);
    return path.length > 0 && path.charCodeAt(0) === 47;
}
function join5(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath1(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize5(joined);
}
function relative4(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    from = resolve4(from);
    to = resolve4(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath4(path) {
    return path;
}
function dirname4(path) {
    assertPath1(path);
    if (path.length === 0) return ".";
    const hasRoot = path.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i = path.length - 1; i >= 1; --i){
        if (path.charCodeAt(i) === 47) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path.slice(0, end);
}
function basename4(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath1(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= 0; --i){
            const code = path.charCodeAt(i);
            if (code === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= 0; --i){
            if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname4(path) {
    assertPath1(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format4(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format1("/", pathObject);
}
function parse4(path) {
    assertPath1(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = path.charCodeAt(0) === 47;
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl4(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl4(path) {
    if (!isAbsolute4(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace1(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod3 = {
    sep: sep4,
    delimiter: delimiter4,
    resolve: resolve4,
    normalize: normalize5,
    isAbsolute: isAbsolute4,
    join: join5,
    relative: relative4,
    toNamespacedPath: toNamespacedPath4,
    dirname: dirname4,
    basename: basename4,
    extname: extname4,
    format: format4,
    parse: parse4,
    fromFileUrl: fromFileUrl4,
    toFileUrl: toFileUrl4
};
const path2 = isWindows1 ? mod2 : mod3;
const { join: join6 , normalize: normalize6  } = path2;
const path3 = isWindows1 ? mod2 : mod3;
const { basename: basename5 , delimiter: delimiter5 , dirname: dirname5 , extname: extname5 , format: format5 , fromFileUrl: fromFileUrl5 , isAbsolute: isAbsolute5 , join: join7 , normalize: normalize7 , parse: parse5 , relative: relative5 , resolve: resolve5 , sep: sep5 , toFileUrl: toFileUrl5 , toNamespacedPath: toNamespacedPath5 ,  } = path3;
const __default = JSON.parse(`{
  "application/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/3gpp-ims+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/3gpphal+json": {
    "source": "iana",
    "compressible": true
  },
  "application/3gpphalforms+json": {
    "source": "iana",
    "compressible": true
  },
  "application/a2l": {
    "source": "iana"
  },
  "application/ace+cbor": {
    "source": "iana"
  },
  "application/activemessage": {
    "source": "iana"
  },
  "application/activity+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-costmap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-costmapfilter+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-directory+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointcost+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointcostparams+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointprop+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointpropparams+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-error+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-networkmap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-networkmapfilter+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-updatestreamcontrol+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-updatestreamparams+json": {
    "source": "iana",
    "compressible": true
  },
  "application/aml": {
    "source": "iana"
  },
  "application/andrew-inset": {
    "source": "iana",
    "extensions": ["ez"]
  },
  "application/applefile": {
    "source": "iana"
  },
  "application/applixware": {
    "source": "apache",
    "extensions": ["aw"]
  },
  "application/at+jwt": {
    "source": "iana"
  },
  "application/atf": {
    "source": "iana"
  },
  "application/atfx": {
    "source": "iana"
  },
  "application/atom+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atom"]
  },
  "application/atomcat+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atomcat"]
  },
  "application/atomdeleted+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atomdeleted"]
  },
  "application/atomicmail": {
    "source": "iana"
  },
  "application/atomsvc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atomsvc"]
  },
  "application/atsc-dwd+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dwd"]
  },
  "application/atsc-dynamic-event-message": {
    "source": "iana"
  },
  "application/atsc-held+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["held"]
  },
  "application/atsc-rdt+json": {
    "source": "iana",
    "compressible": true
  },
  "application/atsc-rsat+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rsat"]
  },
  "application/atxml": {
    "source": "iana"
  },
  "application/auth-policy+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/bacnet-xdd+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/batch-smtp": {
    "source": "iana"
  },
  "application/bdoc": {
    "compressible": false,
    "extensions": ["bdoc"]
  },
  "application/beep+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/calendar+json": {
    "source": "iana",
    "compressible": true
  },
  "application/calendar+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xcs"]
  },
  "application/call-completion": {
    "source": "iana"
  },
  "application/cals-1840": {
    "source": "iana"
  },
  "application/captive+json": {
    "source": "iana",
    "compressible": true
  },
  "application/cbor": {
    "source": "iana"
  },
  "application/cbor-seq": {
    "source": "iana"
  },
  "application/cccex": {
    "source": "iana"
  },
  "application/ccmp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ccxml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ccxml"]
  },
  "application/cdfx+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["cdfx"]
  },
  "application/cdmi-capability": {
    "source": "iana",
    "extensions": ["cdmia"]
  },
  "application/cdmi-container": {
    "source": "iana",
    "extensions": ["cdmic"]
  },
  "application/cdmi-domain": {
    "source": "iana",
    "extensions": ["cdmid"]
  },
  "application/cdmi-object": {
    "source": "iana",
    "extensions": ["cdmio"]
  },
  "application/cdmi-queue": {
    "source": "iana",
    "extensions": ["cdmiq"]
  },
  "application/cdni": {
    "source": "iana"
  },
  "application/cea": {
    "source": "iana"
  },
  "application/cea-2018+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cellml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cfw": {
    "source": "iana"
  },
  "application/city+json": {
    "source": "iana",
    "compressible": true
  },
  "application/clr": {
    "source": "iana"
  },
  "application/clue+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/clue_info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cms": {
    "source": "iana"
  },
  "application/cnrp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/coap-group+json": {
    "source": "iana",
    "compressible": true
  },
  "application/coap-payload": {
    "source": "iana"
  },
  "application/commonground": {
    "source": "iana"
  },
  "application/conference-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cose": {
    "source": "iana"
  },
  "application/cose-key": {
    "source": "iana"
  },
  "application/cose-key-set": {
    "source": "iana"
  },
  "application/cpl+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["cpl"]
  },
  "application/csrattrs": {
    "source": "iana"
  },
  "application/csta+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cstadata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/csvm+json": {
    "source": "iana",
    "compressible": true
  },
  "application/cu-seeme": {
    "source": "apache",
    "extensions": ["cu"]
  },
  "application/cwt": {
    "source": "iana"
  },
  "application/cybercash": {
    "source": "iana"
  },
  "application/dart": {
    "compressible": true
  },
  "application/dash+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mpd"]
  },
  "application/dash-patch+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mpp"]
  },
  "application/dashdelta": {
    "source": "iana"
  },
  "application/davmount+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["davmount"]
  },
  "application/dca-rft": {
    "source": "iana"
  },
  "application/dcd": {
    "source": "iana"
  },
  "application/dec-dx": {
    "source": "iana"
  },
  "application/dialog-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/dicom": {
    "source": "iana"
  },
  "application/dicom+json": {
    "source": "iana",
    "compressible": true
  },
  "application/dicom+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/dii": {
    "source": "iana"
  },
  "application/dit": {
    "source": "iana"
  },
  "application/dns": {
    "source": "iana"
  },
  "application/dns+json": {
    "source": "iana",
    "compressible": true
  },
  "application/dns-message": {
    "source": "iana"
  },
  "application/docbook+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["dbk"]
  },
  "application/dots+cbor": {
    "source": "iana"
  },
  "application/dskpp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/dssc+der": {
    "source": "iana",
    "extensions": ["dssc"]
  },
  "application/dssc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xdssc"]
  },
  "application/dvcs": {
    "source": "iana"
  },
  "application/ecmascript": {
    "source": "iana",
    "compressible": true,
    "extensions": ["es","ecma"]
  },
  "application/edi-consent": {
    "source": "iana"
  },
  "application/edi-x12": {
    "source": "iana",
    "compressible": false
  },
  "application/edifact": {
    "source": "iana",
    "compressible": false
  },
  "application/efi": {
    "source": "iana"
  },
  "application/elm+json": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/elm+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.cap+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/emergencycalldata.comment+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.control+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.deviceinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.ecall.msd": {
    "source": "iana"
  },
  "application/emergencycalldata.providerinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.serviceinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.veds+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emma+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["emma"]
  },
  "application/emotionml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["emotionml"]
  },
  "application/encaprtp": {
    "source": "iana"
  },
  "application/epp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/epub+zip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["epub"]
  },
  "application/eshop": {
    "source": "iana"
  },
  "application/exi": {
    "source": "iana",
    "extensions": ["exi"]
  },
  "application/expect-ct-report+json": {
    "source": "iana",
    "compressible": true
  },
  "application/express": {
    "source": "iana",
    "extensions": ["exp"]
  },
  "application/fastinfoset": {
    "source": "iana"
  },
  "application/fastsoap": {
    "source": "iana"
  },
  "application/fdt+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["fdt"]
  },
  "application/fhir+json": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/fhir+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/fido.trusted-apps+json": {
    "compressible": true
  },
  "application/fits": {
    "source": "iana"
  },
  "application/flexfec": {
    "source": "iana"
  },
  "application/font-sfnt": {
    "source": "iana"
  },
  "application/font-tdpfr": {
    "source": "iana",
    "extensions": ["pfr"]
  },
  "application/font-woff": {
    "source": "iana",
    "compressible": false
  },
  "application/framework-attributes+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/geo+json": {
    "source": "iana",
    "compressible": true,
    "extensions": ["geojson"]
  },
  "application/geo+json-seq": {
    "source": "iana"
  },
  "application/geopackage+sqlite3": {
    "source": "iana"
  },
  "application/geoxacml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/gltf-buffer": {
    "source": "iana"
  },
  "application/gml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["gml"]
  },
  "application/gpx+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["gpx"]
  },
  "application/gxf": {
    "source": "apache",
    "extensions": ["gxf"]
  },
  "application/gzip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["gz"]
  },
  "application/h224": {
    "source": "iana"
  },
  "application/held+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/hjson": {
    "extensions": ["hjson"]
  },
  "application/http": {
    "source": "iana"
  },
  "application/hyperstudio": {
    "source": "iana",
    "extensions": ["stk"]
  },
  "application/ibe-key-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ibe-pkg-reply+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ibe-pp-data": {
    "source": "iana"
  },
  "application/iges": {
    "source": "iana"
  },
  "application/im-iscomposing+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/index": {
    "source": "iana"
  },
  "application/index.cmd": {
    "source": "iana"
  },
  "application/index.obj": {
    "source": "iana"
  },
  "application/index.response": {
    "source": "iana"
  },
  "application/index.vnd": {
    "source": "iana"
  },
  "application/inkml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ink","inkml"]
  },
  "application/iotp": {
    "source": "iana"
  },
  "application/ipfix": {
    "source": "iana",
    "extensions": ["ipfix"]
  },
  "application/ipp": {
    "source": "iana"
  },
  "application/isup": {
    "source": "iana"
  },
  "application/its+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["its"]
  },
  "application/java-archive": {
    "source": "apache",
    "compressible": false,
    "extensions": ["jar","war","ear"]
  },
  "application/java-serialized-object": {
    "source": "apache",
    "compressible": false,
    "extensions": ["ser"]
  },
  "application/java-vm": {
    "source": "apache",
    "compressible": false,
    "extensions": ["class"]
  },
  "application/javascript": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["js","mjs"]
  },
  "application/jf2feed+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jose": {
    "source": "iana"
  },
  "application/jose+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jrd+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jscalendar+json": {
    "source": "iana",
    "compressible": true
  },
  "application/json": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["json","map"]
  },
  "application/json-patch+json": {
    "source": "iana",
    "compressible": true
  },
  "application/json-seq": {
    "source": "iana"
  },
  "application/json5": {
    "extensions": ["json5"]
  },
  "application/jsonml+json": {
    "source": "apache",
    "compressible": true,
    "extensions": ["jsonml"]
  },
  "application/jwk+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jwk-set+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jwt": {
    "source": "iana"
  },
  "application/kpml-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/kpml-response+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ld+json": {
    "source": "iana",
    "compressible": true,
    "extensions": ["jsonld"]
  },
  "application/lgr+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["lgr"]
  },
  "application/link-format": {
    "source": "iana"
  },
  "application/load-control+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/lost+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["lostxml"]
  },
  "application/lostsync+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/lpf+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/lxf": {
    "source": "iana"
  },
  "application/mac-binhex40": {
    "source": "iana",
    "extensions": ["hqx"]
  },
  "application/mac-compactpro": {
    "source": "apache",
    "extensions": ["cpt"]
  },
  "application/macwriteii": {
    "source": "iana"
  },
  "application/mads+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mads"]
  },
  "application/manifest+json": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["webmanifest"]
  },
  "application/marc": {
    "source": "iana",
    "extensions": ["mrc"]
  },
  "application/marcxml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mrcx"]
  },
  "application/mathematica": {
    "source": "iana",
    "extensions": ["ma","nb","mb"]
  },
  "application/mathml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mathml"]
  },
  "application/mathml-content+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mathml-presentation+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-associated-procedure-description+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-deregister+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-envelope+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-msk+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-msk-response+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-protection-description+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-reception-report+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-register+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-register-response+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-schedule+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-user-service-description+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbox": {
    "source": "iana",
    "extensions": ["mbox"]
  },
  "application/media-policy-dataset+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mpf"]
  },
  "application/media_control+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mediaservercontrol+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mscml"]
  },
  "application/merge-patch+json": {
    "source": "iana",
    "compressible": true
  },
  "application/metalink+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["metalink"]
  },
  "application/metalink4+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["meta4"]
  },
  "application/mets+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mets"]
  },
  "application/mf4": {
    "source": "iana"
  },
  "application/mikey": {
    "source": "iana"
  },
  "application/mipc": {
    "source": "iana"
  },
  "application/missing-blocks+cbor-seq": {
    "source": "iana"
  },
  "application/mmt-aei+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["maei"]
  },
  "application/mmt-usd+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["musd"]
  },
  "application/mods+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mods"]
  },
  "application/moss-keys": {
    "source": "iana"
  },
  "application/moss-signature": {
    "source": "iana"
  },
  "application/mosskey-data": {
    "source": "iana"
  },
  "application/mosskey-request": {
    "source": "iana"
  },
  "application/mp21": {
    "source": "iana",
    "extensions": ["m21","mp21"]
  },
  "application/mp4": {
    "source": "iana",
    "extensions": ["mp4s","m4p"]
  },
  "application/mpeg4-generic": {
    "source": "iana"
  },
  "application/mpeg4-iod": {
    "source": "iana"
  },
  "application/mpeg4-iod-xmt": {
    "source": "iana"
  },
  "application/mrb-consumer+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mrb-publish+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/msc-ivr+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/msc-mixer+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/msword": {
    "source": "iana",
    "compressible": false,
    "extensions": ["doc","dot"]
  },
  "application/mud+json": {
    "source": "iana",
    "compressible": true
  },
  "application/multipart-core": {
    "source": "iana"
  },
  "application/mxf": {
    "source": "iana",
    "extensions": ["mxf"]
  },
  "application/n-quads": {
    "source": "iana",
    "extensions": ["nq"]
  },
  "application/n-triples": {
    "source": "iana",
    "extensions": ["nt"]
  },
  "application/nasdata": {
    "source": "iana"
  },
  "application/news-checkgroups": {
    "source": "iana",
    "charset": "US-ASCII"
  },
  "application/news-groupinfo": {
    "source": "iana",
    "charset": "US-ASCII"
  },
  "application/news-transmission": {
    "source": "iana"
  },
  "application/nlsml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/node": {
    "source": "iana",
    "extensions": ["cjs"]
  },
  "application/nss": {
    "source": "iana"
  },
  "application/oauth-authz-req+jwt": {
    "source": "iana"
  },
  "application/oblivious-dns-message": {
    "source": "iana"
  },
  "application/ocsp-request": {
    "source": "iana"
  },
  "application/ocsp-response": {
    "source": "iana"
  },
  "application/octet-stream": {
    "source": "iana",
    "compressible": false,
    "extensions": ["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]
  },
  "application/oda": {
    "source": "iana",
    "extensions": ["oda"]
  },
  "application/odm+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/odx": {
    "source": "iana"
  },
  "application/oebps-package+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["opf"]
  },
  "application/ogg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ogx"]
  },
  "application/omdoc+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["omdoc"]
  },
  "application/onenote": {
    "source": "apache",
    "extensions": ["onetoc","onetoc2","onetmp","onepkg"]
  },
  "application/opc-nodeset+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/oscore": {
    "source": "iana"
  },
  "application/oxps": {
    "source": "iana",
    "extensions": ["oxps"]
  },
  "application/p21": {
    "source": "iana"
  },
  "application/p21+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/p2p-overlay+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["relo"]
  },
  "application/parityfec": {
    "source": "iana"
  },
  "application/passport": {
    "source": "iana"
  },
  "application/patch-ops-error+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xer"]
  },
  "application/pdf": {
    "source": "iana",
    "compressible": false,
    "extensions": ["pdf"]
  },
  "application/pdx": {
    "source": "iana"
  },
  "application/pem-certificate-chain": {
    "source": "iana"
  },
  "application/pgp-encrypted": {
    "source": "iana",
    "compressible": false,
    "extensions": ["pgp"]
  },
  "application/pgp-keys": {
    "source": "iana",
    "extensions": ["asc"]
  },
  "application/pgp-signature": {
    "source": "iana",
    "extensions": ["asc","sig"]
  },
  "application/pics-rules": {
    "source": "apache",
    "extensions": ["prf"]
  },
  "application/pidf+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/pidf-diff+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/pkcs10": {
    "source": "iana",
    "extensions": ["p10"]
  },
  "application/pkcs12": {
    "source": "iana"
  },
  "application/pkcs7-mime": {
    "source": "iana",
    "extensions": ["p7m","p7c"]
  },
  "application/pkcs7-signature": {
    "source": "iana",
    "extensions": ["p7s"]
  },
  "application/pkcs8": {
    "source": "iana",
    "extensions": ["p8"]
  },
  "application/pkcs8-encrypted": {
    "source": "iana"
  },
  "application/pkix-attr-cert": {
    "source": "iana",
    "extensions": ["ac"]
  },
  "application/pkix-cert": {
    "source": "iana",
    "extensions": ["cer"]
  },
  "application/pkix-crl": {
    "source": "iana",
    "extensions": ["crl"]
  },
  "application/pkix-pkipath": {
    "source": "iana",
    "extensions": ["pkipath"]
  },
  "application/pkixcmp": {
    "source": "iana",
    "extensions": ["pki"]
  },
  "application/pls+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["pls"]
  },
  "application/poc-settings+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/postscript": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ai","eps","ps"]
  },
  "application/ppsp-tracker+json": {
    "source": "iana",
    "compressible": true
  },
  "application/problem+json": {
    "source": "iana",
    "compressible": true
  },
  "application/problem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/provenance+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["provx"]
  },
  "application/prs.alvestrand.titrax-sheet": {
    "source": "iana"
  },
  "application/prs.cww": {
    "source": "iana",
    "extensions": ["cww"]
  },
  "application/prs.cyn": {
    "source": "iana",
    "charset": "7-BIT"
  },
  "application/prs.hpub+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/prs.nprend": {
    "source": "iana"
  },
  "application/prs.plucker": {
    "source": "iana"
  },
  "application/prs.rdf-xml-crypt": {
    "source": "iana"
  },
  "application/prs.xsf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/pskc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["pskcxml"]
  },
  "application/pvd+json": {
    "source": "iana",
    "compressible": true
  },
  "application/qsig": {
    "source": "iana"
  },
  "application/raml+yaml": {
    "compressible": true,
    "extensions": ["raml"]
  },
  "application/raptorfec": {
    "source": "iana"
  },
  "application/rdap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/rdf+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rdf","owl"]
  },
  "application/reginfo+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rif"]
  },
  "application/relax-ng-compact-syntax": {
    "source": "iana",
    "extensions": ["rnc"]
  },
  "application/remote-printing": {
    "source": "iana"
  },
  "application/reputon+json": {
    "source": "iana",
    "compressible": true
  },
  "application/resource-lists+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rl"]
  },
  "application/resource-lists-diff+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rld"]
  },
  "application/rfc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/riscos": {
    "source": "iana"
  },
  "application/rlmi+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/rls-services+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rs"]
  },
  "application/route-apd+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rapd"]
  },
  "application/route-s-tsid+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sls"]
  },
  "application/route-usd+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rusd"]
  },
  "application/rpki-ghostbusters": {
    "source": "iana",
    "extensions": ["gbr"]
  },
  "application/rpki-manifest": {
    "source": "iana",
    "extensions": ["mft"]
  },
  "application/rpki-publication": {
    "source": "iana"
  },
  "application/rpki-roa": {
    "source": "iana",
    "extensions": ["roa"]
  },
  "application/rpki-updown": {
    "source": "iana"
  },
  "application/rsd+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["rsd"]
  },
  "application/rss+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["rss"]
  },
  "application/rtf": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rtf"]
  },
  "application/rtploopback": {
    "source": "iana"
  },
  "application/rtx": {
    "source": "iana"
  },
  "application/samlassertion+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/samlmetadata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/sarif+json": {
    "source": "iana",
    "compressible": true
  },
  "application/sarif-external-properties+json": {
    "source": "iana",
    "compressible": true
  },
  "application/sbe": {
    "source": "iana"
  },
  "application/sbml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sbml"]
  },
  "application/scaip+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/scim+json": {
    "source": "iana",
    "compressible": true
  },
  "application/scvp-cv-request": {
    "source": "iana",
    "extensions": ["scq"]
  },
  "application/scvp-cv-response": {
    "source": "iana",
    "extensions": ["scs"]
  },
  "application/scvp-vp-request": {
    "source": "iana",
    "extensions": ["spq"]
  },
  "application/scvp-vp-response": {
    "source": "iana",
    "extensions": ["spp"]
  },
  "application/sdp": {
    "source": "iana",
    "extensions": ["sdp"]
  },
  "application/secevent+jwt": {
    "source": "iana"
  },
  "application/senml+cbor": {
    "source": "iana"
  },
  "application/senml+json": {
    "source": "iana",
    "compressible": true
  },
  "application/senml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["senmlx"]
  },
  "application/senml-etch+cbor": {
    "source": "iana"
  },
  "application/senml-etch+json": {
    "source": "iana",
    "compressible": true
  },
  "application/senml-exi": {
    "source": "iana"
  },
  "application/sensml+cbor": {
    "source": "iana"
  },
  "application/sensml+json": {
    "source": "iana",
    "compressible": true
  },
  "application/sensml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sensmlx"]
  },
  "application/sensml-exi": {
    "source": "iana"
  },
  "application/sep+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/sep-exi": {
    "source": "iana"
  },
  "application/session-info": {
    "source": "iana"
  },
  "application/set-payment": {
    "source": "iana"
  },
  "application/set-payment-initiation": {
    "source": "iana",
    "extensions": ["setpay"]
  },
  "application/set-registration": {
    "source": "iana"
  },
  "application/set-registration-initiation": {
    "source": "iana",
    "extensions": ["setreg"]
  },
  "application/sgml": {
    "source": "iana"
  },
  "application/sgml-open-catalog": {
    "source": "iana"
  },
  "application/shf+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["shf"]
  },
  "application/sieve": {
    "source": "iana",
    "extensions": ["siv","sieve"]
  },
  "application/simple-filter+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/simple-message-summary": {
    "source": "iana"
  },
  "application/simplesymbolcontainer": {
    "source": "iana"
  },
  "application/sipc": {
    "source": "iana"
  },
  "application/slate": {
    "source": "iana"
  },
  "application/smil": {
    "source": "iana"
  },
  "application/smil+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["smi","smil"]
  },
  "application/smpte336m": {
    "source": "iana"
  },
  "application/soap+fastinfoset": {
    "source": "iana"
  },
  "application/soap+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/sparql-query": {
    "source": "iana",
    "extensions": ["rq"]
  },
  "application/sparql-results+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["srx"]
  },
  "application/spdx+json": {
    "source": "iana",
    "compressible": true
  },
  "application/spirits-event+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/sql": {
    "source": "iana"
  },
  "application/srgs": {
    "source": "iana",
    "extensions": ["gram"]
  },
  "application/srgs+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["grxml"]
  },
  "application/sru+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sru"]
  },
  "application/ssdl+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["ssdl"]
  },
  "application/ssml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ssml"]
  },
  "application/stix+json": {
    "source": "iana",
    "compressible": true
  },
  "application/swid+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["swidtag"]
  },
  "application/tamp-apex-update": {
    "source": "iana"
  },
  "application/tamp-apex-update-confirm": {
    "source": "iana"
  },
  "application/tamp-community-update": {
    "source": "iana"
  },
  "application/tamp-community-update-confirm": {
    "source": "iana"
  },
  "application/tamp-error": {
    "source": "iana"
  },
  "application/tamp-sequence-adjust": {
    "source": "iana"
  },
  "application/tamp-sequence-adjust-confirm": {
    "source": "iana"
  },
  "application/tamp-status-query": {
    "source": "iana"
  },
  "application/tamp-status-response": {
    "source": "iana"
  },
  "application/tamp-update": {
    "source": "iana"
  },
  "application/tamp-update-confirm": {
    "source": "iana"
  },
  "application/tar": {
    "compressible": true
  },
  "application/taxii+json": {
    "source": "iana",
    "compressible": true
  },
  "application/td+json": {
    "source": "iana",
    "compressible": true
  },
  "application/tei+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["tei","teicorpus"]
  },
  "application/tetra_isi": {
    "source": "iana"
  },
  "application/thraud+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["tfi"]
  },
  "application/timestamp-query": {
    "source": "iana"
  },
  "application/timestamp-reply": {
    "source": "iana"
  },
  "application/timestamped-data": {
    "source": "iana",
    "extensions": ["tsd"]
  },
  "application/tlsrpt+gzip": {
    "source": "iana"
  },
  "application/tlsrpt+json": {
    "source": "iana",
    "compressible": true
  },
  "application/tnauthlist": {
    "source": "iana"
  },
  "application/token-introspection+jwt": {
    "source": "iana"
  },
  "application/toml": {
    "compressible": true,
    "extensions": ["toml"]
  },
  "application/trickle-ice-sdpfrag": {
    "source": "iana"
  },
  "application/trig": {
    "source": "iana",
    "extensions": ["trig"]
  },
  "application/ttml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ttml"]
  },
  "application/tve-trigger": {
    "source": "iana"
  },
  "application/tzif": {
    "source": "iana"
  },
  "application/tzif-leap": {
    "source": "iana"
  },
  "application/ubjson": {
    "compressible": false,
    "extensions": ["ubj"]
  },
  "application/ulpfec": {
    "source": "iana"
  },
  "application/urc-grpsheet+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/urc-ressheet+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rsheet"]
  },
  "application/urc-targetdesc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["td"]
  },
  "application/urc-uisocketdesc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vcard+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vcard+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vemmi": {
    "source": "iana"
  },
  "application/vividence.scriptfile": {
    "source": "apache"
  },
  "application/vnd.1000minds.decision-model+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["1km"]
  },
  "application/vnd.3gpp-prose+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp-prose-pc3ch+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp-v2x-local-service-information": {
    "source": "iana"
  },
  "application/vnd.3gpp.5gnas": {
    "source": "iana"
  },
  "application/vnd.3gpp.access-transfer-events+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.bsf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.gmop+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.gtpc": {
    "source": "iana"
  },
  "application/vnd.3gpp.interworking-data": {
    "source": "iana"
  },
  "application/vnd.3gpp.lpp": {
    "source": "iana"
  },
  "application/vnd.3gpp.mc-signalling-ear": {
    "source": "iana"
  },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcdata-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcdata-payload": {
    "source": "iana"
  },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcdata-signalling": {
    "source": "iana"
  },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-signed+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mid-call+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.ngap": {
    "source": "iana"
  },
  "application/vnd.3gpp.pfcp": {
    "source": "iana"
  },
  "application/vnd.3gpp.pic-bw-large": {
    "source": "iana",
    "extensions": ["plb"]
  },
  "application/vnd.3gpp.pic-bw-small": {
    "source": "iana",
    "extensions": ["psb"]
  },
  "application/vnd.3gpp.pic-bw-var": {
    "source": "iana",
    "extensions": ["pvb"]
  },
  "application/vnd.3gpp.s1ap": {
    "source": "iana"
  },
  "application/vnd.3gpp.sms": {
    "source": "iana"
  },
  "application/vnd.3gpp.sms+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.srvcc-ext+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.srvcc-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.state-and-event-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.ussd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp2.bcmcsinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp2.sms": {
    "source": "iana"
  },
  "application/vnd.3gpp2.tcap": {
    "source": "iana",
    "extensions": ["tcap"]
  },
  "application/vnd.3lightssoftware.imagescal": {
    "source": "iana"
  },
  "application/vnd.3m.post-it-notes": {
    "source": "iana",
    "extensions": ["pwn"]
  },
  "application/vnd.accpac.simply.aso": {
    "source": "iana",
    "extensions": ["aso"]
  },
  "application/vnd.accpac.simply.imp": {
    "source": "iana",
    "extensions": ["imp"]
  },
  "application/vnd.acucobol": {
    "source": "iana",
    "extensions": ["acu"]
  },
  "application/vnd.acucorp": {
    "source": "iana",
    "extensions": ["atc","acutc"]
  },
  "application/vnd.adobe.air-application-installer-package+zip": {
    "source": "apache",
    "compressible": false,
    "extensions": ["air"]
  },
  "application/vnd.adobe.flash.movie": {
    "source": "iana"
  },
  "application/vnd.adobe.formscentral.fcdt": {
    "source": "iana",
    "extensions": ["fcdt"]
  },
  "application/vnd.adobe.fxp": {
    "source": "iana",
    "extensions": ["fxp","fxpl"]
  },
  "application/vnd.adobe.partial-upload": {
    "source": "iana"
  },
  "application/vnd.adobe.xdp+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xdp"]
  },
  "application/vnd.adobe.xfdf": {
    "source": "iana",
    "extensions": ["xfdf"]
  },
  "application/vnd.aether.imp": {
    "source": "iana"
  },
  "application/vnd.afpc.afplinedata": {
    "source": "iana"
  },
  "application/vnd.afpc.afplinedata-pagedef": {
    "source": "iana"
  },
  "application/vnd.afpc.cmoca-cmresource": {
    "source": "iana"
  },
  "application/vnd.afpc.foca-charset": {
    "source": "iana"
  },
  "application/vnd.afpc.foca-codedfont": {
    "source": "iana"
  },
  "application/vnd.afpc.foca-codepage": {
    "source": "iana"
  },
  "application/vnd.afpc.modca": {
    "source": "iana"
  },
  "application/vnd.afpc.modca-cmtable": {
    "source": "iana"
  },
  "application/vnd.afpc.modca-formdef": {
    "source": "iana"
  },
  "application/vnd.afpc.modca-mediummap": {
    "source": "iana"
  },
  "application/vnd.afpc.modca-objectcontainer": {
    "source": "iana"
  },
  "application/vnd.afpc.modca-overlay": {
    "source": "iana"
  },
  "application/vnd.afpc.modca-pagesegment": {
    "source": "iana"
  },
  "application/vnd.age": {
    "source": "iana",
    "extensions": ["age"]
  },
  "application/vnd.ah-barcode": {
    "source": "iana"
  },
  "application/vnd.ahead.space": {
    "source": "iana",
    "extensions": ["ahead"]
  },
  "application/vnd.airzip.filesecure.azf": {
    "source": "iana",
    "extensions": ["azf"]
  },
  "application/vnd.airzip.filesecure.azs": {
    "source": "iana",
    "extensions": ["azs"]
  },
  "application/vnd.amadeus+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.amazon.ebook": {
    "source": "apache",
    "extensions": ["azw"]
  },
  "application/vnd.amazon.mobi8-ebook": {
    "source": "iana"
  },
  "application/vnd.americandynamics.acc": {
    "source": "iana",
    "extensions": ["acc"]
  },
  "application/vnd.amiga.ami": {
    "source": "iana",
    "extensions": ["ami"]
  },
  "application/vnd.amundsen.maze+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.android.ota": {
    "source": "iana"
  },
  "application/vnd.android.package-archive": {
    "source": "apache",
    "compressible": false,
    "extensions": ["apk"]
  },
  "application/vnd.anki": {
    "source": "iana"
  },
  "application/vnd.anser-web-certificate-issue-initiation": {
    "source": "iana",
    "extensions": ["cii"]
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    "source": "apache",
    "extensions": ["fti"]
  },
  "application/vnd.antix.game-component": {
    "source": "iana",
    "extensions": ["atx"]
  },
  "application/vnd.apache.arrow.file": {
    "source": "iana"
  },
  "application/vnd.apache.arrow.stream": {
    "source": "iana"
  },
  "application/vnd.apache.thrift.binary": {
    "source": "iana"
  },
  "application/vnd.apache.thrift.compact": {
    "source": "iana"
  },
  "application/vnd.apache.thrift.json": {
    "source": "iana"
  },
  "application/vnd.api+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.aplextor.warrp+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.apothekende.reservation+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.apple.installer+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mpkg"]
  },
  "application/vnd.apple.keynote": {
    "source": "iana",
    "extensions": ["key"]
  },
  "application/vnd.apple.mpegurl": {
    "source": "iana",
    "extensions": ["m3u8"]
  },
  "application/vnd.apple.numbers": {
    "source": "iana",
    "extensions": ["numbers"]
  },
  "application/vnd.apple.pages": {
    "source": "iana",
    "extensions": ["pages"]
  },
  "application/vnd.apple.pkpass": {
    "compressible": false,
    "extensions": ["pkpass"]
  },
  "application/vnd.arastra.swi": {
    "source": "iana"
  },
  "application/vnd.aristanetworks.swi": {
    "source": "iana",
    "extensions": ["swi"]
  },
  "application/vnd.artisan+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.artsquare": {
    "source": "iana"
  },
  "application/vnd.astraea-software.iota": {
    "source": "iana",
    "extensions": ["iota"]
  },
  "application/vnd.audiograph": {
    "source": "iana",
    "extensions": ["aep"]
  },
  "application/vnd.autopackage": {
    "source": "iana"
  },
  "application/vnd.avalon+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.avistar+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.balsamiq.bmml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["bmml"]
  },
  "application/vnd.balsamiq.bmpr": {
    "source": "iana"
  },
  "application/vnd.banana-accounting": {
    "source": "iana"
  },
  "application/vnd.bbf.usp.error": {
    "source": "iana"
  },
  "application/vnd.bbf.usp.msg": {
    "source": "iana"
  },
  "application/vnd.bbf.usp.msg+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.bekitzur-stech+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.bint.med-content": {
    "source": "iana"
  },
  "application/vnd.biopax.rdf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.blink-idb-value-wrapper": {
    "source": "iana"
  },
  "application/vnd.blueice.multipass": {
    "source": "iana",
    "extensions": ["mpm"]
  },
  "application/vnd.bluetooth.ep.oob": {
    "source": "iana"
  },
  "application/vnd.bluetooth.le.oob": {
    "source": "iana"
  },
  "application/vnd.bmi": {
    "source": "iana",
    "extensions": ["bmi"]
  },
  "application/vnd.bpf": {
    "source": "iana"
  },
  "application/vnd.bpf3": {
    "source": "iana"
  },
  "application/vnd.businessobjects": {
    "source": "iana",
    "extensions": ["rep"]
  },
  "application/vnd.byu.uapi+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cab-jscript": {
    "source": "iana"
  },
  "application/vnd.canon-cpdl": {
    "source": "iana"
  },
  "application/vnd.canon-lips": {
    "source": "iana"
  },
  "application/vnd.capasystems-pg+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cendio.thinlinc.clientconf": {
    "source": "iana"
  },
  "application/vnd.century-systems.tcp_stream": {
    "source": "iana"
  },
  "application/vnd.chemdraw+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["cdxml"]
  },
  "application/vnd.chess-pgn": {
    "source": "iana"
  },
  "application/vnd.chipnuts.karaoke-mmd": {
    "source": "iana",
    "extensions": ["mmd"]
  },
  "application/vnd.ciedi": {
    "source": "iana"
  },
  "application/vnd.cinderella": {
    "source": "iana",
    "extensions": ["cdy"]
  },
  "application/vnd.cirpack.isdn-ext": {
    "source": "iana"
  },
  "application/vnd.citationstyles.style+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["csl"]
  },
  "application/vnd.claymore": {
    "source": "iana",
    "extensions": ["cla"]
  },
  "application/vnd.cloanto.rp9": {
    "source": "iana",
    "extensions": ["rp9"]
  },
  "application/vnd.clonk.c4group": {
    "source": "iana",
    "extensions": ["c4g","c4d","c4f","c4p","c4u"]
  },
  "application/vnd.cluetrust.cartomobile-config": {
    "source": "iana",
    "extensions": ["c11amc"]
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    "source": "iana",
    "extensions": ["c11amz"]
  },
  "application/vnd.coffeescript": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.document": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.document-template": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.presentation": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.presentation-template": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    "source": "iana"
  },
  "application/vnd.collection+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.collection.doc+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.collection.next+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.comicbook+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.comicbook-rar": {
    "source": "iana"
  },
  "application/vnd.commerce-battelle": {
    "source": "iana"
  },
  "application/vnd.commonspace": {
    "source": "iana",
    "extensions": ["csp"]
  },
  "application/vnd.contact.cmsg": {
    "source": "iana",
    "extensions": ["cdbcmsg"]
  },
  "application/vnd.coreos.ignition+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cosmocaller": {
    "source": "iana",
    "extensions": ["cmc"]
  },
  "application/vnd.crick.clicker": {
    "source": "iana",
    "extensions": ["clkx"]
  },
  "application/vnd.crick.clicker.keyboard": {
    "source": "iana",
    "extensions": ["clkk"]
  },
  "application/vnd.crick.clicker.palette": {
    "source": "iana",
    "extensions": ["clkp"]
  },
  "application/vnd.crick.clicker.template": {
    "source": "iana",
    "extensions": ["clkt"]
  },
  "application/vnd.crick.clicker.wordbank": {
    "source": "iana",
    "extensions": ["clkw"]
  },
  "application/vnd.criticaltools.wbs+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wbs"]
  },
  "application/vnd.cryptii.pipe+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.crypto-shade-file": {
    "source": "iana"
  },
  "application/vnd.cryptomator.encrypted": {
    "source": "iana"
  },
  "application/vnd.cryptomator.vault": {
    "source": "iana"
  },
  "application/vnd.ctc-posml": {
    "source": "iana",
    "extensions": ["pml"]
  },
  "application/vnd.ctct.ws+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cups-pdf": {
    "source": "iana"
  },
  "application/vnd.cups-postscript": {
    "source": "iana"
  },
  "application/vnd.cups-ppd": {
    "source": "iana",
    "extensions": ["ppd"]
  },
  "application/vnd.cups-raster": {
    "source": "iana"
  },
  "application/vnd.cups-raw": {
    "source": "iana"
  },
  "application/vnd.curl": {
    "source": "iana"
  },
  "application/vnd.curl.car": {
    "source": "apache",
    "extensions": ["car"]
  },
  "application/vnd.curl.pcurl": {
    "source": "apache",
    "extensions": ["pcurl"]
  },
  "application/vnd.cyan.dean.root+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cybank": {
    "source": "iana"
  },
  "application/vnd.cyclonedx+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cyclonedx+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.d2l.coursepackage1p0+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.d3m-dataset": {
    "source": "iana"
  },
  "application/vnd.d3m-problem": {
    "source": "iana"
  },
  "application/vnd.dart": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dart"]
  },
  "application/vnd.data-vision.rdz": {
    "source": "iana",
    "extensions": ["rdz"]
  },
  "application/vnd.datapackage+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dataresource+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dbf": {
    "source": "iana",
    "extensions": ["dbf"]
  },
  "application/vnd.debian.binary-package": {
    "source": "iana"
  },
  "application/vnd.dece.data": {
    "source": "iana",
    "extensions": ["uvf","uvvf","uvd","uvvd"]
  },
  "application/vnd.dece.ttml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["uvt","uvvt"]
  },
  "application/vnd.dece.unspecified": {
    "source": "iana",
    "extensions": ["uvx","uvvx"]
  },
  "application/vnd.dece.zip": {
    "source": "iana",
    "extensions": ["uvz","uvvz"]
  },
  "application/vnd.denovo.fcselayout-link": {
    "source": "iana",
    "extensions": ["fe_launch"]
  },
  "application/vnd.desmume.movie": {
    "source": "iana"
  },
  "application/vnd.dir-bi.plate-dl-nosuffix": {
    "source": "iana"
  },
  "application/vnd.dm.delegation+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dna": {
    "source": "iana",
    "extensions": ["dna"]
  },
  "application/vnd.document+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dolby.mlp": {
    "source": "apache",
    "extensions": ["mlp"]
  },
  "application/vnd.dolby.mobile.1": {
    "source": "iana"
  },
  "application/vnd.dolby.mobile.2": {
    "source": "iana"
  },
  "application/vnd.doremir.scorecloud-binary-document": {
    "source": "iana"
  },
  "application/vnd.dpgraph": {
    "source": "iana",
    "extensions": ["dpg"]
  },
  "application/vnd.dreamfactory": {
    "source": "iana",
    "extensions": ["dfac"]
  },
  "application/vnd.drive+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ds-keypoint": {
    "source": "apache",
    "extensions": ["kpxx"]
  },
  "application/vnd.dtg.local": {
    "source": "iana"
  },
  "application/vnd.dtg.local.flash": {
    "source": "iana"
  },
  "application/vnd.dtg.local.html": {
    "source": "iana"
  },
  "application/vnd.dvb.ait": {
    "source": "iana",
    "extensions": ["ait"]
  },
  "application/vnd.dvb.dvbisl+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.dvbj": {
    "source": "iana"
  },
  "application/vnd.dvb.esgcontainer": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcdftnotifaccess": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcesgaccess": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcesgaccess2": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcesgpdd": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcroaming": {
    "source": "iana"
  },
  "application/vnd.dvb.iptv.alfec-base": {
    "source": "iana"
  },
  "application/vnd.dvb.iptv.alfec-enhancement": {
    "source": "iana"
  },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-container+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-generic+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-init+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.pfr": {
    "source": "iana"
  },
  "application/vnd.dvb.service": {
    "source": "iana",
    "extensions": ["svc"]
  },
  "application/vnd.dxr": {
    "source": "iana"
  },
  "application/vnd.dynageo": {
    "source": "iana",
    "extensions": ["geo"]
  },
  "application/vnd.dzr": {
    "source": "iana"
  },
  "application/vnd.easykaraoke.cdgdownload": {
    "source": "iana"
  },
  "application/vnd.ecdis-update": {
    "source": "iana"
  },
  "application/vnd.ecip.rlp": {
    "source": "iana"
  },
  "application/vnd.eclipse.ditto+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ecowin.chart": {
    "source": "iana",
    "extensions": ["mag"]
  },
  "application/vnd.ecowin.filerequest": {
    "source": "iana"
  },
  "application/vnd.ecowin.fileupdate": {
    "source": "iana"
  },
  "application/vnd.ecowin.series": {
    "source": "iana"
  },
  "application/vnd.ecowin.seriesrequest": {
    "source": "iana"
  },
  "application/vnd.ecowin.seriesupdate": {
    "source": "iana"
  },
  "application/vnd.efi.img": {
    "source": "iana"
  },
  "application/vnd.efi.iso": {
    "source": "iana"
  },
  "application/vnd.emclient.accessrequest+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.enliven": {
    "source": "iana",
    "extensions": ["nml"]
  },
  "application/vnd.enphase.envoy": {
    "source": "iana"
  },
  "application/vnd.eprints.data+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.epson.esf": {
    "source": "iana",
    "extensions": ["esf"]
  },
  "application/vnd.epson.msf": {
    "source": "iana",
    "extensions": ["msf"]
  },
  "application/vnd.epson.quickanime": {
    "source": "iana",
    "extensions": ["qam"]
  },
  "application/vnd.epson.salt": {
    "source": "iana",
    "extensions": ["slt"]
  },
  "application/vnd.epson.ssf": {
    "source": "iana",
    "extensions": ["ssf"]
  },
  "application/vnd.ericsson.quickcall": {
    "source": "iana"
  },
  "application/vnd.espass-espass+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.eszigno3+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["es3","et3"]
  },
  "application/vnd.etsi.aoc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.asic-e+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.etsi.asic-s+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.etsi.cug+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvcommand+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvdiscovery+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvprofile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvsad-bc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvsad-cod+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvsad-npvr+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvservice+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvsync+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvueprofile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.mcid+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.mheg5": {
    "source": "iana"
  },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.pstn+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.sci+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.simservs+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.timestamp-token": {
    "source": "iana"
  },
  "application/vnd.etsi.tsl+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.tsl.der": {
    "source": "iana"
  },
  "application/vnd.eu.kasparian.car+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.eudora.data": {
    "source": "iana"
  },
  "application/vnd.evolv.ecig.profile": {
    "source": "iana"
  },
  "application/vnd.evolv.ecig.settings": {
    "source": "iana"
  },
  "application/vnd.evolv.ecig.theme": {
    "source": "iana"
  },
  "application/vnd.exstream-empower+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.exstream-package": {
    "source": "iana"
  },
  "application/vnd.ezpix-album": {
    "source": "iana",
    "extensions": ["ez2"]
  },
  "application/vnd.ezpix-package": {
    "source": "iana",
    "extensions": ["ez3"]
  },
  "application/vnd.f-secure.mobile": {
    "source": "iana"
  },
  "application/vnd.familysearch.gedcom+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.fastcopy-disk-image": {
    "source": "iana"
  },
  "application/vnd.fdf": {
    "source": "iana",
    "extensions": ["fdf"]
  },
  "application/vnd.fdsn.mseed": {
    "source": "iana",
    "extensions": ["mseed"]
  },
  "application/vnd.fdsn.seed": {
    "source": "iana",
    "extensions": ["seed","dataless"]
  },
  "application/vnd.ffsns": {
    "source": "iana"
  },
  "application/vnd.ficlab.flb+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.filmit.zfc": {
    "source": "iana"
  },
  "application/vnd.fints": {
    "source": "iana"
  },
  "application/vnd.firemonkeys.cloudcell": {
    "source": "iana"
  },
  "application/vnd.flographit": {
    "source": "iana",
    "extensions": ["gph"]
  },
  "application/vnd.fluxtime.clip": {
    "source": "iana",
    "extensions": ["ftc"]
  },
  "application/vnd.font-fontforge-sfd": {
    "source": "iana"
  },
  "application/vnd.framemaker": {
    "source": "iana",
    "extensions": ["fm","frame","maker","book"]
  },
  "application/vnd.frogans.fnc": {
    "source": "iana",
    "extensions": ["fnc"]
  },
  "application/vnd.frogans.ltf": {
    "source": "iana",
    "extensions": ["ltf"]
  },
  "application/vnd.fsc.weblaunch": {
    "source": "iana",
    "extensions": ["fsc"]
  },
  "application/vnd.fujifilm.fb.docuworks": {
    "source": "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.binder": {
    "source": "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.container": {
    "source": "iana"
  },
  "application/vnd.fujifilm.fb.jfi+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.fujitsu.oasys": {
    "source": "iana",
    "extensions": ["oas"]
  },
  "application/vnd.fujitsu.oasys2": {
    "source": "iana",
    "extensions": ["oa2"]
  },
  "application/vnd.fujitsu.oasys3": {
    "source": "iana",
    "extensions": ["oa3"]
  },
  "application/vnd.fujitsu.oasysgp": {
    "source": "iana",
    "extensions": ["fg5"]
  },
  "application/vnd.fujitsu.oasysprs": {
    "source": "iana",
    "extensions": ["bh2"]
  },
  "application/vnd.fujixerox.art-ex": {
    "source": "iana"
  },
  "application/vnd.fujixerox.art4": {
    "source": "iana"
  },
  "application/vnd.fujixerox.ddd": {
    "source": "iana",
    "extensions": ["ddd"]
  },
  "application/vnd.fujixerox.docuworks": {
    "source": "iana",
    "extensions": ["xdw"]
  },
  "application/vnd.fujixerox.docuworks.binder": {
    "source": "iana",
    "extensions": ["xbd"]
  },
  "application/vnd.fujixerox.docuworks.container": {
    "source": "iana"
  },
  "application/vnd.fujixerox.hbpl": {
    "source": "iana"
  },
  "application/vnd.fut-misnet": {
    "source": "iana"
  },
  "application/vnd.futoin+cbor": {
    "source": "iana"
  },
  "application/vnd.futoin+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.fuzzysheet": {
    "source": "iana",
    "extensions": ["fzs"]
  },
  "application/vnd.genomatix.tuxedo": {
    "source": "iana",
    "extensions": ["txd"]
  },
  "application/vnd.gentics.grd+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.geo+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.geocube+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.geogebra.file": {
    "source": "iana",
    "extensions": ["ggb"]
  },
  "application/vnd.geogebra.slides": {
    "source": "iana"
  },
  "application/vnd.geogebra.tool": {
    "source": "iana",
    "extensions": ["ggt"]
  },
  "application/vnd.geometry-explorer": {
    "source": "iana",
    "extensions": ["gex","gre"]
  },
  "application/vnd.geonext": {
    "source": "iana",
    "extensions": ["gxt"]
  },
  "application/vnd.geoplan": {
    "source": "iana",
    "extensions": ["g2w"]
  },
  "application/vnd.geospace": {
    "source": "iana",
    "extensions": ["g3w"]
  },
  "application/vnd.gerber": {
    "source": "iana"
  },
  "application/vnd.globalplatform.card-content-mgt": {
    "source": "iana"
  },
  "application/vnd.globalplatform.card-content-mgt-response": {
    "source": "iana"
  },
  "application/vnd.gmx": {
    "source": "iana",
    "extensions": ["gmx"]
  },
  "application/vnd.google-apps.document": {
    "compressible": false,
    "extensions": ["gdoc"]
  },
  "application/vnd.google-apps.presentation": {
    "compressible": false,
    "extensions": ["gslides"]
  },
  "application/vnd.google-apps.spreadsheet": {
    "compressible": false,
    "extensions": ["gsheet"]
  },
  "application/vnd.google-earth.kml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["kml"]
  },
  "application/vnd.google-earth.kmz": {
    "source": "iana",
    "compressible": false,
    "extensions": ["kmz"]
  },
  "application/vnd.gov.sk.e-form+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.gov.sk.e-form+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.grafeq": {
    "source": "iana",
    "extensions": ["gqf","gqs"]
  },
  "application/vnd.gridmp": {
    "source": "iana"
  },
  "application/vnd.groove-account": {
    "source": "iana",
    "extensions": ["gac"]
  },
  "application/vnd.groove-help": {
    "source": "iana",
    "extensions": ["ghf"]
  },
  "application/vnd.groove-identity-message": {
    "source": "iana",
    "extensions": ["gim"]
  },
  "application/vnd.groove-injector": {
    "source": "iana",
    "extensions": ["grv"]
  },
  "application/vnd.groove-tool-message": {
    "source": "iana",
    "extensions": ["gtm"]
  },
  "application/vnd.groove-tool-template": {
    "source": "iana",
    "extensions": ["tpl"]
  },
  "application/vnd.groove-vcard": {
    "source": "iana",
    "extensions": ["vcg"]
  },
  "application/vnd.hal+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hal+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["hal"]
  },
  "application/vnd.handheld-entertainment+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["zmm"]
  },
  "application/vnd.hbci": {
    "source": "iana",
    "extensions": ["hbci"]
  },
  "application/vnd.hc+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hcl-bireports": {
    "source": "iana"
  },
  "application/vnd.hdt": {
    "source": "iana"
  },
  "application/vnd.heroku+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hhe.lesson-player": {
    "source": "iana",
    "extensions": ["les"]
  },
  "application/vnd.hl7cda+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/vnd.hl7v2+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/vnd.hp-hpgl": {
    "source": "iana",
    "extensions": ["hpgl"]
  },
  "application/vnd.hp-hpid": {
    "source": "iana",
    "extensions": ["hpid"]
  },
  "application/vnd.hp-hps": {
    "source": "iana",
    "extensions": ["hps"]
  },
  "application/vnd.hp-jlyt": {
    "source": "iana",
    "extensions": ["jlt"]
  },
  "application/vnd.hp-pcl": {
    "source": "iana",
    "extensions": ["pcl"]
  },
  "application/vnd.hp-pclxl": {
    "source": "iana",
    "extensions": ["pclxl"]
  },
  "application/vnd.httphone": {
    "source": "iana"
  },
  "application/vnd.hydrostatix.sof-data": {
    "source": "iana",
    "extensions": ["sfd-hdstx"]
  },
  "application/vnd.hyper+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hyper-item+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hyperdrive+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hzn-3d-crossword": {
    "source": "iana"
  },
  "application/vnd.ibm.afplinedata": {
    "source": "iana"
  },
  "application/vnd.ibm.electronic-media": {
    "source": "iana"
  },
  "application/vnd.ibm.minipay": {
    "source": "iana",
    "extensions": ["mpy"]
  },
  "application/vnd.ibm.modcap": {
    "source": "iana",
    "extensions": ["afp","listafp","list3820"]
  },
  "application/vnd.ibm.rights-management": {
    "source": "iana",
    "extensions": ["irm"]
  },
  "application/vnd.ibm.secure-container": {
    "source": "iana",
    "extensions": ["sc"]
  },
  "application/vnd.iccprofile": {
    "source": "iana",
    "extensions": ["icc","icm"]
  },
  "application/vnd.ieee.1905": {
    "source": "iana"
  },
  "application/vnd.igloader": {
    "source": "iana",
    "extensions": ["igl"]
  },
  "application/vnd.imagemeter.folder+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.imagemeter.image+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.immervision-ivp": {
    "source": "iana",
    "extensions": ["ivp"]
  },
  "application/vnd.immervision-ivu": {
    "source": "iana",
    "extensions": ["ivu"]
  },
  "application/vnd.ims.imsccv1p1": {
    "source": "iana"
  },
  "application/vnd.ims.imsccv1p2": {
    "source": "iana"
  },
  "application/vnd.ims.imsccv1p3": {
    "source": "iana"
  },
  "application/vnd.ims.lis.v2.result+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.informedcontrol.rms+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.informix-visionary": {
    "source": "iana"
  },
  "application/vnd.infotech.project": {
    "source": "iana"
  },
  "application/vnd.infotech.project+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.innopath.wamp.notification": {
    "source": "iana"
  },
  "application/vnd.insors.igm": {
    "source": "iana",
    "extensions": ["igm"]
  },
  "application/vnd.intercon.formnet": {
    "source": "iana",
    "extensions": ["xpw","xpx"]
  },
  "application/vnd.intergeo": {
    "source": "iana",
    "extensions": ["i2g"]
  },
  "application/vnd.intertrust.digibox": {
    "source": "iana"
  },
  "application/vnd.intertrust.nncp": {
    "source": "iana"
  },
  "application/vnd.intu.qbo": {
    "source": "iana",
    "extensions": ["qbo"]
  },
  "application/vnd.intu.qfx": {
    "source": "iana",
    "extensions": ["qfx"]
  },
  "application/vnd.iptc.g2.catalogitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.newsitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.newsmessage+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ipunplugged.rcprofile": {
    "source": "iana",
    "extensions": ["rcprofile"]
  },
  "application/vnd.irepository.package+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["irp"]
  },
  "application/vnd.is-xpr": {
    "source": "iana",
    "extensions": ["xpr"]
  },
  "application/vnd.isac.fcs": {
    "source": "iana",
    "extensions": ["fcs"]
  },
  "application/vnd.iso11783-10+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.jam": {
    "source": "iana",
    "extensions": ["jam"]
  },
  "application/vnd.japannet-directory-service": {
    "source": "iana"
  },
  "application/vnd.japannet-jpnstore-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-payment-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-registration": {
    "source": "iana"
  },
  "application/vnd.japannet-registration-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-setstore-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-verification": {
    "source": "iana"
  },
  "application/vnd.japannet-verification-wakeup": {
    "source": "iana"
  },
  "application/vnd.jcp.javame.midlet-rms": {
    "source": "iana",
    "extensions": ["rms"]
  },
  "application/vnd.jisp": {
    "source": "iana",
    "extensions": ["jisp"]
  },
  "application/vnd.joost.joda-archive": {
    "source": "iana",
    "extensions": ["joda"]
  },
  "application/vnd.jsk.isdn-ngn": {
    "source": "iana"
  },
  "application/vnd.kahootz": {
    "source": "iana",
    "extensions": ["ktz","ktr"]
  },
  "application/vnd.kde.karbon": {
    "source": "iana",
    "extensions": ["karbon"]
  },
  "application/vnd.kde.kchart": {
    "source": "iana",
    "extensions": ["chrt"]
  },
  "application/vnd.kde.kformula": {
    "source": "iana",
    "extensions": ["kfo"]
  },
  "application/vnd.kde.kivio": {
    "source": "iana",
    "extensions": ["flw"]
  },
  "application/vnd.kde.kontour": {
    "source": "iana",
    "extensions": ["kon"]
  },
  "application/vnd.kde.kpresenter": {
    "source": "iana",
    "extensions": ["kpr","kpt"]
  },
  "application/vnd.kde.kspread": {
    "source": "iana",
    "extensions": ["ksp"]
  },
  "application/vnd.kde.kword": {
    "source": "iana",
    "extensions": ["kwd","kwt"]
  },
  "application/vnd.kenameaapp": {
    "source": "iana",
    "extensions": ["htke"]
  },
  "application/vnd.kidspiration": {
    "source": "iana",
    "extensions": ["kia"]
  },
  "application/vnd.kinar": {
    "source": "iana",
    "extensions": ["kne","knp"]
  },
  "application/vnd.koan": {
    "source": "iana",
    "extensions": ["skp","skd","skt","skm"]
  },
  "application/vnd.kodak-descriptor": {
    "source": "iana",
    "extensions": ["sse"]
  },
  "application/vnd.las": {
    "source": "iana"
  },
  "application/vnd.las.las+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.las.las+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["lasxml"]
  },
  "application/vnd.laszip": {
    "source": "iana"
  },
  "application/vnd.leap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.liberty-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.llamagraphics.life-balance.desktop": {
    "source": "iana",
    "extensions": ["lbd"]
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["lbe"]
  },
  "application/vnd.logipipe.circuit+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.loom": {
    "source": "iana"
  },
  "application/vnd.lotus-1-2-3": {
    "source": "iana",
    "extensions": ["123"]
  },
  "application/vnd.lotus-approach": {
    "source": "iana",
    "extensions": ["apr"]
  },
  "application/vnd.lotus-freelance": {
    "source": "iana",
    "extensions": ["pre"]
  },
  "application/vnd.lotus-notes": {
    "source": "iana",
    "extensions": ["nsf"]
  },
  "application/vnd.lotus-organizer": {
    "source": "iana",
    "extensions": ["org"]
  },
  "application/vnd.lotus-screencam": {
    "source": "iana",
    "extensions": ["scm"]
  },
  "application/vnd.lotus-wordpro": {
    "source": "iana",
    "extensions": ["lwp"]
  },
  "application/vnd.macports.portpkg": {
    "source": "iana",
    "extensions": ["portpkg"]
  },
  "application/vnd.mapbox-vector-tile": {
    "source": "iana",
    "extensions": ["mvt"]
  },
  "application/vnd.marlin.drm.actiontoken+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.marlin.drm.license+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.marlin.drm.mdcf": {
    "source": "iana"
  },
  "application/vnd.mason+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.maxar.archive.3tz+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.maxmind.maxmind-db": {
    "source": "iana"
  },
  "application/vnd.mcd": {
    "source": "iana",
    "extensions": ["mcd"]
  },
  "application/vnd.medcalcdata": {
    "source": "iana",
    "extensions": ["mc1"]
  },
  "application/vnd.mediastation.cdkey": {
    "source": "iana",
    "extensions": ["cdkey"]
  },
  "application/vnd.meridian-slingshot": {
    "source": "iana"
  },
  "application/vnd.mfer": {
    "source": "iana",
    "extensions": ["mwf"]
  },
  "application/vnd.mfmp": {
    "source": "iana",
    "extensions": ["mfm"]
  },
  "application/vnd.micro+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.micrografx.flo": {
    "source": "iana",
    "extensions": ["flo"]
  },
  "application/vnd.micrografx.igx": {
    "source": "iana",
    "extensions": ["igx"]
  },
  "application/vnd.microsoft.portable-executable": {
    "source": "iana"
  },
  "application/vnd.microsoft.windows.thumbnail-cache": {
    "source": "iana"
  },
  "application/vnd.miele+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.mif": {
    "source": "iana",
    "extensions": ["mif"]
  },
  "application/vnd.minisoft-hp3000-save": {
    "source": "iana"
  },
  "application/vnd.mitsubishi.misty-guard.trustweb": {
    "source": "iana"
  },
  "application/vnd.mobius.daf": {
    "source": "iana",
    "extensions": ["daf"]
  },
  "application/vnd.mobius.dis": {
    "source": "iana",
    "extensions": ["dis"]
  },
  "application/vnd.mobius.mbk": {
    "source": "iana",
    "extensions": ["mbk"]
  },
  "application/vnd.mobius.mqy": {
    "source": "iana",
    "extensions": ["mqy"]
  },
  "application/vnd.mobius.msl": {
    "source": "iana",
    "extensions": ["msl"]
  },
  "application/vnd.mobius.plc": {
    "source": "iana",
    "extensions": ["plc"]
  },
  "application/vnd.mobius.txf": {
    "source": "iana",
    "extensions": ["txf"]
  },
  "application/vnd.mophun.application": {
    "source": "iana",
    "extensions": ["mpn"]
  },
  "application/vnd.mophun.certificate": {
    "source": "iana",
    "extensions": ["mpc"]
  },
  "application/vnd.motorola.flexsuite": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.adsi": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.fis": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.gotap": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.kmr": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.ttc": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.wem": {
    "source": "iana"
  },
  "application/vnd.motorola.iprm": {
    "source": "iana"
  },
  "application/vnd.mozilla.xul+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xul"]
  },
  "application/vnd.ms-3mfdocument": {
    "source": "iana"
  },
  "application/vnd.ms-artgalry": {
    "source": "iana",
    "extensions": ["cil"]
  },
  "application/vnd.ms-asf": {
    "source": "iana"
  },
  "application/vnd.ms-cab-compressed": {
    "source": "iana",
    "extensions": ["cab"]
  },
  "application/vnd.ms-color.iccprofile": {
    "source": "apache"
  },
  "application/vnd.ms-excel": {
    "source": "iana",
    "compressible": false,
    "extensions": ["xls","xlm","xla","xlc","xlt","xlw"]
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    "source": "iana",
    "extensions": ["xlam"]
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    "source": "iana",
    "extensions": ["xlsb"]
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    "source": "iana",
    "extensions": ["xlsm"]
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    "source": "iana",
    "extensions": ["xltm"]
  },
  "application/vnd.ms-fontobject": {
    "source": "iana",
    "compressible": true,
    "extensions": ["eot"]
  },
  "application/vnd.ms-htmlhelp": {
    "source": "iana",
    "extensions": ["chm"]
  },
  "application/vnd.ms-ims": {
    "source": "iana",
    "extensions": ["ims"]
  },
  "application/vnd.ms-lrm": {
    "source": "iana",
    "extensions": ["lrm"]
  },
  "application/vnd.ms-office.activex+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ms-officetheme": {
    "source": "iana",
    "extensions": ["thmx"]
  },
  "application/vnd.ms-opentype": {
    "source": "apache",
    "compressible": true
  },
  "application/vnd.ms-outlook": {
    "compressible": false,
    "extensions": ["msg"]
  },
  "application/vnd.ms-package.obfuscated-opentype": {
    "source": "apache"
  },
  "application/vnd.ms-pki.seccat": {
    "source": "apache",
    "extensions": ["cat"]
  },
  "application/vnd.ms-pki.stl": {
    "source": "apache",
    "extensions": ["stl"]
  },
  "application/vnd.ms-playready.initiator+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ms-powerpoint": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ppt","pps","pot"]
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    "source": "iana",
    "extensions": ["ppam"]
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    "source": "iana",
    "extensions": ["pptm"]
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    "source": "iana",
    "extensions": ["sldm"]
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    "source": "iana",
    "extensions": ["ppsm"]
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    "source": "iana",
    "extensions": ["potm"]
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ms-printing.printticket+xml": {
    "source": "apache",
    "compressible": true
  },
  "application/vnd.ms-printschematicket+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ms-project": {
    "source": "iana",
    "extensions": ["mpp","mpt"]
  },
  "application/vnd.ms-tnef": {
    "source": "iana"
  },
  "application/vnd.ms-windows.devicepairing": {
    "source": "iana"
  },
  "application/vnd.ms-windows.nwprinting.oob": {
    "source": "iana"
  },
  "application/vnd.ms-windows.printerpairing": {
    "source": "iana"
  },
  "application/vnd.ms-windows.wsd.oob": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.lic-chlg-req": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.lic-resp": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.meter-chlg-req": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.meter-resp": {
    "source": "iana"
  },
  "application/vnd.ms-word.document.macroenabled.12": {
    "source": "iana",
    "extensions": ["docm"]
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    "source": "iana",
    "extensions": ["dotm"]
  },
  "application/vnd.ms-works": {
    "source": "iana",
    "extensions": ["wps","wks","wcm","wdb"]
  },
  "application/vnd.ms-wpl": {
    "source": "iana",
    "extensions": ["wpl"]
  },
  "application/vnd.ms-xpsdocument": {
    "source": "iana",
    "compressible": false,
    "extensions": ["xps"]
  },
  "application/vnd.msa-disk-image": {
    "source": "iana"
  },
  "application/vnd.mseq": {
    "source": "iana",
    "extensions": ["mseq"]
  },
  "application/vnd.msign": {
    "source": "iana"
  },
  "application/vnd.multiad.creator": {
    "source": "iana"
  },
  "application/vnd.multiad.creator.cif": {
    "source": "iana"
  },
  "application/vnd.music-niff": {
    "source": "iana"
  },
  "application/vnd.musician": {
    "source": "iana",
    "extensions": ["mus"]
  },
  "application/vnd.muvee.style": {
    "source": "iana",
    "extensions": ["msty"]
  },
  "application/vnd.mynfc": {
    "source": "iana",
    "extensions": ["taglet"]
  },
  "application/vnd.nacamar.ybrid+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ncd.control": {
    "source": "iana"
  },
  "application/vnd.ncd.reference": {
    "source": "iana"
  },
  "application/vnd.nearst.inv+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nebumind.line": {
    "source": "iana"
  },
  "application/vnd.nervana": {
    "source": "iana"
  },
  "application/vnd.netfpx": {
    "source": "iana"
  },
  "application/vnd.neurolanguage.nlu": {
    "source": "iana",
    "extensions": ["nlu"]
  },
  "application/vnd.nimn": {
    "source": "iana"
  },
  "application/vnd.nintendo.nitro.rom": {
    "source": "iana"
  },
  "application/vnd.nintendo.snes.rom": {
    "source": "iana"
  },
  "application/vnd.nitf": {
    "source": "iana",
    "extensions": ["ntf","nitf"]
  },
  "application/vnd.noblenet-directory": {
    "source": "iana",
    "extensions": ["nnd"]
  },
  "application/vnd.noblenet-sealer": {
    "source": "iana",
    "extensions": ["nns"]
  },
  "application/vnd.noblenet-web": {
    "source": "iana",
    "extensions": ["nnw"]
  },
  "application/vnd.nokia.catalogs": {
    "source": "iana"
  },
  "application/vnd.nokia.conml+wbxml": {
    "source": "iana"
  },
  "application/vnd.nokia.conml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.iptv.config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.isds-radio-presets": {
    "source": "iana"
  },
  "application/vnd.nokia.landmark+wbxml": {
    "source": "iana"
  },
  "application/vnd.nokia.landmark+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.landmarkcollection+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ac"]
  },
  "application/vnd.nokia.n-gage.data": {
    "source": "iana",
    "extensions": ["ngdat"]
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    "source": "iana",
    "extensions": ["n-gage"]
  },
  "application/vnd.nokia.ncd": {
    "source": "iana"
  },
  "application/vnd.nokia.pcd+wbxml": {
    "source": "iana"
  },
  "application/vnd.nokia.pcd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.radio-preset": {
    "source": "iana",
    "extensions": ["rpst"]
  },
  "application/vnd.nokia.radio-presets": {
    "source": "iana",
    "extensions": ["rpss"]
  },
  "application/vnd.novadigm.edm": {
    "source": "iana",
    "extensions": ["edm"]
  },
  "application/vnd.novadigm.edx": {
    "source": "iana",
    "extensions": ["edx"]
  },
  "application/vnd.novadigm.ext": {
    "source": "iana",
    "extensions": ["ext"]
  },
  "application/vnd.ntt-local.content-share": {
    "source": "iana"
  },
  "application/vnd.ntt-local.file-transfer": {
    "source": "iana"
  },
  "application/vnd.ntt-local.ogw_remote-access": {
    "source": "iana"
  },
  "application/vnd.ntt-local.sip-ta_remote": {
    "source": "iana"
  },
  "application/vnd.ntt-local.sip-ta_tcp_stream": {
    "source": "iana"
  },
  "application/vnd.oasis.opendocument.chart": {
    "source": "iana",
    "extensions": ["odc"]
  },
  "application/vnd.oasis.opendocument.chart-template": {
    "source": "iana",
    "extensions": ["otc"]
  },
  "application/vnd.oasis.opendocument.database": {
    "source": "iana",
    "extensions": ["odb"]
  },
  "application/vnd.oasis.opendocument.formula": {
    "source": "iana",
    "extensions": ["odf"]
  },
  "application/vnd.oasis.opendocument.formula-template": {
    "source": "iana",
    "extensions": ["odft"]
  },
  "application/vnd.oasis.opendocument.graphics": {
    "source": "iana",
    "compressible": false,
    "extensions": ["odg"]
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    "source": "iana",
    "extensions": ["otg"]
  },
  "application/vnd.oasis.opendocument.image": {
    "source": "iana",
    "extensions": ["odi"]
  },
  "application/vnd.oasis.opendocument.image-template": {
    "source": "iana",
    "extensions": ["oti"]
  },
  "application/vnd.oasis.opendocument.presentation": {
    "source": "iana",
    "compressible": false,
    "extensions": ["odp"]
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    "source": "iana",
    "extensions": ["otp"]
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ods"]
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    "source": "iana",
    "extensions": ["ots"]
  },
  "application/vnd.oasis.opendocument.text": {
    "source": "iana",
    "compressible": false,
    "extensions": ["odt"]
  },
  "application/vnd.oasis.opendocument.text-master": {
    "source": "iana",
    "extensions": ["odm"]
  },
  "application/vnd.oasis.opendocument.text-template": {
    "source": "iana",
    "extensions": ["ott"]
  },
  "application/vnd.oasis.opendocument.text-web": {
    "source": "iana",
    "extensions": ["oth"]
  },
  "application/vnd.obn": {
    "source": "iana"
  },
  "application/vnd.ocf+cbor": {
    "source": "iana"
  },
  "application/vnd.oci.image.manifest.v1+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oftn.l10n+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.contentaccessdownload+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.cspg-hexbinary": {
    "source": "iana"
  },
  "application/vnd.oipf.dae.svg+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.dae.xhtml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.pae.gem": {
    "source": "iana"
  },
  "application/vnd.oipf.spdiscovery+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.spdlist+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.ueprofile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.userprofile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.olpc-sugar": {
    "source": "iana",
    "extensions": ["xo"]
  },
  "application/vnd.oma-scws-config": {
    "source": "iana"
  },
  "application/vnd.oma-scws-http-request": {
    "source": "iana"
  },
  "application/vnd.oma-scws-http-response": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.imd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.ltkm": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.notification+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.provisioningtrigger": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.sgboot": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.sgdd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.sgdu": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.simple-symbol-container": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.sprov+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.stkm": {
    "source": "iana"
  },
  "application/vnd.oma.cab-address-book+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.cab-pcc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.cab-subs-invite+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.dcd": {
    "source": "iana"
  },
  "application/vnd.oma.dcdc": {
    "source": "iana"
  },
  "application/vnd.oma.dd2+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dd2"]
  },
  "application/vnd.oma.drm.risd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.group-usage-list+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.lwm2m+cbor": {
    "source": "iana"
  },
  "application/vnd.oma.lwm2m+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.lwm2m+tlv": {
    "source": "iana"
  },
  "application/vnd.oma.pal+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.final-report+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.groups+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.push": {
    "source": "iana"
  },
  "application/vnd.oma.scidm.messages+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.xcap-directory+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.omads-email+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/vnd.omads-file+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/vnd.omads-folder+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/vnd.omaloc-supl-init": {
    "source": "iana"
  },
  "application/vnd.onepager": {
    "source": "iana"
  },
  "application/vnd.onepagertamp": {
    "source": "iana"
  },
  "application/vnd.onepagertamx": {
    "source": "iana"
  },
  "application/vnd.onepagertat": {
    "source": "iana"
  },
  "application/vnd.onepagertatp": {
    "source": "iana"
  },
  "application/vnd.onepagertatx": {
    "source": "iana"
  },
  "application/vnd.openblox.game+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["obgx"]
  },
  "application/vnd.openblox.game-binary": {
    "source": "iana"
  },
  "application/vnd.openeye.oeb": {
    "source": "iana"
  },
  "application/vnd.openofficeorg.extension": {
    "source": "apache",
    "extensions": ["oxt"]
  },
  "application/vnd.openstreetmap.data+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["osm"]
  },
  "application/vnd.opentimestamps.ots": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    "source": "iana",
    "compressible": false,
    "extensions": ["pptx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    "source": "iana",
    "extensions": ["sldx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    "source": "iana",
    "extensions": ["ppsx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    "source": "iana",
    "extensions": ["potx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    "source": "iana",
    "compressible": false,
    "extensions": ["xlsx"]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    "source": "iana",
    "extensions": ["xltx"]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    "source": "iana",
    "compressible": false,
    "extensions": ["docx"]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    "source": "iana",
    "extensions": ["dotx"]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oracle.resource+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.orange.indata": {
    "source": "iana"
  },
  "application/vnd.osa.netdeploy": {
    "source": "iana"
  },
  "application/vnd.osgeo.mapguide.package": {
    "source": "iana",
    "extensions": ["mgp"]
  },
  "application/vnd.osgi.bundle": {
    "source": "iana"
  },
  "application/vnd.osgi.dp": {
    "source": "iana",
    "extensions": ["dp"]
  },
  "application/vnd.osgi.subsystem": {
    "source": "iana",
    "extensions": ["esa"]
  },
  "application/vnd.otps.ct-kip+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oxli.countgraph": {
    "source": "iana"
  },
  "application/vnd.pagerduty+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.palm": {
    "source": "iana",
    "extensions": ["pdb","pqa","oprc"]
  },
  "application/vnd.panoply": {
    "source": "iana"
  },
  "application/vnd.paos.xml": {
    "source": "iana"
  },
  "application/vnd.patentdive": {
    "source": "iana"
  },
  "application/vnd.patientecommsdoc": {
    "source": "iana"
  },
  "application/vnd.pawaafile": {
    "source": "iana",
    "extensions": ["paw"]
  },
  "application/vnd.pcos": {
    "source": "iana"
  },
  "application/vnd.pg.format": {
    "source": "iana",
    "extensions": ["str"]
  },
  "application/vnd.pg.osasli": {
    "source": "iana",
    "extensions": ["ei6"]
  },
  "application/vnd.piaccess.application-licence": {
    "source": "iana"
  },
  "application/vnd.picsel": {
    "source": "iana",
    "extensions": ["efif"]
  },
  "application/vnd.pmi.widget": {
    "source": "iana",
    "extensions": ["wg"]
  },
  "application/vnd.poc.group-advertisement+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.pocketlearn": {
    "source": "iana",
    "extensions": ["plf"]
  },
  "application/vnd.powerbuilder6": {
    "source": "iana",
    "extensions": ["pbd"]
  },
  "application/vnd.powerbuilder6-s": {
    "source": "iana"
  },
  "application/vnd.powerbuilder7": {
    "source": "iana"
  },
  "application/vnd.powerbuilder7-s": {
    "source": "iana"
  },
  "application/vnd.powerbuilder75": {
    "source": "iana"
  },
  "application/vnd.powerbuilder75-s": {
    "source": "iana"
  },
  "application/vnd.preminet": {
    "source": "iana"
  },
  "application/vnd.previewsystems.box": {
    "source": "iana",
    "extensions": ["box"]
  },
  "application/vnd.proteus.magazine": {
    "source": "iana",
    "extensions": ["mgz"]
  },
  "application/vnd.psfs": {
    "source": "iana"
  },
  "application/vnd.publishare-delta-tree": {
    "source": "iana",
    "extensions": ["qps"]
  },
  "application/vnd.pvi.ptid1": {
    "source": "iana",
    "extensions": ["ptid"]
  },
  "application/vnd.pwg-multiplexed": {
    "source": "iana"
  },
  "application/vnd.pwg-xhtml-print+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.qualcomm.brew-app-res": {
    "source": "iana"
  },
  "application/vnd.quarantainenet": {
    "source": "iana"
  },
  "application/vnd.quark.quarkxpress": {
    "source": "iana",
    "extensions": ["qxd","qxt","qwd","qwt","qxl","qxb"]
  },
  "application/vnd.quobject-quoxdocument": {
    "source": "iana"
  },
  "application/vnd.radisys.moml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-conf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.rainstor.data": {
    "source": "iana"
  },
  "application/vnd.rapid": {
    "source": "iana"
  },
  "application/vnd.rar": {
    "source": "iana",
    "extensions": ["rar"]
  },
  "application/vnd.realvnc.bed": {
    "source": "iana",
    "extensions": ["bed"]
  },
  "application/vnd.recordare.musicxml": {
    "source": "iana",
    "extensions": ["mxl"]
  },
  "application/vnd.recordare.musicxml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["musicxml"]
  },
  "application/vnd.renlearn.rlprint": {
    "source": "iana"
  },
  "application/vnd.resilient.logic": {
    "source": "iana"
  },
  "application/vnd.restful+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.rig.cryptonote": {
    "source": "iana",
    "extensions": ["cryptonote"]
  },
  "application/vnd.rim.cod": {
    "source": "apache",
    "extensions": ["cod"]
  },
  "application/vnd.rn-realmedia": {
    "source": "apache",
    "extensions": ["rm"]
  },
  "application/vnd.rn-realmedia-vbr": {
    "source": "apache",
    "extensions": ["rmvb"]
  },
  "application/vnd.route66.link66+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["link66"]
  },
  "application/vnd.rs-274x": {
    "source": "iana"
  },
  "application/vnd.ruckus.download": {
    "source": "iana"
  },
  "application/vnd.s3sms": {
    "source": "iana"
  },
  "application/vnd.sailingtracker.track": {
    "source": "iana",
    "extensions": ["st"]
  },
  "application/vnd.sar": {
    "source": "iana"
  },
  "application/vnd.sbm.cid": {
    "source": "iana"
  },
  "application/vnd.sbm.mid2": {
    "source": "iana"
  },
  "application/vnd.scribus": {
    "source": "iana"
  },
  "application/vnd.sealed.3df": {
    "source": "iana"
  },
  "application/vnd.sealed.csf": {
    "source": "iana"
  },
  "application/vnd.sealed.doc": {
    "source": "iana"
  },
  "application/vnd.sealed.eml": {
    "source": "iana"
  },
  "application/vnd.sealed.mht": {
    "source": "iana"
  },
  "application/vnd.sealed.net": {
    "source": "iana"
  },
  "application/vnd.sealed.ppt": {
    "source": "iana"
  },
  "application/vnd.sealed.tiff": {
    "source": "iana"
  },
  "application/vnd.sealed.xls": {
    "source": "iana"
  },
  "application/vnd.sealedmedia.softseal.html": {
    "source": "iana"
  },
  "application/vnd.sealedmedia.softseal.pdf": {
    "source": "iana"
  },
  "application/vnd.seemail": {
    "source": "iana",
    "extensions": ["see"]
  },
  "application/vnd.seis+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.sema": {
    "source": "iana",
    "extensions": ["sema"]
  },
  "application/vnd.semd": {
    "source": "iana",
    "extensions": ["semd"]
  },
  "application/vnd.semf": {
    "source": "iana",
    "extensions": ["semf"]
  },
  "application/vnd.shade-save-file": {
    "source": "iana"
  },
  "application/vnd.shana.informed.formdata": {
    "source": "iana",
    "extensions": ["ifm"]
  },
  "application/vnd.shana.informed.formtemplate": {
    "source": "iana",
    "extensions": ["itp"]
  },
  "application/vnd.shana.informed.interchange": {
    "source": "iana",
    "extensions": ["iif"]
  },
  "application/vnd.shana.informed.package": {
    "source": "iana",
    "extensions": ["ipk"]
  },
  "application/vnd.shootproof+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.shopkick+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.shp": {
    "source": "iana"
  },
  "application/vnd.shx": {
    "source": "iana"
  },
  "application/vnd.sigrok.session": {
    "source": "iana"
  },
  "application/vnd.simtech-mindmapper": {
    "source": "iana",
    "extensions": ["twd","twds"]
  },
  "application/vnd.siren+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.smaf": {
    "source": "iana",
    "extensions": ["mmf"]
  },
  "application/vnd.smart.notebook": {
    "source": "iana"
  },
  "application/vnd.smart.teacher": {
    "source": "iana",
    "extensions": ["teacher"]
  },
  "application/vnd.snesdev-page-table": {
    "source": "iana"
  },
  "application/vnd.software602.filler.form+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["fo"]
  },
  "application/vnd.software602.filler.form-xml-zip": {
    "source": "iana"
  },
  "application/vnd.solent.sdkm+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sdkm","sdkd"]
  },
  "application/vnd.spotfire.dxp": {
    "source": "iana",
    "extensions": ["dxp"]
  },
  "application/vnd.spotfire.sfs": {
    "source": "iana",
    "extensions": ["sfs"]
  },
  "application/vnd.sqlite3": {
    "source": "iana"
  },
  "application/vnd.sss-cod": {
    "source": "iana"
  },
  "application/vnd.sss-dtf": {
    "source": "iana"
  },
  "application/vnd.sss-ntf": {
    "source": "iana"
  },
  "application/vnd.stardivision.calc": {
    "source": "apache",
    "extensions": ["sdc"]
  },
  "application/vnd.stardivision.draw": {
    "source": "apache",
    "extensions": ["sda"]
  },
  "application/vnd.stardivision.impress": {
    "source": "apache",
    "extensions": ["sdd"]
  },
  "application/vnd.stardivision.math": {
    "source": "apache",
    "extensions": ["smf"]
  },
  "application/vnd.stardivision.writer": {
    "source": "apache",
    "extensions": ["sdw","vor"]
  },
  "application/vnd.stardivision.writer-global": {
    "source": "apache",
    "extensions": ["sgl"]
  },
  "application/vnd.stepmania.package": {
    "source": "iana",
    "extensions": ["smzip"]
  },
  "application/vnd.stepmania.stepchart": {
    "source": "iana",
    "extensions": ["sm"]
  },
  "application/vnd.street-stream": {
    "source": "iana"
  },
  "application/vnd.sun.wadl+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wadl"]
  },
  "application/vnd.sun.xml.calc": {
    "source": "apache",
    "extensions": ["sxc"]
  },
  "application/vnd.sun.xml.calc.template": {
    "source": "apache",
    "extensions": ["stc"]
  },
  "application/vnd.sun.xml.draw": {
    "source": "apache",
    "extensions": ["sxd"]
  },
  "application/vnd.sun.xml.draw.template": {
    "source": "apache",
    "extensions": ["std"]
  },
  "application/vnd.sun.xml.impress": {
    "source": "apache",
    "extensions": ["sxi"]
  },
  "application/vnd.sun.xml.impress.template": {
    "source": "apache",
    "extensions": ["sti"]
  },
  "application/vnd.sun.xml.math": {
    "source": "apache",
    "extensions": ["sxm"]
  },
  "application/vnd.sun.xml.writer": {
    "source": "apache",
    "extensions": ["sxw"]
  },
  "application/vnd.sun.xml.writer.global": {
    "source": "apache",
    "extensions": ["sxg"]
  },
  "application/vnd.sun.xml.writer.template": {
    "source": "apache",
    "extensions": ["stw"]
  },
  "application/vnd.sus-calendar": {
    "source": "iana",
    "extensions": ["sus","susp"]
  },
  "application/vnd.svd": {
    "source": "iana",
    "extensions": ["svd"]
  },
  "application/vnd.swiftview-ics": {
    "source": "iana"
  },
  "application/vnd.sycle+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.syft+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.symbian.install": {
    "source": "apache",
    "extensions": ["sis","sisx"]
  },
  "application/vnd.syncml+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["xsm"]
  },
  "application/vnd.syncml.dm+wbxml": {
    "source": "iana",
    "charset": "UTF-8",
    "extensions": ["bdm"]
  },
  "application/vnd.syncml.dm+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["xdm"]
  },
  "application/vnd.syncml.dm.notification": {
    "source": "iana"
  },
  "application/vnd.syncml.dmddf+wbxml": {
    "source": "iana"
  },
  "application/vnd.syncml.dmddf+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["ddf"]
  },
  "application/vnd.syncml.dmtnds+wbxml": {
    "source": "iana"
  },
  "application/vnd.syncml.dmtnds+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/vnd.syncml.ds.notification": {
    "source": "iana"
  },
  "application/vnd.tableschema+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.tao.intent-module-archive": {
    "source": "iana",
    "extensions": ["tao"]
  },
  "application/vnd.tcpdump.pcap": {
    "source": "iana",
    "extensions": ["pcap","cap","dmp"]
  },
  "application/vnd.think-cell.ppttc+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.tmd.mediaflex.api+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.tml": {
    "source": "iana"
  },
  "application/vnd.tmobile-livetv": {
    "source": "iana",
    "extensions": ["tmo"]
  },
  "application/vnd.tri.onesource": {
    "source": "iana"
  },
  "application/vnd.trid.tpt": {
    "source": "iana",
    "extensions": ["tpt"]
  },
  "application/vnd.triscape.mxs": {
    "source": "iana",
    "extensions": ["mxs"]
  },
  "application/vnd.trueapp": {
    "source": "iana",
    "extensions": ["tra"]
  },
  "application/vnd.truedoc": {
    "source": "iana"
  },
  "application/vnd.ubisoft.webplayer": {
    "source": "iana"
  },
  "application/vnd.ufdl": {
    "source": "iana",
    "extensions": ["ufd","ufdl"]
  },
  "application/vnd.uiq.theme": {
    "source": "iana",
    "extensions": ["utz"]
  },
  "application/vnd.umajin": {
    "source": "iana",
    "extensions": ["umj"]
  },
  "application/vnd.unity": {
    "source": "iana",
    "extensions": ["unityweb"]
  },
  "application/vnd.uoml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["uoml"]
  },
  "application/vnd.uplanet.alert": {
    "source": "iana"
  },
  "application/vnd.uplanet.alert-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.bearer-choice": {
    "source": "iana"
  },
  "application/vnd.uplanet.bearer-choice-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.cacheop": {
    "source": "iana"
  },
  "application/vnd.uplanet.cacheop-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.channel": {
    "source": "iana"
  },
  "application/vnd.uplanet.channel-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.list": {
    "source": "iana"
  },
  "application/vnd.uplanet.list-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.listcmd": {
    "source": "iana"
  },
  "application/vnd.uplanet.listcmd-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.signal": {
    "source": "iana"
  },
  "application/vnd.uri-map": {
    "source": "iana"
  },
  "application/vnd.valve.source.material": {
    "source": "iana"
  },
  "application/vnd.vcx": {
    "source": "iana",
    "extensions": ["vcx"]
  },
  "application/vnd.vd-study": {
    "source": "iana"
  },
  "application/vnd.vectorworks": {
    "source": "iana"
  },
  "application/vnd.vel+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.verimatrix.vcas": {
    "source": "iana"
  },
  "application/vnd.veritone.aion+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.veryant.thin": {
    "source": "iana"
  },
  "application/vnd.ves.encrypted": {
    "source": "iana"
  },
  "application/vnd.vidsoft.vidconference": {
    "source": "iana"
  },
  "application/vnd.visio": {
    "source": "iana",
    "extensions": ["vsd","vst","vss","vsw"]
  },
  "application/vnd.visionary": {
    "source": "iana",
    "extensions": ["vis"]
  },
  "application/vnd.vividence.scriptfile": {
    "source": "iana"
  },
  "application/vnd.vsf": {
    "source": "iana",
    "extensions": ["vsf"]
  },
  "application/vnd.wap.sic": {
    "source": "iana"
  },
  "application/vnd.wap.slc": {
    "source": "iana"
  },
  "application/vnd.wap.wbxml": {
    "source": "iana",
    "charset": "UTF-8",
    "extensions": ["wbxml"]
  },
  "application/vnd.wap.wmlc": {
    "source": "iana",
    "extensions": ["wmlc"]
  },
  "application/vnd.wap.wmlscriptc": {
    "source": "iana",
    "extensions": ["wmlsc"]
  },
  "application/vnd.webturbo": {
    "source": "iana",
    "extensions": ["wtb"]
  },
  "application/vnd.wfa.dpp": {
    "source": "iana"
  },
  "application/vnd.wfa.p2p": {
    "source": "iana"
  },
  "application/vnd.wfa.wsc": {
    "source": "iana"
  },
  "application/vnd.windows.devicepairing": {
    "source": "iana"
  },
  "application/vnd.wmc": {
    "source": "iana"
  },
  "application/vnd.wmf.bootstrap": {
    "source": "iana"
  },
  "application/vnd.wolfram.mathematica": {
    "source": "iana"
  },
  "application/vnd.wolfram.mathematica.package": {
    "source": "iana"
  },
  "application/vnd.wolfram.player": {
    "source": "iana",
    "extensions": ["nbp"]
  },
  "application/vnd.wordperfect": {
    "source": "iana",
    "extensions": ["wpd"]
  },
  "application/vnd.wqd": {
    "source": "iana",
    "extensions": ["wqd"]
  },
  "application/vnd.wrq-hp3000-labelled": {
    "source": "iana"
  },
  "application/vnd.wt.stf": {
    "source": "iana",
    "extensions": ["stf"]
  },
  "application/vnd.wv.csp+wbxml": {
    "source": "iana"
  },
  "application/vnd.wv.csp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.wv.ssp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.xacml+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.xara": {
    "source": "iana",
    "extensions": ["xar"]
  },
  "application/vnd.xfdl": {
    "source": "iana",
    "extensions": ["xfdl"]
  },
  "application/vnd.xfdl.webform": {
    "source": "iana"
  },
  "application/vnd.xmi+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.xmpie.cpkg": {
    "source": "iana"
  },
  "application/vnd.xmpie.dpkg": {
    "source": "iana"
  },
  "application/vnd.xmpie.plan": {
    "source": "iana"
  },
  "application/vnd.xmpie.ppkg": {
    "source": "iana"
  },
  "application/vnd.xmpie.xlim": {
    "source": "iana"
  },
  "application/vnd.yamaha.hv-dic": {
    "source": "iana",
    "extensions": ["hvd"]
  },
  "application/vnd.yamaha.hv-script": {
    "source": "iana",
    "extensions": ["hvs"]
  },
  "application/vnd.yamaha.hv-voice": {
    "source": "iana",
    "extensions": ["hvp"]
  },
  "application/vnd.yamaha.openscoreformat": {
    "source": "iana",
    "extensions": ["osf"]
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["osfpvg"]
  },
  "application/vnd.yamaha.remote-setup": {
    "source": "iana"
  },
  "application/vnd.yamaha.smaf-audio": {
    "source": "iana",
    "extensions": ["saf"]
  },
  "application/vnd.yamaha.smaf-phrase": {
    "source": "iana",
    "extensions": ["spf"]
  },
  "application/vnd.yamaha.through-ngn": {
    "source": "iana"
  },
  "application/vnd.yamaha.tunnel-udpencap": {
    "source": "iana"
  },
  "application/vnd.yaoweme": {
    "source": "iana"
  },
  "application/vnd.yellowriver-custom-menu": {
    "source": "iana",
    "extensions": ["cmp"]
  },
  "application/vnd.youtube.yt": {
    "source": "iana"
  },
  "application/vnd.zul": {
    "source": "iana",
    "extensions": ["zir","zirz"]
  },
  "application/vnd.zzazz.deck+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["zaz"]
  },
  "application/voicexml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["vxml"]
  },
  "application/voucher-cms+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vq-rtcpxr": {
    "source": "iana"
  },
  "application/wasm": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wasm"]
  },
  "application/watcherinfo+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wif"]
  },
  "application/webpush-options+json": {
    "source": "iana",
    "compressible": true
  },
  "application/whoispp-query": {
    "source": "iana"
  },
  "application/whoispp-response": {
    "source": "iana"
  },
  "application/widget": {
    "source": "iana",
    "extensions": ["wgt"]
  },
  "application/winhlp": {
    "source": "apache",
    "extensions": ["hlp"]
  },
  "application/wita": {
    "source": "iana"
  },
  "application/wordperfect5.1": {
    "source": "iana"
  },
  "application/wsdl+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wsdl"]
  },
  "application/wspolicy+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wspolicy"]
  },
  "application/x-7z-compressed": {
    "source": "apache",
    "compressible": false,
    "extensions": ["7z"]
  },
  "application/x-abiword": {
    "source": "apache",
    "extensions": ["abw"]
  },
  "application/x-ace-compressed": {
    "source": "apache",
    "extensions": ["ace"]
  },
  "application/x-amf": {
    "source": "apache"
  },
  "application/x-apple-diskimage": {
    "source": "apache",
    "extensions": ["dmg"]
  },
  "application/x-arj": {
    "compressible": false,
    "extensions": ["arj"]
  },
  "application/x-authorware-bin": {
    "source": "apache",
    "extensions": ["aab","x32","u32","vox"]
  },
  "application/x-authorware-map": {
    "source": "apache",
    "extensions": ["aam"]
  },
  "application/x-authorware-seg": {
    "source": "apache",
    "extensions": ["aas"]
  },
  "application/x-bcpio": {
    "source": "apache",
    "extensions": ["bcpio"]
  },
  "application/x-bdoc": {
    "compressible": false,
    "extensions": ["bdoc"]
  },
  "application/x-bittorrent": {
    "source": "apache",
    "extensions": ["torrent"]
  },
  "application/x-blorb": {
    "source": "apache",
    "extensions": ["blb","blorb"]
  },
  "application/x-bzip": {
    "source": "apache",
    "compressible": false,
    "extensions": ["bz"]
  },
  "application/x-bzip2": {
    "source": "apache",
    "compressible": false,
    "extensions": ["bz2","boz"]
  },
  "application/x-cbr": {
    "source": "apache",
    "extensions": ["cbr","cba","cbt","cbz","cb7"]
  },
  "application/x-cdlink": {
    "source": "apache",
    "extensions": ["vcd"]
  },
  "application/x-cfs-compressed": {
    "source": "apache",
    "extensions": ["cfs"]
  },
  "application/x-chat": {
    "source": "apache",
    "extensions": ["chat"]
  },
  "application/x-chess-pgn": {
    "source": "apache",
    "extensions": ["pgn"]
  },
  "application/x-chrome-extension": {
    "extensions": ["crx"]
  },
  "application/x-cocoa": {
    "source": "nginx",
    "extensions": ["cco"]
  },
  "application/x-compress": {
    "source": "apache"
  },
  "application/x-conference": {
    "source": "apache",
    "extensions": ["nsc"]
  },
  "application/x-cpio": {
    "source": "apache",
    "extensions": ["cpio"]
  },
  "application/x-csh": {
    "source": "apache",
    "extensions": ["csh"]
  },
  "application/x-deb": {
    "compressible": false
  },
  "application/x-debian-package": {
    "source": "apache",
    "extensions": ["deb","udeb"]
  },
  "application/x-dgc-compressed": {
    "source": "apache",
    "extensions": ["dgc"]
  },
  "application/x-director": {
    "source": "apache",
    "extensions": ["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]
  },
  "application/x-doom": {
    "source": "apache",
    "extensions": ["wad"]
  },
  "application/x-dtbncx+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["ncx"]
  },
  "application/x-dtbook+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["dtb"]
  },
  "application/x-dtbresource+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["res"]
  },
  "application/x-dvi": {
    "source": "apache",
    "compressible": false,
    "extensions": ["dvi"]
  },
  "application/x-envoy": {
    "source": "apache",
    "extensions": ["evy"]
  },
  "application/x-eva": {
    "source": "apache",
    "extensions": ["eva"]
  },
  "application/x-font-bdf": {
    "source": "apache",
    "extensions": ["bdf"]
  },
  "application/x-font-dos": {
    "source": "apache"
  },
  "application/x-font-framemaker": {
    "source": "apache"
  },
  "application/x-font-ghostscript": {
    "source": "apache",
    "extensions": ["gsf"]
  },
  "application/x-font-libgrx": {
    "source": "apache"
  },
  "application/x-font-linux-psf": {
    "source": "apache",
    "extensions": ["psf"]
  },
  "application/x-font-pcf": {
    "source": "apache",
    "extensions": ["pcf"]
  },
  "application/x-font-snf": {
    "source": "apache",
    "extensions": ["snf"]
  },
  "application/x-font-speedo": {
    "source": "apache"
  },
  "application/x-font-sunos-news": {
    "source": "apache"
  },
  "application/x-font-type1": {
    "source": "apache",
    "extensions": ["pfa","pfb","pfm","afm"]
  },
  "application/x-font-vfont": {
    "source": "apache"
  },
  "application/x-freearc": {
    "source": "apache",
    "extensions": ["arc"]
  },
  "application/x-futuresplash": {
    "source": "apache",
    "extensions": ["spl"]
  },
  "application/x-gca-compressed": {
    "source": "apache",
    "extensions": ["gca"]
  },
  "application/x-glulx": {
    "source": "apache",
    "extensions": ["ulx"]
  },
  "application/x-gnumeric": {
    "source": "apache",
    "extensions": ["gnumeric"]
  },
  "application/x-gramps-xml": {
    "source": "apache",
    "extensions": ["gramps"]
  },
  "application/x-gtar": {
    "source": "apache",
    "extensions": ["gtar"]
  },
  "application/x-gzip": {
    "source": "apache"
  },
  "application/x-hdf": {
    "source": "apache",
    "extensions": ["hdf"]
  },
  "application/x-httpd-php": {
    "compressible": true,
    "extensions": ["php"]
  },
  "application/x-install-instructions": {
    "source": "apache",
    "extensions": ["install"]
  },
  "application/x-iso9660-image": {
    "source": "apache",
    "extensions": ["iso"]
  },
  "application/x-iwork-keynote-sffkey": {
    "extensions": ["key"]
  },
  "application/x-iwork-numbers-sffnumbers": {
    "extensions": ["numbers"]
  },
  "application/x-iwork-pages-sffpages": {
    "extensions": ["pages"]
  },
  "application/x-java-archive-diff": {
    "source": "nginx",
    "extensions": ["jardiff"]
  },
  "application/x-java-jnlp-file": {
    "source": "apache",
    "compressible": false,
    "extensions": ["jnlp"]
  },
  "application/x-javascript": {
    "compressible": true
  },
  "application/x-keepass2": {
    "extensions": ["kdbx"]
  },
  "application/x-latex": {
    "source": "apache",
    "compressible": false,
    "extensions": ["latex"]
  },
  "application/x-lua-bytecode": {
    "extensions": ["luac"]
  },
  "application/x-lzh-compressed": {
    "source": "apache",
    "extensions": ["lzh","lha"]
  },
  "application/x-makeself": {
    "source": "nginx",
    "extensions": ["run"]
  },
  "application/x-mie": {
    "source": "apache",
    "extensions": ["mie"]
  },
  "application/x-mobipocket-ebook": {
    "source": "apache",
    "extensions": ["prc","mobi"]
  },
  "application/x-mpegurl": {
    "compressible": false
  },
  "application/x-ms-application": {
    "source": "apache",
    "extensions": ["application"]
  },
  "application/x-ms-shortcut": {
    "source": "apache",
    "extensions": ["lnk"]
  },
  "application/x-ms-wmd": {
    "source": "apache",
    "extensions": ["wmd"]
  },
  "application/x-ms-wmz": {
    "source": "apache",
    "extensions": ["wmz"]
  },
  "application/x-ms-xbap": {
    "source": "apache",
    "extensions": ["xbap"]
  },
  "application/x-msaccess": {
    "source": "apache",
    "extensions": ["mdb"]
  },
  "application/x-msbinder": {
    "source": "apache",
    "extensions": ["obd"]
  },
  "application/x-mscardfile": {
    "source": "apache",
    "extensions": ["crd"]
  },
  "application/x-msclip": {
    "source": "apache",
    "extensions": ["clp"]
  },
  "application/x-msdos-program": {
    "extensions": ["exe"]
  },
  "application/x-msdownload": {
    "source": "apache",
    "extensions": ["exe","dll","com","bat","msi"]
  },
  "application/x-msmediaview": {
    "source": "apache",
    "extensions": ["mvb","m13","m14"]
  },
  "application/x-msmetafile": {
    "source": "apache",
    "extensions": ["wmf","wmz","emf","emz"]
  },
  "application/x-msmoney": {
    "source": "apache",
    "extensions": ["mny"]
  },
  "application/x-mspublisher": {
    "source": "apache",
    "extensions": ["pub"]
  },
  "application/x-msschedule": {
    "source": "apache",
    "extensions": ["scd"]
  },
  "application/x-msterminal": {
    "source": "apache",
    "extensions": ["trm"]
  },
  "application/x-mswrite": {
    "source": "apache",
    "extensions": ["wri"]
  },
  "application/x-netcdf": {
    "source": "apache",
    "extensions": ["nc","cdf"]
  },
  "application/x-ns-proxy-autoconfig": {
    "compressible": true,
    "extensions": ["pac"]
  },
  "application/x-nzb": {
    "source": "apache",
    "extensions": ["nzb"]
  },
  "application/x-perl": {
    "source": "nginx",
    "extensions": ["pl","pm"]
  },
  "application/x-pilot": {
    "source": "nginx",
    "extensions": ["prc","pdb"]
  },
  "application/x-pkcs12": {
    "source": "apache",
    "compressible": false,
    "extensions": ["p12","pfx"]
  },
  "application/x-pkcs7-certificates": {
    "source": "apache",
    "extensions": ["p7b","spc"]
  },
  "application/x-pkcs7-certreqresp": {
    "source": "apache",
    "extensions": ["p7r"]
  },
  "application/x-pki-message": {
    "source": "iana"
  },
  "application/x-rar-compressed": {
    "source": "apache",
    "compressible": false,
    "extensions": ["rar"]
  },
  "application/x-redhat-package-manager": {
    "source": "nginx",
    "extensions": ["rpm"]
  },
  "application/x-research-info-systems": {
    "source": "apache",
    "extensions": ["ris"]
  },
  "application/x-sea": {
    "source": "nginx",
    "extensions": ["sea"]
  },
  "application/x-sh": {
    "source": "apache",
    "compressible": true,
    "extensions": ["sh"]
  },
  "application/x-shar": {
    "source": "apache",
    "extensions": ["shar"]
  },
  "application/x-shockwave-flash": {
    "source": "apache",
    "compressible": false,
    "extensions": ["swf"]
  },
  "application/x-silverlight-app": {
    "source": "apache",
    "extensions": ["xap"]
  },
  "application/x-sql": {
    "source": "apache",
    "extensions": ["sql"]
  },
  "application/x-stuffit": {
    "source": "apache",
    "compressible": false,
    "extensions": ["sit"]
  },
  "application/x-stuffitx": {
    "source": "apache",
    "extensions": ["sitx"]
  },
  "application/x-subrip": {
    "source": "apache",
    "extensions": ["srt"]
  },
  "application/x-sv4cpio": {
    "source": "apache",
    "extensions": ["sv4cpio"]
  },
  "application/x-sv4crc": {
    "source": "apache",
    "extensions": ["sv4crc"]
  },
  "application/x-t3vm-image": {
    "source": "apache",
    "extensions": ["t3"]
  },
  "application/x-tads": {
    "source": "apache",
    "extensions": ["gam"]
  },
  "application/x-tar": {
    "source": "apache",
    "compressible": true,
    "extensions": ["tar"]
  },
  "application/x-tcl": {
    "source": "apache",
    "extensions": ["tcl","tk"]
  },
  "application/x-tex": {
    "source": "apache",
    "extensions": ["tex"]
  },
  "application/x-tex-tfm": {
    "source": "apache",
    "extensions": ["tfm"]
  },
  "application/x-texinfo": {
    "source": "apache",
    "extensions": ["texinfo","texi"]
  },
  "application/x-tgif": {
    "source": "apache",
    "extensions": ["obj"]
  },
  "application/x-ustar": {
    "source": "apache",
    "extensions": ["ustar"]
  },
  "application/x-virtualbox-hdd": {
    "compressible": true,
    "extensions": ["hdd"]
  },
  "application/x-virtualbox-ova": {
    "compressible": true,
    "extensions": ["ova"]
  },
  "application/x-virtualbox-ovf": {
    "compressible": true,
    "extensions": ["ovf"]
  },
  "application/x-virtualbox-vbox": {
    "compressible": true,
    "extensions": ["vbox"]
  },
  "application/x-virtualbox-vbox-extpack": {
    "compressible": false,
    "extensions": ["vbox-extpack"]
  },
  "application/x-virtualbox-vdi": {
    "compressible": true,
    "extensions": ["vdi"]
  },
  "application/x-virtualbox-vhd": {
    "compressible": true,
    "extensions": ["vhd"]
  },
  "application/x-virtualbox-vmdk": {
    "compressible": true,
    "extensions": ["vmdk"]
  },
  "application/x-wais-source": {
    "source": "apache",
    "extensions": ["src"]
  },
  "application/x-web-app-manifest+json": {
    "compressible": true,
    "extensions": ["webapp"]
  },
  "application/x-www-form-urlencoded": {
    "source": "iana",
    "compressible": true
  },
  "application/x-x509-ca-cert": {
    "source": "iana",
    "extensions": ["der","crt","pem"]
  },
  "application/x-x509-ca-ra-cert": {
    "source": "iana"
  },
  "application/x-x509-next-ca-cert": {
    "source": "iana"
  },
  "application/x-xfig": {
    "source": "apache",
    "extensions": ["fig"]
  },
  "application/x-xliff+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["xlf"]
  },
  "application/x-xpinstall": {
    "source": "apache",
    "compressible": false,
    "extensions": ["xpi"]
  },
  "application/x-xz": {
    "source": "apache",
    "extensions": ["xz"]
  },
  "application/x-zmachine": {
    "source": "apache",
    "extensions": ["z1","z2","z3","z4","z5","z6","z7","z8"]
  },
  "application/x400-bp": {
    "source": "iana"
  },
  "application/xacml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xaml+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["xaml"]
  },
  "application/xcap-att+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xav"]
  },
  "application/xcap-caps+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xca"]
  },
  "application/xcap-diff+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xdf"]
  },
  "application/xcap-el+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xel"]
  },
  "application/xcap-error+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xcap-ns+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xns"]
  },
  "application/xcon-conference-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xcon-conference-info-diff+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xenc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xenc"]
  },
  "application/xhtml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xhtml","xht"]
  },
  "application/xhtml-voice+xml": {
    "source": "apache",
    "compressible": true
  },
  "application/xliff+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xlf"]
  },
  "application/xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xml","xsl","xsd","rng"]
  },
  "application/xml-dtd": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dtd"]
  },
  "application/xml-external-parsed-entity": {
    "source": "iana"
  },
  "application/xml-patch+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xmpp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xop+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xop"]
  },
  "application/xproc+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["xpl"]
  },
  "application/xslt+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xsl","xslt"]
  },
  "application/xspf+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["xspf"]
  },
  "application/xv+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mxml","xhvml","xvml","xvm"]
  },
  "application/yang": {
    "source": "iana",
    "extensions": ["yang"]
  },
  "application/yang-data+json": {
    "source": "iana",
    "compressible": true
  },
  "application/yang-data+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/yang-patch+json": {
    "source": "iana",
    "compressible": true
  },
  "application/yang-patch+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/yin+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["yin"]
  },
  "application/zip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["zip"]
  },
  "application/zlib": {
    "source": "iana"
  },
  "application/zstd": {
    "source": "iana"
  },
  "audio/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "audio/32kadpcm": {
    "source": "iana"
  },
  "audio/3gpp": {
    "source": "iana",
    "compressible": false,
    "extensions": ["3gpp"]
  },
  "audio/3gpp2": {
    "source": "iana"
  },
  "audio/aac": {
    "source": "iana"
  },
  "audio/ac3": {
    "source": "iana"
  },
  "audio/adpcm": {
    "source": "apache",
    "extensions": ["adp"]
  },
  "audio/amr": {
    "source": "iana",
    "extensions": ["amr"]
  },
  "audio/amr-wb": {
    "source": "iana"
  },
  "audio/amr-wb+": {
    "source": "iana"
  },
  "audio/aptx": {
    "source": "iana"
  },
  "audio/asc": {
    "source": "iana"
  },
  "audio/atrac-advanced-lossless": {
    "source": "iana"
  },
  "audio/atrac-x": {
    "source": "iana"
  },
  "audio/atrac3": {
    "source": "iana"
  },
  "audio/basic": {
    "source": "iana",
    "compressible": false,
    "extensions": ["au","snd"]
  },
  "audio/bv16": {
    "source": "iana"
  },
  "audio/bv32": {
    "source": "iana"
  },
  "audio/clearmode": {
    "source": "iana"
  },
  "audio/cn": {
    "source": "iana"
  },
  "audio/dat12": {
    "source": "iana"
  },
  "audio/dls": {
    "source": "iana"
  },
  "audio/dsr-es201108": {
    "source": "iana"
  },
  "audio/dsr-es202050": {
    "source": "iana"
  },
  "audio/dsr-es202211": {
    "source": "iana"
  },
  "audio/dsr-es202212": {
    "source": "iana"
  },
  "audio/dv": {
    "source": "iana"
  },
  "audio/dvi4": {
    "source": "iana"
  },
  "audio/eac3": {
    "source": "iana"
  },
  "audio/encaprtp": {
    "source": "iana"
  },
  "audio/evrc": {
    "source": "iana"
  },
  "audio/evrc-qcp": {
    "source": "iana"
  },
  "audio/evrc0": {
    "source": "iana"
  },
  "audio/evrc1": {
    "source": "iana"
  },
  "audio/evrcb": {
    "source": "iana"
  },
  "audio/evrcb0": {
    "source": "iana"
  },
  "audio/evrcb1": {
    "source": "iana"
  },
  "audio/evrcnw": {
    "source": "iana"
  },
  "audio/evrcnw0": {
    "source": "iana"
  },
  "audio/evrcnw1": {
    "source": "iana"
  },
  "audio/evrcwb": {
    "source": "iana"
  },
  "audio/evrcwb0": {
    "source": "iana"
  },
  "audio/evrcwb1": {
    "source": "iana"
  },
  "audio/evs": {
    "source": "iana"
  },
  "audio/flexfec": {
    "source": "iana"
  },
  "audio/fwdred": {
    "source": "iana"
  },
  "audio/g711-0": {
    "source": "iana"
  },
  "audio/g719": {
    "source": "iana"
  },
  "audio/g722": {
    "source": "iana"
  },
  "audio/g7221": {
    "source": "iana"
  },
  "audio/g723": {
    "source": "iana"
  },
  "audio/g726-16": {
    "source": "iana"
  },
  "audio/g726-24": {
    "source": "iana"
  },
  "audio/g726-32": {
    "source": "iana"
  },
  "audio/g726-40": {
    "source": "iana"
  },
  "audio/g728": {
    "source": "iana"
  },
  "audio/g729": {
    "source": "iana"
  },
  "audio/g7291": {
    "source": "iana"
  },
  "audio/g729d": {
    "source": "iana"
  },
  "audio/g729e": {
    "source": "iana"
  },
  "audio/gsm": {
    "source": "iana"
  },
  "audio/gsm-efr": {
    "source": "iana"
  },
  "audio/gsm-hr-08": {
    "source": "iana"
  },
  "audio/ilbc": {
    "source": "iana"
  },
  "audio/ip-mr_v2.5": {
    "source": "iana"
  },
  "audio/isac": {
    "source": "apache"
  },
  "audio/l16": {
    "source": "iana"
  },
  "audio/l20": {
    "source": "iana"
  },
  "audio/l24": {
    "source": "iana",
    "compressible": false
  },
  "audio/l8": {
    "source": "iana"
  },
  "audio/lpc": {
    "source": "iana"
  },
  "audio/melp": {
    "source": "iana"
  },
  "audio/melp1200": {
    "source": "iana"
  },
  "audio/melp2400": {
    "source": "iana"
  },
  "audio/melp600": {
    "source": "iana"
  },
  "audio/mhas": {
    "source": "iana"
  },
  "audio/midi": {
    "source": "apache",
    "extensions": ["mid","midi","kar","rmi"]
  },
  "audio/mobile-xmf": {
    "source": "iana",
    "extensions": ["mxmf"]
  },
  "audio/mp3": {
    "compressible": false,
    "extensions": ["mp3"]
  },
  "audio/mp4": {
    "source": "iana",
    "compressible": false,
    "extensions": ["m4a","mp4a"]
  },
  "audio/mp4a-latm": {
    "source": "iana"
  },
  "audio/mpa": {
    "source": "iana"
  },
  "audio/mpa-robust": {
    "source": "iana"
  },
  "audio/mpeg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["mpga","mp2","mp2a","mp3","m2a","m3a"]
  },
  "audio/mpeg4-generic": {
    "source": "iana"
  },
  "audio/musepack": {
    "source": "apache"
  },
  "audio/ogg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["oga","ogg","spx","opus"]
  },
  "audio/opus": {
    "source": "iana"
  },
  "audio/parityfec": {
    "source": "iana"
  },
  "audio/pcma": {
    "source": "iana"
  },
  "audio/pcma-wb": {
    "source": "iana"
  },
  "audio/pcmu": {
    "source": "iana"
  },
  "audio/pcmu-wb": {
    "source": "iana"
  },
  "audio/prs.sid": {
    "source": "iana"
  },
  "audio/qcelp": {
    "source": "iana"
  },
  "audio/raptorfec": {
    "source": "iana"
  },
  "audio/red": {
    "source": "iana"
  },
  "audio/rtp-enc-aescm128": {
    "source": "iana"
  },
  "audio/rtp-midi": {
    "source": "iana"
  },
  "audio/rtploopback": {
    "source": "iana"
  },
  "audio/rtx": {
    "source": "iana"
  },
  "audio/s3m": {
    "source": "apache",
    "extensions": ["s3m"]
  },
  "audio/scip": {
    "source": "iana"
  },
  "audio/silk": {
    "source": "apache",
    "extensions": ["sil"]
  },
  "audio/smv": {
    "source": "iana"
  },
  "audio/smv-qcp": {
    "source": "iana"
  },
  "audio/smv0": {
    "source": "iana"
  },
  "audio/sofa": {
    "source": "iana"
  },
  "audio/sp-midi": {
    "source": "iana"
  },
  "audio/speex": {
    "source": "iana"
  },
  "audio/t140c": {
    "source": "iana"
  },
  "audio/t38": {
    "source": "iana"
  },
  "audio/telephone-event": {
    "source": "iana"
  },
  "audio/tetra_acelp": {
    "source": "iana"
  },
  "audio/tetra_acelp_bb": {
    "source": "iana"
  },
  "audio/tone": {
    "source": "iana"
  },
  "audio/tsvcis": {
    "source": "iana"
  },
  "audio/uemclip": {
    "source": "iana"
  },
  "audio/ulpfec": {
    "source": "iana"
  },
  "audio/usac": {
    "source": "iana"
  },
  "audio/vdvi": {
    "source": "iana"
  },
  "audio/vmr-wb": {
    "source": "iana"
  },
  "audio/vnd.3gpp.iufp": {
    "source": "iana"
  },
  "audio/vnd.4sb": {
    "source": "iana"
  },
  "audio/vnd.audiokoz": {
    "source": "iana"
  },
  "audio/vnd.celp": {
    "source": "iana"
  },
  "audio/vnd.cisco.nse": {
    "source": "iana"
  },
  "audio/vnd.cmles.radio-events": {
    "source": "iana"
  },
  "audio/vnd.cns.anp1": {
    "source": "iana"
  },
  "audio/vnd.cns.inf1": {
    "source": "iana"
  },
  "audio/vnd.dece.audio": {
    "source": "iana",
    "extensions": ["uva","uvva"]
  },
  "audio/vnd.digital-winds": {
    "source": "iana",
    "extensions": ["eol"]
  },
  "audio/vnd.dlna.adts": {
    "source": "iana"
  },
  "audio/vnd.dolby.heaac.1": {
    "source": "iana"
  },
  "audio/vnd.dolby.heaac.2": {
    "source": "iana"
  },
  "audio/vnd.dolby.mlp": {
    "source": "iana"
  },
  "audio/vnd.dolby.mps": {
    "source": "iana"
  },
  "audio/vnd.dolby.pl2": {
    "source": "iana"
  },
  "audio/vnd.dolby.pl2x": {
    "source": "iana"
  },
  "audio/vnd.dolby.pl2z": {
    "source": "iana"
  },
  "audio/vnd.dolby.pulse.1": {
    "source": "iana"
  },
  "audio/vnd.dra": {
    "source": "iana",
    "extensions": ["dra"]
  },
  "audio/vnd.dts": {
    "source": "iana",
    "extensions": ["dts"]
  },
  "audio/vnd.dts.hd": {
    "source": "iana",
    "extensions": ["dtshd"]
  },
  "audio/vnd.dts.uhd": {
    "source": "iana"
  },
  "audio/vnd.dvb.file": {
    "source": "iana"
  },
  "audio/vnd.everad.plj": {
    "source": "iana"
  },
  "audio/vnd.hns.audio": {
    "source": "iana"
  },
  "audio/vnd.lucent.voice": {
    "source": "iana",
    "extensions": ["lvp"]
  },
  "audio/vnd.ms-playready.media.pya": {
    "source": "iana",
    "extensions": ["pya"]
  },
  "audio/vnd.nokia.mobile-xmf": {
    "source": "iana"
  },
  "audio/vnd.nortel.vbk": {
    "source": "iana"
  },
  "audio/vnd.nuera.ecelp4800": {
    "source": "iana",
    "extensions": ["ecelp4800"]
  },
  "audio/vnd.nuera.ecelp7470": {
    "source": "iana",
    "extensions": ["ecelp7470"]
  },
  "audio/vnd.nuera.ecelp9600": {
    "source": "iana",
    "extensions": ["ecelp9600"]
  },
  "audio/vnd.octel.sbc": {
    "source": "iana"
  },
  "audio/vnd.presonus.multitrack": {
    "source": "iana"
  },
  "audio/vnd.qcelp": {
    "source": "iana"
  },
  "audio/vnd.rhetorex.32kadpcm": {
    "source": "iana"
  },
  "audio/vnd.rip": {
    "source": "iana",
    "extensions": ["rip"]
  },
  "audio/vnd.rn-realaudio": {
    "compressible": false
  },
  "audio/vnd.sealedmedia.softseal.mpeg": {
    "source": "iana"
  },
  "audio/vnd.vmx.cvsd": {
    "source": "iana"
  },
  "audio/vnd.wave": {
    "compressible": false
  },
  "audio/vorbis": {
    "source": "iana",
    "compressible": false
  },
  "audio/vorbis-config": {
    "source": "iana"
  },
  "audio/wav": {
    "compressible": false,
    "extensions": ["wav"]
  },
  "audio/wave": {
    "compressible": false,
    "extensions": ["wav"]
  },
  "audio/webm": {
    "source": "apache",
    "compressible": false,
    "extensions": ["weba"]
  },
  "audio/x-aac": {
    "source": "apache",
    "compressible": false,
    "extensions": ["aac"]
  },
  "audio/x-aiff": {
    "source": "apache",
    "extensions": ["aif","aiff","aifc"]
  },
  "audio/x-caf": {
    "source": "apache",
    "compressible": false,
    "extensions": ["caf"]
  },
  "audio/x-flac": {
    "source": "apache",
    "extensions": ["flac"]
  },
  "audio/x-m4a": {
    "source": "nginx",
    "extensions": ["m4a"]
  },
  "audio/x-matroska": {
    "source": "apache",
    "extensions": ["mka"]
  },
  "audio/x-mpegurl": {
    "source": "apache",
    "extensions": ["m3u"]
  },
  "audio/x-ms-wax": {
    "source": "apache",
    "extensions": ["wax"]
  },
  "audio/x-ms-wma": {
    "source": "apache",
    "extensions": ["wma"]
  },
  "audio/x-pn-realaudio": {
    "source": "apache",
    "extensions": ["ram","ra"]
  },
  "audio/x-pn-realaudio-plugin": {
    "source": "apache",
    "extensions": ["rmp"]
  },
  "audio/x-realaudio": {
    "source": "nginx",
    "extensions": ["ra"]
  },
  "audio/x-tta": {
    "source": "apache"
  },
  "audio/x-wav": {
    "source": "apache",
    "extensions": ["wav"]
  },
  "audio/xm": {
    "source": "apache",
    "extensions": ["xm"]
  },
  "chemical/x-cdx": {
    "source": "apache",
    "extensions": ["cdx"]
  },
  "chemical/x-cif": {
    "source": "apache",
    "extensions": ["cif"]
  },
  "chemical/x-cmdf": {
    "source": "apache",
    "extensions": ["cmdf"]
  },
  "chemical/x-cml": {
    "source": "apache",
    "extensions": ["cml"]
  },
  "chemical/x-csml": {
    "source": "apache",
    "extensions": ["csml"]
  },
  "chemical/x-pdb": {
    "source": "apache"
  },
  "chemical/x-xyz": {
    "source": "apache",
    "extensions": ["xyz"]
  },
  "font/collection": {
    "source": "iana",
    "extensions": ["ttc"]
  },
  "font/otf": {
    "source": "iana",
    "compressible": true,
    "extensions": ["otf"]
  },
  "font/sfnt": {
    "source": "iana"
  },
  "font/ttf": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ttf"]
  },
  "font/woff": {
    "source": "iana",
    "extensions": ["woff"]
  },
  "font/woff2": {
    "source": "iana",
    "extensions": ["woff2"]
  },
  "image/aces": {
    "source": "iana",
    "extensions": ["exr"]
  },
  "image/apng": {
    "compressible": false,
    "extensions": ["apng"]
  },
  "image/avci": {
    "source": "iana",
    "extensions": ["avci"]
  },
  "image/avcs": {
    "source": "iana",
    "extensions": ["avcs"]
  },
  "image/avif": {
    "source": "iana",
    "compressible": false,
    "extensions": ["avif"]
  },
  "image/bmp": {
    "source": "iana",
    "compressible": true,
    "extensions": ["bmp"]
  },
  "image/cgm": {
    "source": "iana",
    "extensions": ["cgm"]
  },
  "image/dicom-rle": {
    "source": "iana",
    "extensions": ["drle"]
  },
  "image/emf": {
    "source": "iana",
    "extensions": ["emf"]
  },
  "image/fits": {
    "source": "iana",
    "extensions": ["fits"]
  },
  "image/g3fax": {
    "source": "iana",
    "extensions": ["g3"]
  },
  "image/gif": {
    "source": "iana",
    "compressible": false,
    "extensions": ["gif"]
  },
  "image/heic": {
    "source": "iana",
    "extensions": ["heic"]
  },
  "image/heic-sequence": {
    "source": "iana",
    "extensions": ["heics"]
  },
  "image/heif": {
    "source": "iana",
    "extensions": ["heif"]
  },
  "image/heif-sequence": {
    "source": "iana",
    "extensions": ["heifs"]
  },
  "image/hej2k": {
    "source": "iana",
    "extensions": ["hej2"]
  },
  "image/hsj2": {
    "source": "iana",
    "extensions": ["hsj2"]
  },
  "image/ief": {
    "source": "iana",
    "extensions": ["ief"]
  },
  "image/jls": {
    "source": "iana",
    "extensions": ["jls"]
  },
  "image/jp2": {
    "source": "iana",
    "compressible": false,
    "extensions": ["jp2","jpg2"]
  },
  "image/jpeg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["jpeg","jpg","jpe"]
  },
  "image/jph": {
    "source": "iana",
    "extensions": ["jph"]
  },
  "image/jphc": {
    "source": "iana",
    "extensions": ["jhc"]
  },
  "image/jpm": {
    "source": "iana",
    "compressible": false,
    "extensions": ["jpm"]
  },
  "image/jpx": {
    "source": "iana",
    "compressible": false,
    "extensions": ["jpx","jpf"]
  },
  "image/jxr": {
    "source": "iana",
    "extensions": ["jxr"]
  },
  "image/jxra": {
    "source": "iana",
    "extensions": ["jxra"]
  },
  "image/jxrs": {
    "source": "iana",
    "extensions": ["jxrs"]
  },
  "image/jxs": {
    "source": "iana",
    "extensions": ["jxs"]
  },
  "image/jxsc": {
    "source": "iana",
    "extensions": ["jxsc"]
  },
  "image/jxsi": {
    "source": "iana",
    "extensions": ["jxsi"]
  },
  "image/jxss": {
    "source": "iana",
    "extensions": ["jxss"]
  },
  "image/ktx": {
    "source": "iana",
    "extensions": ["ktx"]
  },
  "image/ktx2": {
    "source": "iana",
    "extensions": ["ktx2"]
  },
  "image/naplps": {
    "source": "iana"
  },
  "image/pjpeg": {
    "compressible": false
  },
  "image/png": {
    "source": "iana",
    "compressible": false,
    "extensions": ["png"]
  },
  "image/prs.btif": {
    "source": "iana",
    "extensions": ["btif"]
  },
  "image/prs.pti": {
    "source": "iana",
    "extensions": ["pti"]
  },
  "image/pwg-raster": {
    "source": "iana"
  },
  "image/sgi": {
    "source": "apache",
    "extensions": ["sgi"]
  },
  "image/svg+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["svg","svgz"]
  },
  "image/t38": {
    "source": "iana",
    "extensions": ["t38"]
  },
  "image/tiff": {
    "source": "iana",
    "compressible": false,
    "extensions": ["tif","tiff"]
  },
  "image/tiff-fx": {
    "source": "iana",
    "extensions": ["tfx"]
  },
  "image/vnd.adobe.photoshop": {
    "source": "iana",
    "compressible": true,
    "extensions": ["psd"]
  },
  "image/vnd.airzip.accelerator.azv": {
    "source": "iana",
    "extensions": ["azv"]
  },
  "image/vnd.cns.inf2": {
    "source": "iana"
  },
  "image/vnd.dece.graphic": {
    "source": "iana",
    "extensions": ["uvi","uvvi","uvg","uvvg"]
  },
  "image/vnd.djvu": {
    "source": "iana",
    "extensions": ["djvu","djv"]
  },
  "image/vnd.dvb.subtitle": {
    "source": "iana",
    "extensions": ["sub"]
  },
  "image/vnd.dwg": {
    "source": "iana",
    "extensions": ["dwg"]
  },
  "image/vnd.dxf": {
    "source": "iana",
    "extensions": ["dxf"]
  },
  "image/vnd.fastbidsheet": {
    "source": "iana",
    "extensions": ["fbs"]
  },
  "image/vnd.fpx": {
    "source": "iana",
    "extensions": ["fpx"]
  },
  "image/vnd.fst": {
    "source": "iana",
    "extensions": ["fst"]
  },
  "image/vnd.fujixerox.edmics-mmr": {
    "source": "iana",
    "extensions": ["mmr"]
  },
  "image/vnd.fujixerox.edmics-rlc": {
    "source": "iana",
    "extensions": ["rlc"]
  },
  "image/vnd.globalgraphics.pgb": {
    "source": "iana"
  },
  "image/vnd.microsoft.icon": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ico"]
  },
  "image/vnd.mix": {
    "source": "iana"
  },
  "image/vnd.mozilla.apng": {
    "source": "iana"
  },
  "image/vnd.ms-dds": {
    "compressible": true,
    "extensions": ["dds"]
  },
  "image/vnd.ms-modi": {
    "source": "iana",
    "extensions": ["mdi"]
  },
  "image/vnd.ms-photo": {
    "source": "apache",
    "extensions": ["wdp"]
  },
  "image/vnd.net-fpx": {
    "source": "iana",
    "extensions": ["npx"]
  },
  "image/vnd.pco.b16": {
    "source": "iana",
    "extensions": ["b16"]
  },
  "image/vnd.radiance": {
    "source": "iana"
  },
  "image/vnd.sealed.png": {
    "source": "iana"
  },
  "image/vnd.sealedmedia.softseal.gif": {
    "source": "iana"
  },
  "image/vnd.sealedmedia.softseal.jpg": {
    "source": "iana"
  },
  "image/vnd.svf": {
    "source": "iana"
  },
  "image/vnd.tencent.tap": {
    "source": "iana",
    "extensions": ["tap"]
  },
  "image/vnd.valve.source.texture": {
    "source": "iana",
    "extensions": ["vtf"]
  },
  "image/vnd.wap.wbmp": {
    "source": "iana",
    "extensions": ["wbmp"]
  },
  "image/vnd.xiff": {
    "source": "iana",
    "extensions": ["xif"]
  },
  "image/vnd.zbrush.pcx": {
    "source": "iana",
    "extensions": ["pcx"]
  },
  "image/webp": {
    "source": "apache",
    "extensions": ["webp"]
  },
  "image/wmf": {
    "source": "iana",
    "extensions": ["wmf"]
  },
  "image/x-3ds": {
    "source": "apache",
    "extensions": ["3ds"]
  },
  "image/x-cmu-raster": {
    "source": "apache",
    "extensions": ["ras"]
  },
  "image/x-cmx": {
    "source": "apache",
    "extensions": ["cmx"]
  },
  "image/x-freehand": {
    "source": "apache",
    "extensions": ["fh","fhc","fh4","fh5","fh7"]
  },
  "image/x-icon": {
    "source": "apache",
    "compressible": true,
    "extensions": ["ico"]
  },
  "image/x-jng": {
    "source": "nginx",
    "extensions": ["jng"]
  },
  "image/x-mrsid-image": {
    "source": "apache",
    "extensions": ["sid"]
  },
  "image/x-ms-bmp": {
    "source": "nginx",
    "compressible": true,
    "extensions": ["bmp"]
  },
  "image/x-pcx": {
    "source": "apache",
    "extensions": ["pcx"]
  },
  "image/x-pict": {
    "source": "apache",
    "extensions": ["pic","pct"]
  },
  "image/x-portable-anymap": {
    "source": "apache",
    "extensions": ["pnm"]
  },
  "image/x-portable-bitmap": {
    "source": "apache",
    "extensions": ["pbm"]
  },
  "image/x-portable-graymap": {
    "source": "apache",
    "extensions": ["pgm"]
  },
  "image/x-portable-pixmap": {
    "source": "apache",
    "extensions": ["ppm"]
  },
  "image/x-rgb": {
    "source": "apache",
    "extensions": ["rgb"]
  },
  "image/x-tga": {
    "source": "apache",
    "extensions": ["tga"]
  },
  "image/x-xbitmap": {
    "source": "apache",
    "extensions": ["xbm"]
  },
  "image/x-xcf": {
    "compressible": false
  },
  "image/x-xpixmap": {
    "source": "apache",
    "extensions": ["xpm"]
  },
  "image/x-xwindowdump": {
    "source": "apache",
    "extensions": ["xwd"]
  },
  "message/cpim": {
    "source": "iana"
  },
  "message/delivery-status": {
    "source": "iana"
  },
  "message/disposition-notification": {
    "source": "iana",
    "extensions": [
      "disposition-notification"
    ]
  },
  "message/external-body": {
    "source": "iana"
  },
  "message/feedback-report": {
    "source": "iana"
  },
  "message/global": {
    "source": "iana",
    "extensions": ["u8msg"]
  },
  "message/global-delivery-status": {
    "source": "iana",
    "extensions": ["u8dsn"]
  },
  "message/global-disposition-notification": {
    "source": "iana",
    "extensions": ["u8mdn"]
  },
  "message/global-headers": {
    "source": "iana",
    "extensions": ["u8hdr"]
  },
  "message/http": {
    "source": "iana",
    "compressible": false
  },
  "message/imdn+xml": {
    "source": "iana",
    "compressible": true
  },
  "message/news": {
    "source": "iana"
  },
  "message/partial": {
    "source": "iana",
    "compressible": false
  },
  "message/rfc822": {
    "source": "iana",
    "compressible": true,
    "extensions": ["eml","mime"]
  },
  "message/s-http": {
    "source": "iana"
  },
  "message/sip": {
    "source": "iana"
  },
  "message/sipfrag": {
    "source": "iana"
  },
  "message/tracking-status": {
    "source": "iana"
  },
  "message/vnd.si.simp": {
    "source": "iana"
  },
  "message/vnd.wfa.wsc": {
    "source": "iana",
    "extensions": ["wsc"]
  },
  "model/3mf": {
    "source": "iana",
    "extensions": ["3mf"]
  },
  "model/e57": {
    "source": "iana"
  },
  "model/gltf+json": {
    "source": "iana",
    "compressible": true,
    "extensions": ["gltf"]
  },
  "model/gltf-binary": {
    "source": "iana",
    "compressible": true,
    "extensions": ["glb"]
  },
  "model/iges": {
    "source": "iana",
    "compressible": false,
    "extensions": ["igs","iges"]
  },
  "model/mesh": {
    "source": "iana",
    "compressible": false,
    "extensions": ["msh","mesh","silo"]
  },
  "model/mtl": {
    "source": "iana",
    "extensions": ["mtl"]
  },
  "model/obj": {
    "source": "iana",
    "extensions": ["obj"]
  },
  "model/step": {
    "source": "iana"
  },
  "model/step+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["stpx"]
  },
  "model/step+zip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["stpz"]
  },
  "model/step-xml+zip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["stpxz"]
  },
  "model/stl": {
    "source": "iana",
    "extensions": ["stl"]
  },
  "model/vnd.collada+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dae"]
  },
  "model/vnd.dwf": {
    "source": "iana",
    "extensions": ["dwf"]
  },
  "model/vnd.flatland.3dml": {
    "source": "iana"
  },
  "model/vnd.gdl": {
    "source": "iana",
    "extensions": ["gdl"]
  },
  "model/vnd.gs-gdl": {
    "source": "apache"
  },
  "model/vnd.gs.gdl": {
    "source": "iana"
  },
  "model/vnd.gtw": {
    "source": "iana",
    "extensions": ["gtw"]
  },
  "model/vnd.moml+xml": {
    "source": "iana",
    "compressible": true
  },
  "model/vnd.mts": {
    "source": "iana",
    "extensions": ["mts"]
  },
  "model/vnd.opengex": {
    "source": "iana",
    "extensions": ["ogex"]
  },
  "model/vnd.parasolid.transmit.binary": {
    "source": "iana",
    "extensions": ["x_b"]
  },
  "model/vnd.parasolid.transmit.text": {
    "source": "iana",
    "extensions": ["x_t"]
  },
  "model/vnd.pytha.pyox": {
    "source": "iana"
  },
  "model/vnd.rosette.annotated-data-model": {
    "source": "iana"
  },
  "model/vnd.sap.vds": {
    "source": "iana",
    "extensions": ["vds"]
  },
  "model/vnd.usdz+zip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["usdz"]
  },
  "model/vnd.valve.source.compiled-map": {
    "source": "iana",
    "extensions": ["bsp"]
  },
  "model/vnd.vtu": {
    "source": "iana",
    "extensions": ["vtu"]
  },
  "model/vrml": {
    "source": "iana",
    "compressible": false,
    "extensions": ["wrl","vrml"]
  },
  "model/x3d+binary": {
    "source": "apache",
    "compressible": false,
    "extensions": ["x3db","x3dbz"]
  },
  "model/x3d+fastinfoset": {
    "source": "iana",
    "extensions": ["x3db"]
  },
  "model/x3d+vrml": {
    "source": "apache",
    "compressible": false,
    "extensions": ["x3dv","x3dvz"]
  },
  "model/x3d+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["x3d","x3dz"]
  },
  "model/x3d-vrml": {
    "source": "iana",
    "extensions": ["x3dv"]
  },
  "multipart/alternative": {
    "source": "iana",
    "compressible": false
  },
  "multipart/appledouble": {
    "source": "iana"
  },
  "multipart/byteranges": {
    "source": "iana"
  },
  "multipart/digest": {
    "source": "iana"
  },
  "multipart/encrypted": {
    "source": "iana",
    "compressible": false
  },
  "multipart/form-data": {
    "source": "iana",
    "compressible": false
  },
  "multipart/header-set": {
    "source": "iana"
  },
  "multipart/mixed": {
    "source": "iana"
  },
  "multipart/multilingual": {
    "source": "iana"
  },
  "multipart/parallel": {
    "source": "iana"
  },
  "multipart/related": {
    "source": "iana",
    "compressible": false
  },
  "multipart/report": {
    "source": "iana"
  },
  "multipart/signed": {
    "source": "iana",
    "compressible": false
  },
  "multipart/vnd.bint.med-plus": {
    "source": "iana"
  },
  "multipart/voice-message": {
    "source": "iana"
  },
  "multipart/x-mixed-replace": {
    "source": "iana"
  },
  "text/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "text/cache-manifest": {
    "source": "iana",
    "compressible": true,
    "extensions": ["appcache","manifest"]
  },
  "text/calendar": {
    "source": "iana",
    "extensions": ["ics","ifb"]
  },
  "text/calender": {
    "compressible": true
  },
  "text/cmd": {
    "compressible": true
  },
  "text/coffeescript": {
    "extensions": ["coffee","litcoffee"]
  },
  "text/cql": {
    "source": "iana"
  },
  "text/cql-expression": {
    "source": "iana"
  },
  "text/cql-identifier": {
    "source": "iana"
  },
  "text/css": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["css"]
  },
  "text/csv": {
    "source": "iana",
    "compressible": true,
    "extensions": ["csv"]
  },
  "text/csv-schema": {
    "source": "iana"
  },
  "text/directory": {
    "source": "iana"
  },
  "text/dns": {
    "source": "iana"
  },
  "text/ecmascript": {
    "source": "iana"
  },
  "text/encaprtp": {
    "source": "iana"
  },
  "text/enriched": {
    "source": "iana"
  },
  "text/fhirpath": {
    "source": "iana"
  },
  "text/flexfec": {
    "source": "iana"
  },
  "text/fwdred": {
    "source": "iana"
  },
  "text/gff3": {
    "source": "iana"
  },
  "text/grammar-ref-list": {
    "source": "iana"
  },
  "text/html": {
    "source": "iana",
    "compressible": true,
    "extensions": ["html","htm","shtml"]
  },
  "text/jade": {
    "extensions": ["jade"]
  },
  "text/javascript": {
    "source": "iana",
    "compressible": true
  },
  "text/jcr-cnd": {
    "source": "iana"
  },
  "text/jsx": {
    "compressible": true,
    "extensions": ["jsx"]
  },
  "text/less": {
    "compressible": true,
    "extensions": ["less"]
  },
  "text/markdown": {
    "source": "iana",
    "compressible": true,
    "extensions": ["markdown","md"]
  },
  "text/mathml": {
    "source": "nginx",
    "extensions": ["mml"]
  },
  "text/mdx": {
    "compressible": true,
    "extensions": ["mdx"]
  },
  "text/mizar": {
    "source": "iana"
  },
  "text/n3": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["n3"]
  },
  "text/parameters": {
    "source": "iana",
    "charset": "UTF-8"
  },
  "text/parityfec": {
    "source": "iana"
  },
  "text/plain": {
    "source": "iana",
    "compressible": true,
    "extensions": ["txt","text","conf","def","list","log","in","ini"]
  },
  "text/provenance-notation": {
    "source": "iana",
    "charset": "UTF-8"
  },
  "text/prs.fallenstein.rst": {
    "source": "iana"
  },
  "text/prs.lines.tag": {
    "source": "iana",
    "extensions": ["dsc"]
  },
  "text/prs.prop.logic": {
    "source": "iana"
  },
  "text/raptorfec": {
    "source": "iana"
  },
  "text/red": {
    "source": "iana"
  },
  "text/rfc822-headers": {
    "source": "iana"
  },
  "text/richtext": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rtx"]
  },
  "text/rtf": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rtf"]
  },
  "text/rtp-enc-aescm128": {
    "source": "iana"
  },
  "text/rtploopback": {
    "source": "iana"
  },
  "text/rtx": {
    "source": "iana"
  },
  "text/sgml": {
    "source": "iana",
    "extensions": ["sgml","sgm"]
  },
  "text/shaclc": {
    "source": "iana"
  },
  "text/shex": {
    "source": "iana",
    "extensions": ["shex"]
  },
  "text/slim": {
    "extensions": ["slim","slm"]
  },
  "text/spdx": {
    "source": "iana",
    "extensions": ["spdx"]
  },
  "text/strings": {
    "source": "iana"
  },
  "text/stylus": {
    "extensions": ["stylus","styl"]
  },
  "text/t140": {
    "source": "iana"
  },
  "text/tab-separated-values": {
    "source": "iana",
    "compressible": true,
    "extensions": ["tsv"]
  },
  "text/troff": {
    "source": "iana",
    "extensions": ["t","tr","roff","man","me","ms"]
  },
  "text/turtle": {
    "source": "iana",
    "charset": "UTF-8",
    "extensions": ["ttl"]
  },
  "text/ulpfec": {
    "source": "iana"
  },
  "text/uri-list": {
    "source": "iana",
    "compressible": true,
    "extensions": ["uri","uris","urls"]
  },
  "text/vcard": {
    "source": "iana",
    "compressible": true,
    "extensions": ["vcard"]
  },
  "text/vnd.a": {
    "source": "iana"
  },
  "text/vnd.abc": {
    "source": "iana"
  },
  "text/vnd.ascii-art": {
    "source": "iana"
  },
  "text/vnd.curl": {
    "source": "iana",
    "extensions": ["curl"]
  },
  "text/vnd.curl.dcurl": {
    "source": "apache",
    "extensions": ["dcurl"]
  },
  "text/vnd.curl.mcurl": {
    "source": "apache",
    "extensions": ["mcurl"]
  },
  "text/vnd.curl.scurl": {
    "source": "apache",
    "extensions": ["scurl"]
  },
  "text/vnd.debian.copyright": {
    "source": "iana",
    "charset": "UTF-8"
  },
  "text/vnd.dmclientscript": {
    "source": "iana"
  },
  "text/vnd.dvb.subtitle": {
    "source": "iana",
    "extensions": ["sub"]
  },
  "text/vnd.esmertec.theme-descriptor": {
    "source": "iana",
    "charset": "UTF-8"
  },
  "text/vnd.familysearch.gedcom": {
    "source": "iana",
    "extensions": ["ged"]
  },
  "text/vnd.ficlab.flt": {
    "source": "iana"
  },
  "text/vnd.fly": {
    "source": "iana",
    "extensions": ["fly"]
  },
  "text/vnd.fmi.flexstor": {
    "source": "iana",
    "extensions": ["flx"]
  },
  "text/vnd.gml": {
    "source": "iana"
  },
  "text/vnd.graphviz": {
    "source": "iana",
    "extensions": ["gv"]
  },
  "text/vnd.hans": {
    "source": "iana"
  },
  "text/vnd.hgl": {
    "source": "iana"
  },
  "text/vnd.in3d.3dml": {
    "source": "iana",
    "extensions": ["3dml"]
  },
  "text/vnd.in3d.spot": {
    "source": "iana",
    "extensions": ["spot"]
  },
  "text/vnd.iptc.newsml": {
    "source": "iana"
  },
  "text/vnd.iptc.nitf": {
    "source": "iana"
  },
  "text/vnd.latex-z": {
    "source": "iana"
  },
  "text/vnd.motorola.reflex": {
    "source": "iana"
  },
  "text/vnd.ms-mediapackage": {
    "source": "iana"
  },
  "text/vnd.net2phone.commcenter.command": {
    "source": "iana"
  },
  "text/vnd.radisys.msml-basic-layout": {
    "source": "iana"
  },
  "text/vnd.senx.warpscript": {
    "source": "iana"
  },
  "text/vnd.si.uricatalogue": {
    "source": "iana"
  },
  "text/vnd.sosi": {
    "source": "iana"
  },
  "text/vnd.sun.j2me.app-descriptor": {
    "source": "iana",
    "charset": "UTF-8",
    "extensions": ["jad"]
  },
  "text/vnd.trolltech.linguist": {
    "source": "iana",
    "charset": "UTF-8"
  },
  "text/vnd.wap.si": {
    "source": "iana"
  },
  "text/vnd.wap.sl": {
    "source": "iana"
  },
  "text/vnd.wap.wml": {
    "source": "iana",
    "extensions": ["wml"]
  },
  "text/vnd.wap.wmlscript": {
    "source": "iana",
    "extensions": ["wmls"]
  },
  "text/vtt": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["vtt"]
  },
  "text/x-asm": {
    "source": "apache",
    "extensions": ["s","asm"]
  },
  "text/x-c": {
    "source": "apache",
    "extensions": ["c","cc","cxx","cpp","h","hh","dic"]
  },
  "text/x-component": {
    "source": "nginx",
    "extensions": ["htc"]
  },
  "text/x-fortran": {
    "source": "apache",
    "extensions": ["f","for","f77","f90"]
  },
  "text/x-gwt-rpc": {
    "compressible": true
  },
  "text/x-handlebars-template": {
    "extensions": ["hbs"]
  },
  "text/x-java-source": {
    "source": "apache",
    "extensions": ["java"]
  },
  "text/x-jquery-tmpl": {
    "compressible": true
  },
  "text/x-lua": {
    "extensions": ["lua"]
  },
  "text/x-markdown": {
    "compressible": true,
    "extensions": ["mkd"]
  },
  "text/x-nfo": {
    "source": "apache",
    "extensions": ["nfo"]
  },
  "text/x-opml": {
    "source": "apache",
    "extensions": ["opml"]
  },
  "text/x-org": {
    "compressible": true,
    "extensions": ["org"]
  },
  "text/x-pascal": {
    "source": "apache",
    "extensions": ["p","pas"]
  },
  "text/x-processing": {
    "compressible": true,
    "extensions": ["pde"]
  },
  "text/x-sass": {
    "extensions": ["sass"]
  },
  "text/x-scss": {
    "extensions": ["scss"]
  },
  "text/x-setext": {
    "source": "apache",
    "extensions": ["etx"]
  },
  "text/x-sfv": {
    "source": "apache",
    "extensions": ["sfv"]
  },
  "text/x-suse-ymp": {
    "compressible": true,
    "extensions": ["ymp"]
  },
  "text/x-uuencode": {
    "source": "apache",
    "extensions": ["uu"]
  },
  "text/x-vcalendar": {
    "source": "apache",
    "extensions": ["vcs"]
  },
  "text/x-vcard": {
    "source": "apache",
    "extensions": ["vcf"]
  },
  "text/xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xml"]
  },
  "text/xml-external-parsed-entity": {
    "source": "iana"
  },
  "text/yaml": {
    "compressible": true,
    "extensions": ["yaml","yml"]
  },
  "video/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "video/3gpp": {
    "source": "iana",
    "extensions": ["3gp","3gpp"]
  },
  "video/3gpp-tt": {
    "source": "iana"
  },
  "video/3gpp2": {
    "source": "iana",
    "extensions": ["3g2"]
  },
  "video/av1": {
    "source": "iana"
  },
  "video/bmpeg": {
    "source": "iana"
  },
  "video/bt656": {
    "source": "iana"
  },
  "video/celb": {
    "source": "iana"
  },
  "video/dv": {
    "source": "iana"
  },
  "video/encaprtp": {
    "source": "iana"
  },
  "video/ffv1": {
    "source": "iana"
  },
  "video/flexfec": {
    "source": "iana"
  },
  "video/h261": {
    "source": "iana",
    "extensions": ["h261"]
  },
  "video/h263": {
    "source": "iana",
    "extensions": ["h263"]
  },
  "video/h263-1998": {
    "source": "iana"
  },
  "video/h263-2000": {
    "source": "iana"
  },
  "video/h264": {
    "source": "iana",
    "extensions": ["h264"]
  },
  "video/h264-rcdo": {
    "source": "iana"
  },
  "video/h264-svc": {
    "source": "iana"
  },
  "video/h265": {
    "source": "iana"
  },
  "video/iso.segment": {
    "source": "iana",
    "extensions": ["m4s"]
  },
  "video/jpeg": {
    "source": "iana",
    "extensions": ["jpgv"]
  },
  "video/jpeg2000": {
    "source": "iana"
  },
  "video/jpm": {
    "source": "apache",
    "extensions": ["jpm","jpgm"]
  },
  "video/jxsv": {
    "source": "iana"
  },
  "video/mj2": {
    "source": "iana",
    "extensions": ["mj2","mjp2"]
  },
  "video/mp1s": {
    "source": "iana"
  },
  "video/mp2p": {
    "source": "iana"
  },
  "video/mp2t": {
    "source": "iana",
    "extensions": ["ts"]
  },
  "video/mp4": {
    "source": "iana",
    "compressible": false,
    "extensions": ["mp4","mp4v","mpg4"]
  },
  "video/mp4v-es": {
    "source": "iana"
  },
  "video/mpeg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["mpeg","mpg","mpe","m1v","m2v"]
  },
  "video/mpeg4-generic": {
    "source": "iana"
  },
  "video/mpv": {
    "source": "iana"
  },
  "video/nv": {
    "source": "iana"
  },
  "video/ogg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ogv"]
  },
  "video/parityfec": {
    "source": "iana"
  },
  "video/pointer": {
    "source": "iana"
  },
  "video/quicktime": {
    "source": "iana",
    "compressible": false,
    "extensions": ["qt","mov"]
  },
  "video/raptorfec": {
    "source": "iana"
  },
  "video/raw": {
    "source": "iana"
  },
  "video/rtp-enc-aescm128": {
    "source": "iana"
  },
  "video/rtploopback": {
    "source": "iana"
  },
  "video/rtx": {
    "source": "iana"
  },
  "video/scip": {
    "source": "iana"
  },
  "video/smpte291": {
    "source": "iana"
  },
  "video/smpte292m": {
    "source": "iana"
  },
  "video/ulpfec": {
    "source": "iana"
  },
  "video/vc1": {
    "source": "iana"
  },
  "video/vc2": {
    "source": "iana"
  },
  "video/vnd.cctv": {
    "source": "iana"
  },
  "video/vnd.dece.hd": {
    "source": "iana",
    "extensions": ["uvh","uvvh"]
  },
  "video/vnd.dece.mobile": {
    "source": "iana",
    "extensions": ["uvm","uvvm"]
  },
  "video/vnd.dece.mp4": {
    "source": "iana"
  },
  "video/vnd.dece.pd": {
    "source": "iana",
    "extensions": ["uvp","uvvp"]
  },
  "video/vnd.dece.sd": {
    "source": "iana",
    "extensions": ["uvs","uvvs"]
  },
  "video/vnd.dece.video": {
    "source": "iana",
    "extensions": ["uvv","uvvv"]
  },
  "video/vnd.directv.mpeg": {
    "source": "iana"
  },
  "video/vnd.directv.mpeg-tts": {
    "source": "iana"
  },
  "video/vnd.dlna.mpeg-tts": {
    "source": "iana"
  },
  "video/vnd.dvb.file": {
    "source": "iana",
    "extensions": ["dvb"]
  },
  "video/vnd.fvt": {
    "source": "iana",
    "extensions": ["fvt"]
  },
  "video/vnd.hns.video": {
    "source": "iana"
  },
  "video/vnd.iptvforum.1dparityfec-1010": {
    "source": "iana"
  },
  "video/vnd.iptvforum.1dparityfec-2005": {
    "source": "iana"
  },
  "video/vnd.iptvforum.2dparityfec-1010": {
    "source": "iana"
  },
  "video/vnd.iptvforum.2dparityfec-2005": {
    "source": "iana"
  },
  "video/vnd.iptvforum.ttsavc": {
    "source": "iana"
  },
  "video/vnd.iptvforum.ttsmpeg2": {
    "source": "iana"
  },
  "video/vnd.motorola.video": {
    "source": "iana"
  },
  "video/vnd.motorola.videop": {
    "source": "iana"
  },
  "video/vnd.mpegurl": {
    "source": "iana",
    "extensions": ["mxu","m4u"]
  },
  "video/vnd.ms-playready.media.pyv": {
    "source": "iana",
    "extensions": ["pyv"]
  },
  "video/vnd.nokia.interleaved-multimedia": {
    "source": "iana"
  },
  "video/vnd.nokia.mp4vr": {
    "source": "iana"
  },
  "video/vnd.nokia.videovoip": {
    "source": "iana"
  },
  "video/vnd.objectvideo": {
    "source": "iana"
  },
  "video/vnd.radgamettools.bink": {
    "source": "iana"
  },
  "video/vnd.radgamettools.smacker": {
    "source": "iana"
  },
  "video/vnd.sealed.mpeg1": {
    "source": "iana"
  },
  "video/vnd.sealed.mpeg4": {
    "source": "iana"
  },
  "video/vnd.sealed.swf": {
    "source": "iana"
  },
  "video/vnd.sealedmedia.softseal.mov": {
    "source": "iana"
  },
  "video/vnd.uvvu.mp4": {
    "source": "iana",
    "extensions": ["uvu","uvvu"]
  },
  "video/vnd.vivo": {
    "source": "iana",
    "extensions": ["viv"]
  },
  "video/vnd.youtube.yt": {
    "source": "iana"
  },
  "video/vp8": {
    "source": "iana"
  },
  "video/vp9": {
    "source": "iana"
  },
  "video/webm": {
    "source": "apache",
    "compressible": false,
    "extensions": ["webm"]
  },
  "video/x-f4v": {
    "source": "apache",
    "extensions": ["f4v"]
  },
  "video/x-fli": {
    "source": "apache",
    "extensions": ["fli"]
  },
  "video/x-flv": {
    "source": "apache",
    "compressible": false,
    "extensions": ["flv"]
  },
  "video/x-m4v": {
    "source": "apache",
    "extensions": ["m4v"]
  },
  "video/x-matroska": {
    "source": "apache",
    "compressible": false,
    "extensions": ["mkv","mk3d","mks"]
  },
  "video/x-mng": {
    "source": "apache",
    "extensions": ["mng"]
  },
  "video/x-ms-asf": {
    "source": "apache",
    "extensions": ["asf","asx"]
  },
  "video/x-ms-vob": {
    "source": "apache",
    "extensions": ["vob"]
  },
  "video/x-ms-wm": {
    "source": "apache",
    "extensions": ["wm"]
  },
  "video/x-ms-wmv": {
    "source": "apache",
    "compressible": false,
    "extensions": ["wmv"]
  },
  "video/x-ms-wmx": {
    "source": "apache",
    "extensions": ["wmx"]
  },
  "video/x-ms-wvx": {
    "source": "apache",
    "extensions": ["wvx"]
  },
  "video/x-msvideo": {
    "source": "apache",
    "extensions": ["avi"]
  },
  "video/x-sgi-movie": {
    "source": "apache",
    "extensions": ["movie"]
  },
  "video/x-smv": {
    "source": "apache",
    "extensions": ["smv"]
  },
  "x-conference/x-cooltalk": {
    "source": "apache",
    "extensions": ["ice"]
  },
  "x-shader/x-fragment": {
    "compressible": true
  },
  "x-shader/x-vertex": {
    "compressible": true
  }
}
`);
const EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
const extensions = new Map();
const types = new Map();
function populateMaps(extensions, types) {
    const preference = [
        "nginx",
        "apache",
        undefined,
        "iana"
    ];
    for (const type of Object.keys(__default)){
        const mime = __default[type];
        const exts = mime.extensions;
        if (!exts || !exts.length) {
            continue;
        }
        extensions.set(type, exts);
        for (const ext of exts){
            const current = types.get(ext);
            if (current) {
                const from = preference.indexOf(__default[current].source);
                const to = preference.indexOf(mime.source);
                if (current !== "application/octet-stream" && (from > to || from === to && current.startsWith("application/"))) {
                    continue;
                }
            }
            types.set(ext, type);
        }
    }
}
populateMaps(extensions, types);
function lookup(path) {
    const extension = extname5(`x.${path}`).toLowerCase().substring(1);
    return types.get(extension);
}
function extension(type) {
    const match = EXTRACT_TYPE_REGEXP.exec(type);
    if (!match) {
        return undefined;
    }
    const exts = extensions.get(match[1].toLowerCase());
    if (!exts || !exts.length) {
        return undefined;
    }
    return exts[0];
}
const textTypes = [
    "text/",
    "application/javascript",
    "application/xml",
    "application/xhtml+xml"
];
const isJson = (mimeType)=>!!mimeType && (mimeType.indexOf("/json") > 0 || mimeType.indexOf("+json") > 0 || mimeType === 'inode/directory');
const isText = (mimeType)=>!!mimeType && textTypes.some((tt)=>mimeType.startsWith(tt));
const isZip = (mimeType)=>!!mimeType && mimeType.startsWith("application/") && mimeType.includes('zip');
const multiExtensions = {
    'image/jpeg': [
        'jpg',
        'jpeg'
    ]
};
const mappings = {
    "text/x.nunjucks": "njk"
};
function getExtension(mimeType) {
    if (mimeType.startsWith("application/schema-instance+json") || mimeType.startsWith("application/schema+json")) {
        return "json";
    }
    if (mappings[mimeType]) {
        return mappings[mimeType];
    }
    return extension(mimeType);
}
function addExtension(resourceName, mimeType) {
    let ext = getExtension(mimeType);
    if (ext === null) return resourceName;
    ext = '.' + ext;
    return resourceName + (resourceName.endsWith(ext) ? '' : ext);
}
function getType(path) {
    let mimeType = lookup(path);
    if (mimeType) return mimeType;
    const ext = path.indexOf('.') >= 0 ? path.split(".").pop() : path;
    let [key, ] = Object.entries(mappings).find(([, value])=>value === ext) || [
        null,
        null
    ];
    if (!key) [key, ] = Object.entries(multiExtensions).find(([, values])=>values.indexOf(ext) >= 0) || [
        null,
        null
    ];
    return key;
}
function ab2str(buf) {
    return new TextDecoder().decode(new Uint8Array(buf));
}
function str2ab(str) {
    return new TextEncoder().encode(str).buffer;
}
function ab2b64(buf) {
    let binary = '';
    const bytes = new Uint8Array(buf);
    const len = bytes.byteLength;
    for(let i = 0; i < len; i++){
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}
function stripBom(str) {
    if (typeof str !== "string") {
        throw new TypeError(`Expected a string, got ${typeof str}`);
    }
    if (str.charCodeAt(0) === 0xFEFF) {
        return str.slice(1);
    }
    return str;
}
function copy(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
const MIN_READ = 32 * 1024;
const MAX_SIZE = 2 ** 32 - 2;
class Buffer {
    #buf;
    #off = 0;
    constructor(ab){
        this.#buf = ab === undefined ? new Uint8Array(0) : new Uint8Array(ab);
    }
    bytes(options = {
        copy: true
    }) {
        if (options.copy === false) return this.#buf.subarray(this.#off);
        return this.#buf.slice(this.#off);
    }
    empty() {
        return this.#buf.byteLength <= this.#off;
    }
    get length() {
        return this.#buf.byteLength - this.#off;
    }
    get capacity() {
        return this.#buf.buffer.byteLength;
    }
    truncate(n) {
        if (n === 0) {
            this.reset();
            return;
        }
        if (n < 0 || n > this.length) {
            throw Error("bytes.Buffer: truncation out of range");
        }
        this.#reslice(this.#off + n);
    }
    reset() {
        this.#reslice(0);
        this.#off = 0;
    }
    #tryGrowByReslice(n) {
        const l = this.#buf.byteLength;
        if (n <= this.capacity - l) {
            this.#reslice(l + n);
            return l;
        }
        return -1;
    }
    #reslice(len) {
        assert(len <= this.#buf.buffer.byteLength);
        this.#buf = new Uint8Array(this.#buf.buffer, 0, len);
    }
    readSync(p) {
        if (this.empty()) {
            this.reset();
            if (p.byteLength === 0) {
                return 0;
            }
            return null;
        }
        const nread = copy(this.#buf.subarray(this.#off), p);
        this.#off += nread;
        return nread;
    }
    read(p) {
        const rr = this.readSync(p);
        return Promise.resolve(rr);
    }
    writeSync(p) {
        const m = this.#grow(p.byteLength);
        return copy(p, this.#buf, m);
    }
    write(p) {
        const n = this.writeSync(p);
        return Promise.resolve(n);
    }
    #grow(n1) {
        const m = this.length;
        if (m === 0 && this.#off !== 0) {
            this.reset();
        }
        const i = this.#tryGrowByReslice(n1);
        if (i >= 0) {
            return i;
        }
        const c = this.capacity;
        if (n1 <= Math.floor(c / 2) - m) {
            copy(this.#buf.subarray(this.#off), this.#buf);
        } else if (c + n1 > MAX_SIZE) {
            throw new Error("The buffer cannot be grown beyond the maximum size.");
        } else {
            const buf = new Uint8Array(Math.min(2 * c + n1, MAX_SIZE));
            copy(this.#buf.subarray(this.#off), buf);
            this.#buf = buf;
        }
        this.#off = 0;
        this.#reslice(Math.min(m + n1, MAX_SIZE));
        return m;
    }
    grow(n) {
        if (n < 0) {
            throw Error("Buffer.grow: negative count");
        }
        const m = this.#grow(n);
        this.#reslice(m);
    }
    async readFrom(r) {
        let n = 0;
        const tmp = new Uint8Array(MIN_READ);
        while(true){
            const shouldGrow = this.capacity - this.length < MIN_READ;
            const buf = shouldGrow ? tmp : new Uint8Array(this.#buf.buffer, this.length);
            const nread = await r.read(buf);
            if (nread === null) {
                return n;
            }
            if (shouldGrow) this.writeSync(buf.subarray(0, nread));
            else this.#reslice(this.length + nread);
            n += nread;
        }
    }
    readFromSync(r) {
        let n = 0;
        const tmp = new Uint8Array(MIN_READ);
        while(true){
            const shouldGrow = this.capacity - this.length < MIN_READ;
            const buf = shouldGrow ? tmp : new Uint8Array(this.#buf.buffer, this.length);
            const nread = r.readSync(buf);
            if (nread === null) {
                return n;
            }
            if (shouldGrow) this.writeSync(buf.subarray(0, nread));
            else this.#reslice(this.length + nread);
            n += nread;
        }
    }
}
"\r".charCodeAt(0);
"\n".charCodeAt(0);
class AbstractBufBase {
    buf;
    usedBufferBytes = 0;
    err = null;
    constructor(buf){
        this.buf = buf;
    }
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriterSync extends AbstractBufBase {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriterSync ? writer : new BufWriterSync(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w;
    }
    flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p.length){
                nwritten += this.#writer.writeSync(p.subarray(nwritten));
            }
        } catch (e) {
            if (e instanceof Error) {
                this.err = e;
            }
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    writeSync(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = this.#writer.writeSync(data);
                } catch (e) {
                    if (e instanceof Error) {
                        this.err = e;
                    }
                    throw e;
                }
            } else {
                numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
function readerFromStreamReader(streamReader) {
    const buffer = new Buffer();
    return {
        async read (p) {
            if (buffer.empty()) {
                const res = await streamReader.read();
                if (res.done) {
                    return null;
                }
                await writeAll(buffer, res.value);
            }
            return buffer.read(p);
        }
    };
}
function readableStreamFromIterable(iterable) {
    const iterator = iterable[Symbol.asyncIterator]?.() ?? iterable[Symbol.iterator]?.();
    return new ReadableStream({
        async pull (controller) {
            const { value , done  } = await iterator.next();
            if (done) {
                controller.close();
            } else {
                controller.enqueue(value);
            }
        },
        async cancel (reason) {
            if (typeof iterator.throw == "function") {
                try {
                    await iterator.throw(reason);
                } catch  {}
            }
        }
    });
}
async function writeAll(w, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += await w.write(arr.subarray(nwritten));
    }
}
class MessageBody {
    statusCode;
    wasMimeHandled;
    _size;
    get size() {
        if (this.data instanceof ArrayBuffer) return this.data.byteLength;
        if (!this.data) return 0;
        return this._size || 0;
    }
    set size(newSize) {
        this._size = newSize;
    }
    get ok() {
        return this.statusCode === 0 || 200 <= this.statusCode && this.statusCode < 300;
    }
    get isStream() {
        return this.data instanceof ReadableStream;
    }
    constructor(data, mimeType = "text/plain", size, dateModified, filename){
        this.data = data;
        this.mimeType = mimeType;
        this.dateModified = dateModified;
        this.filename = filename;
        this.statusCode = 0;
        this.wasMimeHandled = false;
        this._size = size;
    }
    copy() {
        let newData = this.data;
        if (this.data && this.data instanceof ReadableStream) {
            [this.data, newData] = this.data.tee();
        }
        return new MessageBody(newData, this.mimeType, this.size, this.dateModified, this.filename);
    }
    convertFormData() {
        if (this.data instanceof ArrayBuffer && this.mimeType === 'application/x-www-form-urlencoded') {
            const formData = ab2str(this.data);
            const lines = formData.split('&');
            const obj = lines.reduce((res, line)=>{
                const parts = line.split('=');
                res[decodeURIComponentAndPlus(parts[0])] = parts.length < 2 ? null : decodeURIComponentAndPlus(parts[1]);
                return res;
            }, {});
            this.data = str2ab(JSON.stringify(obj));
            this.mimeType = 'application/json';
        }
    }
    async ensureDataIsArrayBuffer() {
        if (!(this.data instanceof ArrayBuffer)) {
            if (!this.data) {
                const err = new Error('Resource does not exist');
                err['statusCode'] = this.statusCode;
                throw err;
            }
            const resp = new Response(this.data);
            this.data = await resp.arrayBuffer();
        }
    }
    setMimeType(mimeType) {
        this.mimeType = mimeType;
        return this;
    }
    setIsDirectory() {
        this.mimeType = 'inode/directory+json';
        return this;
    }
    get isDirectory() {
        return this.mimeType === 'inode/directory+json';
    }
    async asJson() {
        if (this.data === null) return null;
        const str = await this.asString();
        if (isJson(this.mimeType)) {
            if (!str) return null;
            const obj = JSON.parse(str);
            return obj;
        } else {
            return str;
        }
    }
    async extractPathIfJson(path) {
        if (!isJson(this.mimeType)) return;
        const val = await this.asJson();
        this.data = str2ab(JSON.stringify(getProp(val, path)));
    }
    isTextual() {
        return isJson(this.mimeType) || isText(this.mimeType);
    }
    async asString() {
        if (this.data === null) return null;
        let enc = 'base64';
        let str;
        if (this.isTextual()) {
            str = ab2str(await this.asArrayBuffer());
            return stripBom(str);
        }
        const buf = await this.asArrayBuffer();
        if (this.isTextual()) enc = 'utf8';
        str = enc === 'base64' ? ab2b64(buf) : ab2str(buf);
        return stripBom(str);
    }
    asStringSync() {
        if (!(this.data instanceof ArrayBuffer)) return "";
        return this.isTextual() ? ab2str(this.data) : ab2b64(this.data);
    }
    async asArrayBuffer() {
        if (this.data === null) return null;
        await this.ensureDataIsArrayBuffer();
        this.convertFormData();
        return this.data;
    }
    asReadable() {
        if (this.data === null) return null;
        if (this.data instanceof ReadableStream) return this.data;
        return new Response(this.data).body;
    }
    asServerResponseBody() {
        if (this.data === null) return undefined;
        if (this.data instanceof ReadableStream) return readerFromStreamReader(this.data.getReader());
        return new Uint8Array(this.data);
    }
    asAny() {
        if (this.data === null) {
            return Promise.resolve(null);
        } else if (isJson(this.mimeType)) {
            return this.asJson();
        } else if (isText(this.mimeType)) {
            return this.asString();
        } else {
            return this.asArrayBuffer();
        }
    }
    static fromRequest(req) {
        const contentLength = req.headers.get('content-length');
        const size = contentLength != null ? parseInt(contentLength) : NaN;
        const contentType = req.headers.get('content-type');
        return contentType && req.body ? new MessageBody(req.body, contentType, isNaN(size) ? undefined : size) : null;
    }
    static fromString(text) {
        return new MessageBody(str2ab(text), 'text/plain');
    }
    static fromObject(obj) {
        const msgBody = MessageBody.fromString(JSON.stringify(obj));
        msgBody.mimeType = 'application/json';
        return msgBody;
    }
    static fromError(statusCode, statusText) {
        const msgBody = MessageBody.fromString(statusText || '');
        msgBody.statusCode = statusCode;
        return msgBody;
    }
    data;
    mimeType;
    dateModified;
    filename;
}
var SameSiteValue;
(function(SameSiteValue) {
    SameSiteValue["strict"] = "Strict";
    SameSiteValue["lax"] = "Lax";
    SameSiteValue["none"] = "None";
})(SameSiteValue || (SameSiteValue = {}));
class CookieOptions {
    expires;
    maxAge;
    domain;
    path;
    secure;
    httpOnly;
    sameSite;
    constructor(obj){
        obj && Object.assign(this, obj);
    }
    toString() {
        const opts = [];
        if (this.expires) opts.push(`Expires=${this.expires.toUTCString()}`);
        if (this.maxAge) opts.push(`Max-Age=${this.maxAge}`);
        if (this.domain) opts.push(`Domain=${this.domain}`);
        opts.push(this.path ? `Path=${this.path}` : "Path=/");
        if (this.secure) opts.push("Secure");
        if (this.httpOnly) opts.push("HttpOnly");
        if (this.sameSite) opts.push(`SameSite=${this.sameSite}`);
        return opts.length ? '; ' + opts.join('; ') : '';
    }
}
var rangeParser_1 = rangeParser;
function rangeParser(size, str, options) {
    if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
    }
    var index = str.indexOf("=");
    if (index === -1) {
        return -2;
    }
    var arr = str.slice(index + 1).split(",");
    var ranges = [];
    ranges.type = str.slice(0, index);
    for(var i = 0; i < arr.length; i++){
        var range = arr[i].split("-");
        var start = parseInt(range[0], 10);
        var end = parseInt(range[1], 10);
        if (isNaN(start)) {
            start = size - end;
            end = size - 1;
        } else if (isNaN(end)) {
            end = size - 1;
        }
        if (end > size - 1) {
            end = size - 1;
        }
        if (isNaN(start) || isNaN(end) || start > end || start < 0) {
            continue;
        }
        ranges.push({
            start,
            end
        });
    }
    if (ranges.length < 1) {
        return -1;
    }
    return options && options.combine ? combineRanges(ranges) : ranges;
}
function combineRanges(ranges) {
    var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
    for(var j = 0, i = 1; i < ordered.length; i++){
        var range = ordered[i];
        var current = ordered[j];
        if (range.start > current.end + 1) {
            ordered[++j] = range;
        } else if (range.end > current.end) {
            current.end = range.end;
            current.index = Math.min(current.index, range.index);
        }
    }
    ordered.length = j + 1;
    var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
    combined.type = ranges.type;
    return combined;
}
function mapWithIndex(range, index) {
    return {
        start: range.start,
        end: range.end,
        index
    };
}
function mapWithoutIndex(range) {
    return {
        start: range.start,
        end: range.end
    };
}
function sortByRangeIndex(a, b) {
    return a.index - b.index;
}
function sortByRangeStart(a, b) {
    return a.start - b.start;
}
class EventEmitter {
    _events_ = new Map();
    on(event, listener) {
        if (!this._events_.has(event)) this._events_.set(event, new Set());
        this._events_.get(event).add(listener);
        return this;
    }
    once(event, listener) {
        const l = listener;
        l.__once__ = true;
        return this.on(event, l);
    }
    off(event, listener) {
        if (!event && listener) throw new Error("Why is there a listener defined here?");
        else if (!event && !listener) this._events_.clear();
        else if (event && !listener) this._events_.delete(event);
        else if (event && listener && this._events_.has(event)) {
            const _ = this._events_.get(event);
            _.delete(listener);
            if (_.size === 0) this._events_.delete(event);
        } else {
            throw new Error("Unknown action!");
        }
        return this;
    }
    emitSync(event, ...args) {
        if (!this._events_.has(event)) return this;
        const _ = this._events_.get(event);
        for (let [, listener] of _.entries()){
            const r = listener(...args);
            if (r instanceof Promise) r.catch(console.error);
            if (listener.__once__) {
                delete listener.__once__;
                _.delete(listener);
            }
        }
        if (_.size === 0) this._events_.delete(event);
        return this;
    }
    async emit(event, ...args) {
        if (!this._events_.has(event)) return this;
        const _ = this._events_.get(event);
        for (let [, listener] of _.entries()){
            try {
                await listener(...args);
                if (listener.__once__) {
                    delete listener.__once__;
                    _.delete(listener);
                }
            } catch (error) {
                console.error(error);
            }
        }
        if (_.size === 0) this._events_.delete(event);
        return this;
    }
    queue(event, ...args) {
        (async ()=>await this.emit(event, ...args))().catch(console.error);
        return this;
    }
    pull(event, timeout) {
        return new Promise(async (resolve, reject)=>{
            let timeoutId;
            let listener = (...args)=>{
                if (timeoutId !== null) clearTimeout(timeoutId);
                resolve(args);
            };
            timeoutId = typeof timeout !== "number" ? null : setTimeout(()=>(this.off(event, listener), reject(new Error("Timed out!"))));
            this.once(event, listener);
        });
    }
}
class ArrayQueue extends Array {
    enqueue(value) {
        return this.push(value);
    }
    dequeue() {
        return this.shift();
    }
}
class AsyncQueue {
    _values;
    _settlers;
    _nPassed;
    _nActiveChildren;
    _state;
    _nAwaiting;
    static queueCount = 0;
    _qid;
    emitter;
    get nRemaining() {
        return this.maxPassed !== undefined ? this.maxPassed - this._nPassed : 1;
    }
    constructor(maxPassed){
        this.maxPassed = maxPassed;
        this._nPassed = 0;
        this._nActiveChildren = 0;
        this._state = "running";
        this._nAwaiting = 0;
        this.emitter = new EventEmitter();
        this._values = new ArrayQueue();
        this._settlers = new ArrayQueue();
        this._qid = AsyncQueue.queueCount++;
        this.updateState();
    }
    updateState(closeRequested = false) {
        if (this._qid == 9999) console.log(`state change qid ${this._qid} maxp ${this.maxPassed} starts ${this._state} nAwaiting ${this._nAwaiting} nPassed ${this._nPassed} nChild ${this._nActiveChildren} close req ${closeRequested}`);
        if (this._state === "running" && (this.maxPassed !== undefined && this._nPassed >= this.maxPassed || closeRequested)) {
            this.emitter.emit('statechange', 'no-enqueue');
            this._state = "no-enqueue";
        }
        if (this._state === "no-enqueue" && this._nActiveChildren === 0 && this._nAwaiting === 0) {
            this.emitter.emit('statechange', 'all-enqueued');
            this._state = "all-enqueued";
        }
        if (this._state === "all-enqueued" && this._values.length === 0) {
            this.emitter.emit('statechange', 'closed');
            this._state = "closed";
            this.finalClose();
        }
    }
    [Symbol.asyncIterator]() {
        return this;
    }
    enqueue(value) {
        if (this._state !== "running") {
            throw new Error('Closed');
        }
        if (value instanceof Promise) {
            this._nAwaiting++;
            value.then((res)=>{
                this.innerEnqueue(res, false, true);
                this._nAwaiting--;
                this.updateState();
                if (this._qid == 9999) console.log(`enqueue promise qid ${this._qid} maxp ${this.maxPassed}, after nAwaiting: ${this._nAwaiting}, state: ${this._state}`);
            }).catch((reason)=>{
                if (!(reason instanceof Error)) reason = new Error(reason.toString());
                this.innerEnqueue(reason, false, true);
                this._nAwaiting--;
                this.updateState();
            });
        } else {
            this.innerEnqueue(value, false);
        }
        return this;
    }
    innerEnqueue(value, fromChild, fromPromise) {
        const allowedNoenqueue = this._state == "no-enqueue" && (fromChild || fromPromise);
        if (allowedNoenqueue) {
            if (this._qid == 9999) console.log(`Allowed no-enqueue, qid: ${this._qid} maxp: ${this.maxPassed} state: ${this._state}, fromChild: ${fromChild}, fromPromise: ${fromPromise} nChild ${this._nActiveChildren} nAwaiting ${this._nAwaiting}`);
        }
        if (this._state !== "running" && !allowedNoenqueue) {
            if (this._qid == 9999) console.log(`Illegal enqueue, qid: ${this._qid} maxp: ${this.maxPassed} state: ${this._state}, fromChild: ${fromChild}, fromPromise: ${fromPromise}`);
            throw new Error('Illegal internal enqueue after closed');
        }
        if (value instanceof AsyncQueue) {
            if (fromChild) return;
            this.attachSubqueue(value);
        } else {
            if (value !== null && value !== undefined) {
                if (this._settlers.length > 0) {
                    if (this._values.length > 0) {
                        throw new Error('Illegal internal state');
                    }
                    const settler = this._settlers.dequeue();
                    if (value instanceof Error) {
                        settler.reject(value);
                    } else {
                        settler.resolve({
                            value
                        });
                    }
                } else {
                    this._values.enqueue(value);
                }
            }
        }
        this.emitter.emit('enqueue', value);
        if (!fromChild) this._nPassed++;
        this.updateState();
    }
    attachSubqueue(subqueue) {
        subqueue._values.forEach((val)=>this.innerEnqueue(val, true));
        if (subqueue._state === "running" || subqueue._state === "no-enqueue") {
            subqueue.on('enqueue', (val)=>this.innerEnqueue(val, true));
            this._nActiveChildren++;
            const decrementActiveChildren = (newState)=>{
                if (newState === 'all-enqueued') {
                    this._nActiveChildren--;
                    this.updateState();
                    subqueue.off('statechange', decrementActiveChildren);
                }
            };
            subqueue.on('statechange', decrementActiveChildren);
        }
    }
    next() {
        if (this._values.length > 0) {
            const value = this._values.dequeue();
            this.updateState();
            if (value instanceof Error) {
                return Promise.reject(value);
            } else {
                return Promise.resolve({
                    value
                });
            }
        } else if (this._state === 'closed') {
            if (this._settlers.length > 0) {
                throw new Error('Illegal internal state');
            }
            return Promise.resolve({
                done: true
            });
        } else {
            return new Promise((resolve, reject)=>{
                this._settlers.enqueue({
                    resolve,
                    reject
                });
            });
        }
    }
    close() {
        this.updateState(true);
    }
    finalClose() {
        while(this._settlers.length > 0){
            this._settlers.dequeue().resolve({
                done: true
            });
        }
    }
    on(event, listener) {
        this.emitter.on(event, listener);
    }
    off(event, listener) {
        this.emitter.off(event, listener);
    }
    flatMap(mapper) {
        const newAsq = new AsyncQueue();
        const getResultsAsync = async ()=>{
            try {
                for await (const item of this){
                    let res;
                    try {
                        res = mapper(item);
                        if (res !== undefined) newAsq.enqueue(res);
                    } catch (err) {
                        newAsq.enqueue(err);
                    }
                }
            } catch (err1) {
                newAsq.enqueue(err1);
            }
            newAsq.close();
        };
        getResultsAsync();
        return newAsq;
    }
    static fromPromises(...promises) {
        const asq = new AsyncQueue();
        let nUnresolved = promises.length;
        promises.forEach((promise)=>promise.then((val)=>{
                if (val !== null && val !== undefined) asq.enqueue(val);
                nUnresolved--;
                if (nUnresolved <= 0) asq.close();
            }).catch((reason)=>{
                asq.enqueue(reason);
                nUnresolved--;
                if (nUnresolved <= 0) asq.close();
            }));
        return asq;
    }
    maxPassed;
}
const sendHeaders = [
    "accept-ranges",
    "access-control-allow-origin",
    "access-control-allow-credentials",
    "access-control-expose-headers",
    "access-control-max-age",
    "access-control-allow-methods",
    "access-control-allow-headers",
    "cache-control",
    "content-disposition",
    "content-encoding",
    "content-language",
    "content-length",
    "content-location",
    "content-md5",
    "content-range",
    "content-security-policy",
    "content-type",
    "date",
    "delta-base",
    "etag",
    "expires",
    "im",
    "last-modified",
    "link",
    "location",
    "p3p",
    "pragma",
    "proxy-authenticate",
    "public-key-pins",
    "refresh",
    "retry-after",
    "server",
    "set-cookie",
    "strict-transport-security",
    "timing-allow-origin",
    "trailer",
    "transfer-encoding",
    "tk",
    "upgrade",
    "vary",
    "via",
    "warning",
    "www-authenticate",
    "x-content-type-options",
    "x-correlation-id",
    "x-frame-options",
    "x-powered-by",
    "x-request-id",
    "x-restspace-service",
    "x-ua-compatible",
    "x-xss-protection"
];
const headerDate = (d)=>{
    const leadingZ = (n)=>n.toString().padStart(2, '0');
    const dayName = [
        'Sun',
        'Mon',
        'Tue',
        'Wed',
        'Thu',
        'Fri',
        'Sat'
    ][d.getUTCDay()];
    const day = leadingZ(d.getUTCDate());
    const month = [
        'Jan',
        'Feb',
        'Mar',
        'Apr',
        'May',
        'Jun',
        'Jul',
        'Aug',
        'Sep',
        'Oct',
        'Nov',
        'Dec'
    ][d.getUTCMonth()];
    const year = d.getUTCFullYear();
    const hour = leadingZ(d.getUTCHours());
    const minute = leadingZ(d.getUTCMinutes());
    const second = leadingZ(d.getUTCSeconds());
    return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
};
class Message {
    cookies;
    context;
    depth;
    conditionalMode;
    authenticated;
    originator;
    internalPrivilege;
    url;
    externalUrl;
    user;
    websocket;
    _status;
    _data;
    uninitiatedDataCopies;
    _headers;
    static pullName = new RegExp(/([; ]name=["'])(.*?)(["'])/);
    get headers() {
        const headersOut = {
            ...this._headers
        };
        if (this.data?.mimeType) {
            headersOut['content-type'] = this.data?.mimeType;
        }
        if (!headersOut['content-type']) headersOut['content-type'] = 'text/plain';
        if (this.data?.size) {
            headersOut['content-length'] = this.data.size.toString();
        }
        if (this.data?.filename) {
            headersOut['content-disposition'] = `attachment; filename="${this.data.filename}"`;
        }
        if (this.data?.dateModified) {
            headersOut['last-modified'] = headerDate(this.data.dateModified);
        }
        return headersOut;
    }
    set headers(val) {
        const valLowerCase = Object.fromEntries(Object.entries(val).map(([k, v])=>[
                k.toLowerCase(),
                v
            ]));
        this._headers = valLowerCase;
    }
    get data() {
        return this._data;
    }
    set data(d) {
        this.cancelOldStream();
        this._data = d;
    }
    get status() {
        return this.data && this.data.statusCode > 0 ? this.data.statusCode : this._status;
    }
    set status(code) {
        this._status = code;
    }
    get ok() {
        return this.status < 400;
    }
    get isRedirect() {
        return 300 <= this.status && this.status < 400;
    }
    get isManageRequest() {
        const modeHdr = this.getHeader('X-Restspace-Request-Mode');
        return !!modeHdr && modeHdr === 'manage';
    }
    get name() {
        const cd = this.getHeader('Content-Disposition');
        if (!cd) return '';
        const match = Message.pullName.exec(cd);
        return match && match[2] ? match[2] : '';
    }
    set name(name) {
        const cd = this.getHeader('Content-Disposition');
        if (cd) {
            this.setHeader('Content-Disposition', cd.replace(Message.pullName, `$1${name}$3`));
        } else {
            this.setHeader('Content-Disposition', `form-data; name="${name}"`);
        }
    }
    get host() {
        const host = this.getHeader('Host');
        return host || '';
    }
    constructor(url, tenant, method = "GET", parent, headers, data){
        this.tenant = tenant;
        this.method = method;
        this.cookies = {};
        this.context = {};
        this.depth = 0;
        this.conditionalMode = false;
        this.authenticated = false;
        this.originator = '';
        this.internalPrivilege = false;
        this.externalUrl = null;
        this.user = null;
        this.websocket = null;
        this._status = 0;
        this.uninitiatedDataCopies = [];
        this._headers = {};
        this.forbiddenHeaders = [
            "accept-charset",
            "accept-encoding",
            "access-control-request-headers",
            "access-control-request-method",
            "connection",
            "date",
            "dnt",
            "expect",
            "feature-policy",
            "host",
            "keep-alive",
            "origin",
            "referer",
            "te",
            "trailer",
            "transfer-encoding",
            "upgrade",
            "via"
        ];
        this.url = typeof url === 'string' ? new Url(url) : url;
        this.data = data;
        if (headers) {
            if (headers instanceof Headers) {
                for (const [key, val] of headers.entries())this._headers[key.toLowerCase()] = val;
            } else {
                this.headers = headers;
            }
        }
        if (this.getHeader("x-forwarded-proto")) {
            this.url.scheme = this.getHeader("x-forwarded-proto") + '://';
        }
        if (parent === null) {
            const traceId = crypto.randomUUID().replace(/-/g, '');
            const spanId = crypto.randomUUID().replace(/-/g, '').substring(0, 16);
            this.setHeader('traceparent', `00-${traceId}-${spanId}-00`);
        } else {
            const traceparent = parent.getHeader('traceparent');
            if (traceparent) {
                this.setHeader('traceparent', traceparent);
                const tracestate = parent.getHeader('tracestate');
                if (tracestate) this.setHeader('tracestate', tracestate);
            }
        }
        const cookieStrings = (this.headers['cookie'] || '').split(';');
        this.cookies = cookieStrings ? cookieStrings.reduce((res, cookieString)=>{
            const parts = cookieString.trim().split('=');
            res[parts[0]] = parts[1];
            return res;
        }, {}) : {};
    }
    copy(withData = true) {
        const msg = new Message(this.url.copy(), this.tenant, this.method, this, {
            ...this._headers
        }, withData ? this.data : undefined);
        msg.externalUrl = this.externalUrl ? this.externalUrl.copy() : null;
        msg.depth = this.depth;
        msg.conditionalMode = this.conditionalMode;
        msg.authenticated = this.authenticated;
        msg.internalPrivilege = this.internalPrivilege;
        msg.user = this.user;
        msg.name = this.name;
        return msg.setStatus(this.status);
    }
    copyWithData() {
        const newMsg = this.copy();
        newMsg.data = this.data ? this.data.copy() : undefined;
        if (newMsg.data) this.uninitiatedDataCopies.push(newMsg.data);
        return newMsg;
    }
    setMetadataOn(msg) {
        msg.externalUrl = this.externalUrl ? this.externalUrl.copy() : null;
        msg.depth = this.depth;
        msg.conditionalMode = this.conditionalMode;
        msg.authenticated = this.authenticated;
        msg.internalPrivilege = this.internalPrivilege;
        msg.user = this.user;
        msg.name = this.name;
        const traceparent = this.getHeader('traceparent');
        if (traceparent) msg.setHeader('traceparent', traceparent);
    }
    hasData() {
        return !!this.data && !!this.data.data;
    }
    headerCase(header) {
        return header.split('-').map((part)=>part.substr(0, 1).toUpperCase() + part.substr(1).toLowerCase()).join('-');
    }
    mapHeaders(msgHeaders, headers) {
        Object.entries(msgHeaders).flatMap(([k, vs])=>Array.isArray(vs) ? vs.map((v)=>[
                    k,
                    v
                ]) : [
                [
                    k,
                    vs
                ]
            ]).forEach(([k, v])=>headers.set(this.headerCase(k), v));
        return headers;
    }
    responseHeadersOnly(headers) {
        const isContentDispositionFormData = (k, v)=>k.toLowerCase() === 'content-disposition' && !Array.isArray(v) && v.startsWith('form-data');
        return Object.fromEntries(Object.entries(headers).filter(([k, v])=>sendHeaders.indexOf(k.toLowerCase()) >= 0 && !isContentDispositionFormData(k, v)));
    }
    forbiddenHeaders;
    nonForbiddenHeaders() {
        const isForbidden = (h)=>this.forbiddenHeaders.includes(h) || h.startsWith('proxy-') || h.startsWith('sec-');
        return Object.fromEntries(Object.entries(this.headers).filter(([k, _])=>!isForbidden(k)));
    }
    responsify() {
        this.method = "";
        this.status = this.status || 200;
    }
    requestify() {
        this.status = 0;
    }
    toResponse() {
        const res = new Response(this.data?.data || undefined, {
            status: this.status || 200
        });
        this.mapHeaders(this.responseHeadersOnly(this.headers), res.headers);
        if (this.data) {
            res.headers.delete('content-length');
        }
        res.headers.set('X-Powered-By', 'Restspace');
        return res;
    }
    toRequest() {
        if (this.data?.data instanceof ReadableStream) {
            if (this.data.data.locked) throw new Error("Can't convert locked stream to request, will fail");
        }
        const req = new Request(this.url.toString(), {
            method: this.method,
            headers: this.mapHeaders(this.nonForbiddenHeaders(), new Headers()),
            body: this.data?.data || undefined
        });
        return req;
    }
    setStatus(status, message) {
        if (message !== undefined) {
            this.setData(message, 'text/plain');
        }
        this.status = status;
        return this;
    }
    getHeader(header) {
        const hdr = this.headers[header.toLowerCase()];
        return Array.isArray(hdr) ? hdr[0] : hdr;
    }
    setHeader(header, value) {
        this._headers[header.toLowerCase()] = value;
        return this;
    }
    removeHeader(header) {
        delete this._headers[header.toLowerCase()];
        return this;
    }
    async getParam(name, urlPosition = -1) {
        if (urlPosition > 0 && this.url.servicePathElements.length > urlPosition) {
            return this.url.servicePathElements[urlPosition];
        } else if (this.url.query[name]) {
            return this.url.query[name] || undefined;
        }
        if (this.data && isJson(this.data.mimeType)) {
            const json = await this.data.asJson() || {};
            return json[name];
        }
        return undefined;
    }
    setServiceRedirect(servicePath) {
        this.setHeader('X-Restspace-Service-Redirect', servicePath);
    }
    getServiceRedirect() {
        const redir = this.getHeader('X-Restspace-Service-Redirect');
        return redir;
    }
    applyServiceRedirect() {
        const redirServicePath = this.getServiceRedirect();
        if (redirServicePath) this.url.servicePath = redirServicePath;
    }
    getRequestRange(size) {
        const ranges = this.getHeader('Range');
        if (!ranges) return null;
        const parsed = rangeParser_1(size, ranges, {
            combine: true
        });
        return parsed;
    }
    setRange(type, size, range) {
        this.setHeader('Content-Range', type + ' ' + (range ? range.start + '-' + range.end : '*') + '/' + size);
        if (range && this.data) this.data.size = range.end - range.start + 1;
        return this;
    }
    getCookie(name) {
        return this.cookies[name] === undefined ? undefined : decodeURIComponent(this.cookies[name]);
    }
    setCookie(name, value, options) {
        let currSetCookie = this.headers['set-cookie'] || [];
        currSetCookie = currSetCookie.filter((sc)=>!sc.startsWith(name + '='));
        this._headers['set-cookie'] = [
            ...currSetCookie,
            `${name}=${encodeURIComponent(value)}${options}`
        ];
        return this;
    }
    deleteCookie(name) {
        this.setCookie(name, '', new CookieOptions({
            expires: new Date(2000, 0, 1)
        }));
    }
    cancelOldStream() {
        if (this.data?.data instanceof ReadableStream) {
            const self1 = this;
            (async (rs)=>{
                try {
                    if (rs !== self1.data?.data) {
                        await rs.cancel('message body change');
                    }
                } catch  {}
            })(this.data.data);
        }
    }
    setData(data, mimeType) {
        this.cancelOldStream();
        if (data == null) {
            this.data = undefined;
        } else if (typeof data === 'string') {
            this.data = new MessageBody(str2ab(data), mimeType);
        } else {
            this.data = new MessageBody(data, mimeType);
        }
        this._status = 0;
        this.conditionalMode = false;
        this.setHeader("content-type", mimeType);
        return this;
    }
    setText(data) {
        this.cancelOldStream();
        this.data = new MessageBody(str2ab(data), 'text/plain');
        this._status = 0;
        this.conditionalMode = false;
        return this;
    }
    setDataJson(value, mimeType) {
        this._status = 0;
        this.conditionalMode = false;
        return this.setData(JSON.stringify(value), mimeType || 'application/json');
    }
    setDirectoryJson(value) {
        this.setDataJson(value);
        this.data?.setMimeType('inode/directory+json');
        return this;
    }
    setMethod(httpMethod) {
        this.method = httpMethod;
        return this;
    }
    setUrl(url) {
        if (typeof url === 'string') {
            this.url = Url.inheritingBase(this.url, url);
        } else {
            this.url = url;
        }
        return this;
    }
    setName(name) {
        this.name = name;
        return this;
    }
    setDateModified(dateModified) {
        if (this.data) this.data.dateModified = dateModified;
        return this;
    }
    enterConditionalMode() {
        if (!this.ok) {
            const errorMsg = this.data && this.data.data instanceof ArrayBuffer ? ab2str(this.data.data) : '';
            this.conditionalMode = true;
            this.setDataJson({
                _errorStatus: this.status,
                _errorMessage: errorMsg
            }).setStatus(200);
        }
        return this;
    }
    exitConditionalMode() {
        if (this?.data?.mimeType === 'application/json' && this?.data.data instanceof ArrayBuffer) {
            const str = ab2str(this.data.data);
            const err = str ? JSON.parse(str) : {};
            if (err && err['_errorStatus'] !== undefined && err['_errorMessage'] !== undefined) {
                this.setStatus(err['_errorStatus'], err['_errorMessage']);
            }
            this.conditionalMode = false;
        }
        return this;
    }
    callDown() {
        this.depth++;
        return this;
    }
    callUp() {
        this.depth--;
        return this;
    }
    startSpan(traceparent, tracestate) {
        if (!traceparent) traceparent = this.getHeader('traceparent');
        if (traceparent) {
            const traceParts = traceparent.split('-');
            const newSpanId = crypto.randomUUID().replace(/-/g, '').substring(0, 16);
            this.setHeader('traceparent', `${traceParts[0]}-${traceParts[1]}-${newSpanId}-00`);
            if (tracestate) this.setHeader('tracestate', tracestate);
        }
        return this;
    }
    loggerArgs() {
        let traceId = 'x'.repeat(32);
        let spanId = 'x'.repeat(16);
        const traceparent = this.getHeader('traceparent');
        if (traceparent) {
            const parts = traceparent.split('-');
            traceId = parts[1];
            spanId = parts[2];
        }
        return [
            this.tenant,
            this.user?.email || '?',
            traceId,
            spanId
        ];
    }
    async requestExternal() {
        let resp;
        try {
            resp = await fetch(this.toRequest());
        } catch (err) {
            console.error(`Request failed: ${err}`);
            return this.setStatus(500, `request fail: ${err}`);
        }
        const msgOut = Message.fromResponse(resp, this.tenant);
        msgOut.method = this.method;
        msgOut.name = this.name;
        this.setMetadataOn(msgOut);
        return msgOut;
    }
    async divertToSpec(spec, defaultMethod, effectiveUrl, inheritMethod, headers) {
        if (Array.isArray(spec)) {
            const unflatMsgs = await Promise.all(spec.flatMap((stg)=>this.divertToSpec(stg, defaultMethod, effectiveUrl, inheritMethod, headers)));
            return unflatMsgs.flat(1);
        }
        let obj = {};
        const hasData = (mimeType)=>isJson(mimeType) || mimeType === 'application/x-www-form-urlencoded';
        const specHasObjectMacro = spec.indexOf('${') >= 0 || spec.indexOf(' $this') >= 0;
        if (this.data && this.data.mimeType && hasData(this.data.mimeType) && specHasObjectMacro) {
            obj = await this.data.asJson();
        }
        const msgs = Message.fromSpec(spec, this.tenant, effectiveUrl || this.url, obj, defaultMethod, this.name, inheritMethod, headers);
        (Array.isArray(msgs) ? msgs : [
            msgs
        ]).forEach((msg)=>{
            msg.data = msg.data || this.data;
            msg._headers = {
                ...this._headers
            };
            msg.setStatus(this.status);
            this.setMetadataOn(msg);
        });
        return msgs;
    }
    redirect(url, isTemporary) {
        this.setStatus(isTemporary ? 302 : 301);
        this.setHeader('Location', url.toString());
        return this;
    }
    splitData() {
        const datas = new AsyncQueue();
        if (!this.data) {
            datas.close();
            return datas;
        }
        switch(this.data.mimeType){
            default:
                {
                    datas.enqueue(this);
                    datas.close();
                }
        }
        return datas;
    }
    async validate(validator) {
        if (!this.data || !isJson(this.data.mimeType)) {
            validator.errors = [
                {
                    keyword: "",
                    instancePath: "",
                    schemaPath: "",
                    params: {},
                    message: "The body was not JSON"
                }
            ];
            return false;
        }
        const json = await this.data.asJson();
        return validator(json);
    }
    toString() {
        const startLine = `${this.method} ${this.url.toString("absolute path")} HTTP/1.1`;
        const headers = Object.entries(this.headers).flatMap(([name, vals])=>(Array.isArray(vals) ? vals : [
                vals
            ]).map((val)=>`${name}: ${val}`));
        const body = this.data ? this.data.asStringSync() : '';
        return `${startLine}\r\n${headers.join("\r\n")}${body ? "\r\n\r\n" + body : ''}`;
    }
    async toUint8Array() {
        let startLine;
        if (this.method) {
            startLine = `${this.method} ${this.url.toString("absolute path")} HTTP/1.1`;
        } else {
            startLine = `HTTP/1.1 ${this.status} ${this.ok || !this.hasData ? "" : await this.data.asString()}`;
        }
        const headers = Object.entries(this.headers).flatMap(([name, vals])=>(Array.isArray(vals) ? vals : [
                vals
            ]).map((val)=>`${name}: ${val}`));
        const hasBody = !!this.data?.data;
        const enc = new TextEncoder().encode(`${startLine}\r\n${headers.join("\r\n")}${hasBody ? "\r\n\r\n" : ""}`);
        if (this.data?.data) {
            const body = await this.data.asArrayBuffer();
            const res = new Uint8Array(enc.byteLength + body.byteLength);
            res.set(enc, 0);
            res.set(new Uint8Array(body), enc.byteLength);
            return res;
        } else {
            return enc;
        }
    }
    static fromRequest(req, tenant) {
        const url = new Url(req.url);
        const msg = new Message(url, tenant, req.method, null, req.headers, MessageBody.fromRequest(req) || undefined);
        const traceparent = req.headers.get('traceparent');
        if (traceparent) {
            msg.setHeader('traceparent', traceparent);
            const tracestate = req.headers.get('tracestate');
            if (tracestate) msg.setHeader('tracestate', tracestate);
        }
        return msg;
    }
    static fromResponse(resp, tenant) {
        const msg = new Message(resp.url, tenant, "", null, resp.headers, resp.body ? new MessageBody(resp.body, resp.headers.get('content-type') || 'text/plain') : undefined);
        msg.setStatus(resp.status);
        const traceparent = resp.headers.get('traceparent');
        if (traceparent) {
            msg.setHeader('traceparent', traceparent);
            const tracestate = resp.headers.get('tracestate');
            if (tracestate) msg.setHeader('tracestate', tracestate);
        }
        return msg;
    }
    static fromUint8Array(arr, tenant) {
        const decoder = new TextDecoder();
        const pullString = (arr, start)=>{
            let pos = start;
            while(pos < arr.byteLength && arr[pos] !== 13 && arr[pos] !== 10)pos++;
            return [
                pos < arr.byteLength ? decoder.decode(arr.subarray(start, pos)) : '',
                pos + 2
            ];
        };
        let [line, pos] = pullString(arr, 0);
        const initial = upTo(line, ' ');
        let msg;
        if (initial === "HTTP/1.1") {
            const lastPart = after(line, ' ');
            const statusStr = upTo(lastPart, ' ');
            const statusMsg = after(lastPart, ' ');
            msg = new Message("/", tenant, "", null);
            msg.setStatus(parseInt(statusStr), statusMsg || undefined);
        } else {
            const firstPart = upToLast(line, ' ');
            const url = after(firstPart, ' ');
            msg = new Message(url, tenant, initial, null);
        }
        while(line){
            [line, pos] = pullString(arr, pos);
            if (!line) break;
            const headerParts = line.split(':');
            msg.setHeader(headerParts[0].trim(), headerParts[1].trim());
        }
        if (pos < arr.byteLength - 1 && msg.method) {
            const body = new Uint8Array(arr.subarray(pos)).buffer;
            const contentType = msg.getHeader('content-type');
            if (!contentType) throw new Error('Content-Type header not set');
            msg.setData(body, contentType);
        }
        return msg;
    }
    static isUrl(url) {
        return (Url.urlRegex.test(url) || url.startsWith('$')) && !url.startsWith('$this');
    }
    static isMethod(method) {
        return [
            "GET",
            "POST",
            "PUT",
            "DELETE",
            "OPTIONS",
            "HEAD",
            "PATCH",
            "$METHOD"
        ].includes(method);
    }
    static fromSpec(spec, tenant, referenceUrl, data, defaultMethod, name, inheritMethod, headers) {
        const parts = spec.trim().split(' ');
        let method = defaultMethod || 'GET';
        let url = '';
        let postData = null;
        if (Message.isUrl(parts[0]) && !Message.isMethod(parts[0])) {
            url = spec;
        } else if (parts.length > 1 && Message.isUrl(parts[1]) && Message.isMethod(parts[0])) {
            method = parts[0] === '$METHOD' ? inheritMethod || method : parts[0];
            url = parts.slice(1).join(' ');
        } else if (parts.length > 2 && Message.isUrl(parts[2]) && Message.isMethod(parts[0]) && data) {
            method = parts[0] === '$METHOD' ? inheritMethod || method : parts[0];
            const propertyPath = parts[1];
            if (propertyPath === '$this') {
                postData = data;
            } else {
                postData = getProp(data, propertyPath);
            }
            url = parts.slice(2).join(' ');
        } else {
            console.error('bad req spec: ' + spec);
            throw new Error('Bad request spec');
        }
        if (referenceUrl || data) {
            const refUrl = referenceUrl || new Url('/');
            const urls = resolvePathPatternWithUrl(url, refUrl, data, name);
            if (Array.isArray(urls)) {
                return urls.map((url)=>new Message(Url.inheritingBase(referenceUrl, url), tenant, method, null, {
                        ...headers
                    }, postData ? MessageBody.fromObject(postData) : undefined));
            }
            url = urls;
        }
        return new Message(Url.inheritingBase(referenceUrl, url), tenant, method, null, {
            ...headers
        }, postData ? MessageBody.fromObject(postData) : undefined);
    }
    tenant;
    method;
}
function longestMatchingPath(pathMap, path) {
    let exactPath = '/' + path + '.';
    let item = pathMap[exactPath];
    if (item) return exactPath;
    const pathParts = path.split('/');
    while(true){
        exactPath = '/' + pathParts.join('/');
        item = pathMap[exactPath];
        if (item) {
            return exactPath;
        } else {
            if (pathParts.length === 0) break;
            pathParts.pop();
        }
    }
    return undefined;
}
var fastDeepEqual = function equal(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
            length = a.length;
            if (length != b.length) return false;
            for(i = length; i-- !== 0;)if (!equal(a[i], b[i])) return false;
            return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for(i = length; i-- !== 0;){
            var key = keys[i];
            if (!equal(a[key], b[key])) return false;
        }
        return true;
    }
    return a !== a && b !== b;
};
function createCommonjsModule(fn, basedir, module) {
    return module = {
        path: basedir,
        exports: {},
        require: function(path, base) {
            return commonjsRequire(path, base === void 0 || base === null ? module.path : base);
        }
    }, fn(module, module.exports), module.exports;
}
function commonjsRequire() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var jsonSchemaTraverse = createCommonjsModule(function(module) {
    var traverse = module.exports = function(schema, opts, cb) {
        if (typeof opts == "function") {
            cb = opts;
            opts = {};
        }
        cb = opts.cb || cb;
        var pre = typeof cb == "function" ? cb : cb.pre || function() {};
        var post = cb.post || function() {};
        _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
        additionalItems: true,
        items: true,
        contains: true,
        additionalProperties: true,
        propertyNames: true,
        not: true,
        if: true,
        then: true,
        else: true
    };
    traverse.arrayKeywords = {
        items: true,
        allOf: true,
        anyOf: true,
        oneOf: true
    };
    traverse.propsKeywords = {
        $defs: true,
        definitions: true,
        properties: true,
        patternProperties: true,
        dependencies: true
    };
    traverse.skipKeywords = {
        default: true,
        enum: true,
        const: true,
        required: true,
        maximum: true,
        minimum: true,
        exclusiveMaximum: true,
        exclusiveMinimum: true,
        multipleOf: true,
        maxLength: true,
        minLength: true,
        pattern: true,
        format: true,
        maxItems: true,
        minItems: true,
        uniqueItems: true,
        maxProperties: true,
        minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (schema && typeof schema == "object" && !Array.isArray(schema)) {
            pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
            for(var key in schema){
                var sch = schema[key];
                if (Array.isArray(sch)) {
                    if (key in traverse.arrayKeywords) {
                        for(var i = 0; i < sch.length; i++)_traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
                    }
                } else if (key in traverse.propsKeywords) {
                    if (sch && typeof sch == "object") {
                        for(var prop in sch)_traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
                    }
                } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
                    _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
                }
            }
            post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        }
    }
    function escapeJsonPtr(str) {
        return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
});
jsonSchemaTraverse.arrayKeywords;
jsonSchemaTraverse.keywords;
jsonSchemaTraverse.propsKeywords;
jsonSchemaTraverse.skipKeywords;
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function createCommonjsModule1(fn, basedir, module) {
    return module = {
        path: basedir,
        exports: {},
        require: function(path, base) {
            return commonjsRequire1(path, base === void 0 || base === null ? module.path : base);
        }
    }, fn(module, module.exports), module.exports;
}
function commonjsRequire1() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var uri_all = createCommonjsModule1(function(module, exports) {
    (function(global2, factory) {
        factory(exports);
    })(commonjsGlobal, function(exports2) {
        function merge() {
            for(var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++){
                sets[_key] = arguments[_key];
            }
            if (sets.length > 1) {
                sets[0] = sets[0].slice(0, -1);
                var xl = sets.length - 1;
                for(var x = 1; x < xl; ++x){
                    sets[x] = sets[x].slice(1, -1);
                }
                sets[xl] = sets[xl].slice(1);
                return sets.join("");
            } else {
                return sets[0];
            }
        }
        function subexp(str) {
            return "(?:" + str + ")";
        }
        function typeOf(o) {
            return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
        }
        function toUpperCase(str) {
            return str.toUpperCase();
        }
        function toArray(obj) {
            return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [
                obj
            ] : Array.prototype.slice.call(obj) : [];
        }
        function assign(target, source) {
            var obj = target;
            if (source) {
                for(var key in source){
                    obj[key] = source[key];
                }
            }
            return obj;
        }
        function buildExps(isIRI) {
            var ALPHA$$ = "[A-Za-z]", DIGIT$$ = "[0-9]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([
                IPV6ADDRESS1$,
                IPV6ADDRESS2$,
                IPV6ADDRESS3$,
                IPV6ADDRESS4$,
                IPV6ADDRESS5$,
                IPV6ADDRESS6$,
                IPV6ADDRESS7$,
                IPV6ADDRESS8$,
                IPV6ADDRESS9$
            ].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*");
            return {
                NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
                NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
                NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
                NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
                NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
                NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
                NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
                ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
                UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
                OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
                PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
                IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
                IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
            };
        }
        var URI_PROTOCOL = buildExps(false);
        var IRI_PROTOCOL = buildExps(true);
        var slicedToArray = function() {
            function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                    for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
                        _arr.push(_s.value);
                        if (i && _arr.length === i) break;
                    }
                } catch (err) {
                    _d = true;
                    _e = err;
                } finally{
                    try {
                        if (!_n && _i["return"]) _i["return"]();
                    } finally{
                        if (_d) throw _e;
                    }
                }
                return _arr;
            }
            return function(arr, i) {
                if (Array.isArray(arr)) {
                    return arr;
                } else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                } else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
            };
        }();
        var toConsumableArray = function(arr) {
            if (Array.isArray(arr)) {
                for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++)arr2[i] = arr[i];
                return arr2;
            } else {
                return Array.from(arr);
            }
        };
        var maxInt = 2147483647;
        var base = 36;
        var tMin = 1;
        var tMax = 26;
        var skew = 38;
        var damp = 700;
        var initialBias = 72;
        var initialN = 128;
        var delimiter = "-";
        var regexPunycode = /^xn--/;
        var regexNonASCII = /[^\0-\x7E]/;
        var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
        var errors = {
            overflow: "Overflow: input needs wider integers to process",
            "not-basic": "Illegal input >= 0x80 (not a basic code point)",
            "invalid-input": "Invalid input"
        };
        var baseMinusTMin = base - tMin;
        var floor = Math.floor;
        var stringFromCharCode = String.fromCharCode;
        function error$1(type) {
            throw new RangeError(errors[type]);
        }
        function map(array, fn) {
            var result = [];
            var length = array.length;
            while(length--){
                result[length] = fn(array[length]);
            }
            return result;
        }
        function mapDomain(string, fn) {
            var parts = string.split("@");
            var result = "";
            if (parts.length > 1) {
                result = parts[0] + "@";
                string = parts[1];
            }
            string = string.replace(regexSeparators, ".");
            var labels = string.split(".");
            var encoded = map(labels, fn).join(".");
            return result + encoded;
        }
        function ucs2decode(string) {
            var output = [];
            var counter = 0;
            var length = string.length;
            while(counter < length){
                var value = string.charCodeAt(counter++);
                if (value >= 55296 && value <= 56319 && counter < length) {
                    var extra = string.charCodeAt(counter++);
                    if ((extra & 64512) == 56320) {
                        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                    } else {
                        output.push(value);
                        counter--;
                    }
                } else {
                    output.push(value);
                }
            }
            return output;
        }
        var ucs2encode = function ucs2encode2(array) {
            return String.fromCodePoint.apply(String, toConsumableArray(array));
        };
        var basicToDigit = function basicToDigit2(codePoint) {
            if (codePoint - 48 < 10) {
                return codePoint - 22;
            }
            if (codePoint - 65 < 26) {
                return codePoint - 65;
            }
            if (codePoint - 97 < 26) {
                return codePoint - 97;
            }
            return base;
        };
        var digitToBasic = function digitToBasic2(digit, flag) {
            return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        };
        var adapt = function adapt2(delta, numPoints, firstTime) {
            var k = 0;
            delta = firstTime ? floor(delta / damp) : delta >> 1;
            delta += floor(delta / numPoints);
            for(; delta > baseMinusTMin * tMax >> 1; k += base){
                delta = floor(delta / baseMinusTMin);
            }
            return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
        };
        var decode = function decode2(input) {
            var output = [];
            var inputLength = input.length;
            var i = 0;
            var n = initialN;
            var bias = initialBias;
            var basic = input.lastIndexOf(delimiter);
            if (basic < 0) {
                basic = 0;
            }
            for(var j = 0; j < basic; ++j){
                if (input.charCodeAt(j) >= 128) {
                    error$1("not-basic");
                }
                output.push(input.charCodeAt(j));
            }
            for(var index = basic > 0 ? basic + 1 : 0; index < inputLength;){
                var oldi = i;
                for(var w = 1, k = base;; k += base){
                    if (index >= inputLength) {
                        error$1("invalid-input");
                    }
                    var digit = basicToDigit(input.charCodeAt(index++));
                    if (digit >= base || digit > floor((maxInt - i) / w)) {
                        error$1("overflow");
                    }
                    i += digit * w;
                    var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                    if (digit < t) {
                        break;
                    }
                    var baseMinusT = base - t;
                    if (w > floor(maxInt / baseMinusT)) {
                        error$1("overflow");
                    }
                    w *= baseMinusT;
                }
                var out = output.length + 1;
                bias = adapt(i - oldi, out, oldi == 0);
                if (floor(i / out) > maxInt - n) {
                    error$1("overflow");
                }
                n += floor(i / out);
                i %= out;
                output.splice(i++, 0, n);
            }
            return String.fromCodePoint.apply(String, output);
        };
        var encode = function encode2(input) {
            var output = [];
            input = ucs2decode(input);
            var inputLength = input.length;
            var n = initialN;
            var delta = 0;
            var bias = initialBias;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
                for(var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var _currentValue2 = _step.value;
                    if (_currentValue2 < 128) {
                        output.push(stringFromCharCode(_currentValue2));
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            var basicLength = output.length;
            var handledCPCount = basicLength;
            if (basicLength) {
                output.push(delimiter);
            }
            while(handledCPCount < inputLength){
                var m = maxInt;
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = void 0;
                try {
                    for(var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                        var currentValue = _step2.value;
                        if (currentValue >= n && currentValue < m) {
                            m = currentValue;
                        }
                    }
                } catch (err1) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err1;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally{
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
                var handledCPCountPlusOne = handledCPCount + 1;
                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                    error$1("overflow");
                }
                delta += (m - n) * handledCPCountPlusOne;
                n = m;
                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = void 0;
                try {
                    for(var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){
                        var _currentValue = _step3.value;
                        if (_currentValue < n && ++delta > maxInt) {
                            error$1("overflow");
                        }
                        if (_currentValue == n) {
                            var q = delta;
                            for(var k = base;; k += base){
                                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                                if (q < t) {
                                    break;
                                }
                                var qMinusT = q - t;
                                var baseMinusT = base - t;
                                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                                q = floor(qMinusT / baseMinusT);
                            }
                            output.push(stringFromCharCode(digitToBasic(q, 0)));
                            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                            delta = 0;
                            ++handledCPCount;
                        }
                    }
                } catch (err2) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err2;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                        }
                    } finally{
                        if (_didIteratorError3) {
                            throw _iteratorError3;
                        }
                    }
                }
                ++delta;
                ++n;
            }
            return output.join("");
        };
        var toUnicode = function toUnicode2(input) {
            return mapDomain(input, function(string) {
                return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
            });
        };
        var toASCII = function toASCII2(input) {
            return mapDomain(input, function(string) {
                return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
            });
        };
        var punycode = {
            version: "2.1.0",
            ucs2: {
                decode: ucs2decode,
                encode: ucs2encode
            },
            decode,
            encode,
            toASCII,
            toUnicode
        };
        var SCHEMES2 = {};
        function pctEncChar2(chr) {
            var c = chr.charCodeAt(0);
            var e = void 0;
            if (c < 16) e = "%0" + c.toString(16).toUpperCase();
            else if (c < 128) e = "%" + c.toString(16).toUpperCase();
            else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
            else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
            return e;
        }
        function pctDecChars2(str) {
            var newStr = "";
            var i = 0;
            var il = str.length;
            while(i < il){
                var c = parseInt(str.substr(i + 1, 2), 16);
                if (c < 128) {
                    newStr += String.fromCharCode(c);
                    i += 3;
                } else if (c >= 194 && c < 224) {
                    if (il - i >= 6) {
                        var c2 = parseInt(str.substr(i + 4, 2), 16);
                        newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
                    } else {
                        newStr += str.substr(i, 6);
                    }
                    i += 6;
                } else if (c >= 224) {
                    if (il - i >= 9) {
                        var _c = parseInt(str.substr(i + 4, 2), 16);
                        var c3 = parseInt(str.substr(i + 7, 2), 16);
                        newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
                    } else {
                        newStr += str.substr(i, 9);
                    }
                    i += 9;
                } else {
                    newStr += str.substr(i, 3);
                    i += 3;
                }
            }
            return newStr;
        }
        function _normalizeComponentEncoding(components, protocol) {
            function decodeUnreserved2(str) {
                var decStr = pctDecChars2(str);
                return !decStr.match(protocol.UNRESERVED) ? str : decStr;
            }
            if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
            if (components.userinfo !== void 0) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar2).replace(protocol.PCT_ENCODED, toUpperCase);
            if (components.host !== void 0) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar2).replace(protocol.PCT_ENCODED, toUpperCase);
            if (components.path !== void 0) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar2).replace(protocol.PCT_ENCODED, toUpperCase);
            if (components.query !== void 0) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar2).replace(protocol.PCT_ENCODED, toUpperCase);
            if (components.fragment !== void 0) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar2).replace(protocol.PCT_ENCODED, toUpperCase);
            return components;
        }
        function _stripLeadingZeros(str) {
            return str.replace(/^0*(.*)/, "$1") || "0";
        }
        function _normalizeIPv4(host, protocol) {
            var matches = host.match(protocol.IPV4ADDRESS) || [];
            var _matches = slicedToArray(matches, 2), address = _matches[1];
            if (address) {
                return address.split(".").map(_stripLeadingZeros).join(".");
            } else {
                return host;
            }
        }
        function _normalizeIPv6(host, protocol) {
            var matches = host.match(protocol.IPV6ADDRESS) || [];
            var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
            if (address) {
                var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
                var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
                var lastFields = last.split(":").map(_stripLeadingZeros);
                var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
                var fieldCount = isLastFieldIPv4Address ? 7 : 8;
                var lastFieldsStart = lastFields.length - fieldCount;
                var fields = Array(fieldCount);
                for(var x = 0; x < fieldCount; ++x){
                    fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
                }
                if (isLastFieldIPv4Address) {
                    fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
                }
                var allZeroFields = fields.reduce(function(acc, field, index) {
                    if (!field || field === "0") {
                        var lastLongest = acc[acc.length - 1];
                        if (lastLongest && lastLongest.index + lastLongest.length === index) {
                            lastLongest.length++;
                        } else {
                            acc.push({
                                index,
                                length: 1
                            });
                        }
                    }
                    return acc;
                }, []);
                var longestZeroFields = allZeroFields.sort(function(a, b) {
                    return b.length - a.length;
                })[0];
                var newHost = void 0;
                if (longestZeroFields && longestZeroFields.length > 1) {
                    var newFirst = fields.slice(0, longestZeroFields.index);
                    var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
                    newHost = newFirst.join(":") + "::" + newLast.join(":");
                } else {
                    newHost = fields.join(":");
                }
                if (zone) {
                    newHost += "%" + zone;
                }
                return newHost;
            } else {
                return host;
            }
        }
        var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
        var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
        function parse2(uriString) {
            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var components = {};
            var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
            if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
            var matches = uriString.match(URI_PARSE);
            if (matches) {
                if (NO_MATCH_IS_UNDEFINED) {
                    components.scheme = matches[1];
                    components.userinfo = matches[3];
                    components.host = matches[4];
                    components.port = parseInt(matches[5], 10);
                    components.path = matches[6] || "";
                    components.query = matches[7];
                    components.fragment = matches[8];
                    if (isNaN(components.port)) {
                        components.port = matches[5];
                    }
                } else {
                    components.scheme = matches[1] || void 0;
                    components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
                    components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
                    components.port = parseInt(matches[5], 10);
                    components.path = matches[6] || "";
                    components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
                    components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
                    if (isNaN(components.port)) {
                        components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
                    }
                }
                if (components.host) {
                    components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
                }
                if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
                    components.reference = "same-document";
                } else if (components.scheme === void 0) {
                    components.reference = "relative";
                } else if (components.fragment === void 0) {
                    components.reference = "absolute";
                } else {
                    components.reference = "uri";
                }
                if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
                    components.error = components.error || "URI is not a " + options.reference + " reference.";
                }
                var schemeHandler = SCHEMES2[(options.scheme || components.scheme || "").toLowerCase()];
                if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
                    if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                        try {
                            components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars2).toLowerCase());
                        } catch (e) {
                            components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                        }
                    }
                    _normalizeComponentEncoding(components, URI_PROTOCOL);
                } else {
                    _normalizeComponentEncoding(components, protocol);
                }
                if (schemeHandler && schemeHandler.parse) {
                    schemeHandler.parse(components, options);
                }
            } else {
                components.error = components.error || "URI can not be parsed.";
            }
            return components;
        }
        function _recomposeAuthority(components, options) {
            var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
            var uriTokens = [];
            if (components.userinfo !== void 0) {
                uriTokens.push(components.userinfo);
                uriTokens.push("@");
            }
            if (components.host !== void 0) {
                uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
                    return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
                }));
            }
            if (typeof components.port === "number" || typeof components.port === "string") {
                uriTokens.push(":");
                uriTokens.push(String(components.port));
            }
            return uriTokens.length ? uriTokens.join("") : void 0;
        }
        var RDS1 = /^\.\.?\//;
        var RDS2 = /^\/\.(\/|$)/;
        var RDS3 = /^\/\.\.(\/|$)/;
        var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
        function removeDotSegments2(input) {
            var output = [];
            while(input.length){
                if (input.match(RDS1)) {
                    input = input.replace(RDS1, "");
                } else if (input.match(RDS2)) {
                    input = input.replace(RDS2, "/");
                } else if (input.match(RDS3)) {
                    input = input.replace(RDS3, "/");
                    output.pop();
                } else if (input === "." || input === "..") {
                    input = "";
                } else {
                    var im = input.match(RDS5);
                    if (im) {
                        var s = im[0];
                        input = input.slice(s.length);
                        output.push(s);
                    } else {
                        throw new Error("Unexpected dot segment condition");
                    }
                }
            }
            return output.join("");
        }
        function serialize2(components) {
            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
            var uriTokens = [];
            var schemeHandler = SCHEMES2[(options.scheme || components.scheme || "").toLowerCase()];
            if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
            if (components.host) {
                if (protocol.IPV6ADDRESS.test(components.host)) ;
                else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
                    try {
                        components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars2).toLowerCase()) : punycode.toUnicode(components.host);
                    } catch (e) {
                        components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                    }
                }
            }
            _normalizeComponentEncoding(components, protocol);
            if (options.reference !== "suffix" && components.scheme) {
                uriTokens.push(components.scheme);
                uriTokens.push(":");
            }
            var authority = _recomposeAuthority(components, options);
            if (authority !== void 0) {
                if (options.reference !== "suffix") {
                    uriTokens.push("//");
                }
                uriTokens.push(authority);
                if (components.path && components.path.charAt(0) !== "/") {
                    uriTokens.push("/");
                }
            }
            if (components.path !== void 0) {
                var s = components.path;
                if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
                    s = removeDotSegments2(s);
                }
                if (authority === void 0) {
                    s = s.replace(/^\/\//, "/%2F");
                }
                uriTokens.push(s);
            }
            if (components.query !== void 0) {
                uriTokens.push("?");
                uriTokens.push(components.query);
            }
            if (components.fragment !== void 0) {
                uriTokens.push("#");
                uriTokens.push(components.fragment);
            }
            return uriTokens.join("");
        }
        function resolveComponents2(base2, relative) {
            var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            var skipNormalization = arguments[3];
            var target = {};
            if (!skipNormalization) {
                base2 = parse2(serialize2(base2, options), options);
                relative = parse2(serialize2(relative, options), options);
            }
            options = options || {};
            if (!options.tolerant && relative.scheme) {
                target.scheme = relative.scheme;
                target.userinfo = relative.userinfo;
                target.host = relative.host;
                target.port = relative.port;
                target.path = removeDotSegments2(relative.path || "");
                target.query = relative.query;
            } else {
                if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
                    target.userinfo = relative.userinfo;
                    target.host = relative.host;
                    target.port = relative.port;
                    target.path = removeDotSegments2(relative.path || "");
                    target.query = relative.query;
                } else {
                    if (!relative.path) {
                        target.path = base2.path;
                        if (relative.query !== void 0) {
                            target.query = relative.query;
                        } else {
                            target.query = base2.query;
                        }
                    } else {
                        if (relative.path.charAt(0) === "/") {
                            target.path = removeDotSegments2(relative.path);
                        } else {
                            if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                                target.path = "/" + relative.path;
                            } else if (!base2.path) {
                                target.path = relative.path;
                            } else {
                                target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
                            }
                            target.path = removeDotSegments2(target.path);
                        }
                        target.query = relative.query;
                    }
                    target.userinfo = base2.userinfo;
                    target.host = base2.host;
                    target.port = base2.port;
                }
                target.scheme = base2.scheme;
            }
            target.fragment = relative.fragment;
            return target;
        }
        function resolve2(baseURI, relativeURI, options) {
            var schemelessOptions = assign({
                scheme: "null"
            }, options);
            return serialize2(resolveComponents2(parse2(baseURI, schemelessOptions), parse2(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
        }
        function normalize2(uri, options) {
            if (typeof uri === "string") {
                uri = serialize2(parse2(uri, options), options);
            } else if (typeOf(uri) === "object") {
                uri = parse2(serialize2(uri, options), options);
            }
            return uri;
        }
        function equal2(uriA, uriB, options) {
            if (typeof uriA === "string") {
                uriA = serialize2(parse2(uriA, options), options);
            } else if (typeOf(uriA) === "object") {
                uriA = serialize2(uriA, options);
            }
            if (typeof uriB === "string") {
                uriB = serialize2(parse2(uriB, options), options);
            } else if (typeOf(uriB) === "object") {
                uriB = serialize2(uriB, options);
            }
            return uriA === uriB;
        }
        function escapeComponent2(str, options) {
            return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar2);
        }
        function unescapeComponent2(str, options) {
            return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars2);
        }
        var handler = {
            scheme: "http",
            domainHost: true,
            parse: function parse3(components, options) {
                if (!components.host) {
                    components.error = components.error || "HTTP URIs must have a host.";
                }
                return components;
            },
            serialize: function serialize3(components, options) {
                var secure = String(components.scheme).toLowerCase() === "https";
                if (components.port === (secure ? 443 : 80) || components.port === "") {
                    components.port = void 0;
                }
                if (!components.path) {
                    components.path = "/";
                }
                return components;
            }
        };
        var handler$1 = {
            scheme: "https",
            domainHost: handler.domainHost,
            parse: handler.parse,
            serialize: handler.serialize
        };
        function isSecure(wsComponents) {
            return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
        }
        var handler$2 = {
            scheme: "ws",
            domainHost: true,
            parse: function parse3(components, options) {
                var wsComponents = components;
                wsComponents.secure = isSecure(wsComponents);
                wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
                wsComponents.path = void 0;
                wsComponents.query = void 0;
                return wsComponents;
            },
            serialize: function serialize3(wsComponents, options) {
                if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
                    wsComponents.port = void 0;
                }
                if (typeof wsComponents.secure === "boolean") {
                    wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
                    wsComponents.secure = void 0;
                }
                if (wsComponents.resourceName) {
                    var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
                    wsComponents.path = path && path !== "/" ? path : void 0;
                    wsComponents.query = query;
                    wsComponents.resourceName = void 0;
                }
                wsComponents.fragment = void 0;
                return wsComponents;
            }
        };
        var handler$3 = {
            scheme: "wss",
            domainHost: handler$2.domainHost,
            parse: handler$2.parse,
            serialize: handler$2.serialize
        };
        var O = {};
        var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]";
        var HEXDIG$$ = "[0-9A-Fa-f]";
        var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
        var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
        var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
        var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
        var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
        var UNRESERVED = new RegExp(UNRESERVED$$, "g");
        var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
        var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
        var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
        var NOT_HFVALUE = NOT_HFNAME;
        function decodeUnreserved(str) {
            var decStr = pctDecChars2(str);
            return !decStr.match(UNRESERVED) ? str : decStr;
        }
        var handler$4 = {
            scheme: "mailto",
            parse: function parse$$1(components, options) {
                var mailtoComponents = components;
                var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
                mailtoComponents.path = void 0;
                if (mailtoComponents.query) {
                    var unknownHeaders = false;
                    var headers = {};
                    var hfields = mailtoComponents.query.split("&");
                    for(var x = 0, xl = hfields.length; x < xl; ++x){
                        var hfield = hfields[x].split("=");
                        switch(hfield[0]){
                            case "to":
                                var toAddrs = hfield[1].split(",");
                                for(var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x){
                                    to.push(toAddrs[_x]);
                                }
                                break;
                            case "subject":
                                mailtoComponents.subject = unescapeComponent2(hfield[1], options);
                                break;
                            case "body":
                                mailtoComponents.body = unescapeComponent2(hfield[1], options);
                                break;
                            default:
                                unknownHeaders = true;
                                headers[unescapeComponent2(hfield[0], options)] = unescapeComponent2(hfield[1], options);
                                break;
                        }
                    }
                    if (unknownHeaders) mailtoComponents.headers = headers;
                }
                mailtoComponents.query = void 0;
                for(var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2){
                    var addr = to[_x2].split("@");
                    addr[0] = unescapeComponent2(addr[0]);
                    if (!options.unicodeSupport) {
                        try {
                            addr[1] = punycode.toASCII(unescapeComponent2(addr[1], options).toLowerCase());
                        } catch (e) {
                            mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                        }
                    } else {
                        addr[1] = unescapeComponent2(addr[1], options).toLowerCase();
                    }
                    to[_x2] = addr.join("@");
                }
                return mailtoComponents;
            },
            serialize: function serialize$$1(mailtoComponents, options) {
                var components = mailtoComponents;
                var to = toArray(mailtoComponents.to);
                if (to) {
                    for(var x = 0, xl = to.length; x < xl; ++x){
                        var toAddr = String(to[x]);
                        var atIdx = toAddr.lastIndexOf("@");
                        var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar2);
                        var domain = toAddr.slice(atIdx + 1);
                        try {
                            domain = !options.iri ? punycode.toASCII(unescapeComponent2(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                        } catch (e) {
                            components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                        }
                        to[x] = localPart + "@" + domain;
                    }
                    components.path = to.join(",");
                }
                var headers = mailtoComponents.headers = mailtoComponents.headers || {};
                if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
                if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
                var fields = [];
                for(var name in headers){
                    if (headers[name] !== O[name]) {
                        fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar2) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar2));
                    }
                }
                if (fields.length) {
                    components.query = fields.join("&");
                }
                return components;
            }
        };
        var URN_PARSE = /^([^\:]+)\:(.*)/;
        var handler$5 = {
            scheme: "urn",
            parse: function parse$$1(components, options) {
                var matches = components.path && components.path.match(URN_PARSE);
                var urnComponents = components;
                if (matches) {
                    var scheme = options.scheme || urnComponents.scheme || "urn";
                    var nid = matches[1].toLowerCase();
                    var nss = matches[2];
                    var urnScheme = scheme + ":" + (options.nid || nid);
                    var schemeHandler = SCHEMES2[urnScheme];
                    urnComponents.nid = nid;
                    urnComponents.nss = nss;
                    urnComponents.path = void 0;
                    if (schemeHandler) {
                        urnComponents = schemeHandler.parse(urnComponents, options);
                    }
                } else {
                    urnComponents.error = urnComponents.error || "URN can not be parsed.";
                }
                return urnComponents;
            },
            serialize: function serialize$$1(urnComponents, options) {
                var scheme = options.scheme || urnComponents.scheme || "urn";
                var nid = urnComponents.nid;
                var urnScheme = scheme + ":" + (options.nid || nid);
                var schemeHandler = SCHEMES2[urnScheme];
                if (schemeHandler) {
                    urnComponents = schemeHandler.serialize(urnComponents, options);
                }
                var uriComponents = urnComponents;
                var nss = urnComponents.nss;
                uriComponents.path = (nid || options.nid) + ":" + nss;
                return uriComponents;
            }
        };
        var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
        var handler$6 = {
            scheme: "urn:uuid",
            parse: function parse3(urnComponents, options) {
                var uuidComponents = urnComponents;
                uuidComponents.uuid = uuidComponents.nss;
                uuidComponents.nss = void 0;
                if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
                    uuidComponents.error = uuidComponents.error || "UUID is not valid.";
                }
                return uuidComponents;
            },
            serialize: function serialize3(uuidComponents, options) {
                var urnComponents = uuidComponents;
                urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
                return urnComponents;
            }
        };
        SCHEMES2[handler.scheme] = handler;
        SCHEMES2[handler$1.scheme] = handler$1;
        SCHEMES2[handler$2.scheme] = handler$2;
        SCHEMES2[handler$3.scheme] = handler$3;
        SCHEMES2[handler$4.scheme] = handler$4;
        SCHEMES2[handler$5.scheme] = handler$5;
        SCHEMES2[handler$6.scheme] = handler$6;
        exports2.SCHEMES = SCHEMES2;
        exports2.pctEncChar = pctEncChar2;
        exports2.pctDecChars = pctDecChars2;
        exports2.parse = parse2;
        exports2.removeDotSegments = removeDotSegments2;
        exports2.serialize = serialize2;
        exports2.resolveComponents = resolveComponents2;
        exports2.resolve = resolve2;
        exports2.normalize = normalize2;
        exports2.equal = equal2;
        exports2.escapeComponent = escapeComponent2;
        exports2.unescapeComponent = unescapeComponent2;
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
    });
});
var __pika_web_default_export_for_treeshaking__ = getDefaultExportFromCjs(uri_all);
uri_all.SCHEMES;
uri_all.equal;
uri_all.escapeComponent;
uri_all.normalize;
uri_all.parse;
uri_all.pctDecChars;
uri_all.pctEncChar;
uri_all.removeDotSegments;
uri_all.resolve;
uri_all.resolveComponents;
uri_all.serialize;
uri_all.unescapeComponent;
function getDefaultExportFromCjs1(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function createCommonjsModule2(fn, basedir, module) {
    return module = {
        path: basedir,
        exports: {},
        require: function(path, base) {
            return commonjsRequire2(path, base === void 0 || base === null ? module.path : base);
        }
    }, fn(module, module.exports), module.exports;
}
function commonjsRequire2() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var code = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
    class _CodeOrName {
    }
    exports._CodeOrName = _CodeOrName;
    exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    class Name2 extends _CodeOrName {
        constructor(s){
            super();
            if (!exports.IDENTIFIER.test(s)) throw new Error("CodeGen: name must be a valid identifier");
            this.str = s;
        }
        toString() {
            return this.str;
        }
        emptyStr() {
            return false;
        }
        get names() {
            return {
                [this.str]: 1
            };
        }
    }
    exports.Name = Name2;
    class _Code extends _CodeOrName {
        constructor(code2){
            super();
            this._items = typeof code2 === "string" ? [
                code2
            ] : code2;
        }
        toString() {
            return this.str;
        }
        emptyStr() {
            if (this._items.length > 1) return false;
            const item = this._items[0];
            return item === "" || item === '""';
        }
        get str() {
            var _a;
            return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c)=>`${s}${c}`, "");
        }
        get names() {
            var _a;
            return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c)=>{
                if (c instanceof Name2) names[c.str] = (names[c.str] || 0) + 1;
                return names;
            }, {});
        }
    }
    exports._Code = _Code;
    exports.nil = new _Code("");
    function _2(strs, ...args) {
        const code2 = [
            strs[0]
        ];
        let i = 0;
        while(i < args.length){
            addCodeArg(code2, args[i]);
            code2.push(strs[++i]);
        }
        return new _Code(code2);
    }
    exports._ = _2;
    const plus = new _Code("+");
    function str2(strs, ...args) {
        const expr = [
            safeStringify(strs[0])
        ];
        let i = 0;
        while(i < args.length){
            expr.push(plus);
            addCodeArg(expr, args[i]);
            expr.push(plus, safeStringify(strs[++i]));
        }
        optimize(expr);
        return new _Code(expr);
    }
    exports.str = str2;
    function addCodeArg(code2, arg) {
        if (arg instanceof _Code) code2.push(...arg._items);
        else if (arg instanceof Name2) code2.push(arg);
        else code2.push(interpolate(arg));
    }
    exports.addCodeArg = addCodeArg;
    function optimize(expr) {
        let i = 1;
        while(i < expr.length - 1){
            if (expr[i] === plus) {
                const res = mergeExprItems(expr[i - 1], expr[i + 1]);
                if (res !== void 0) {
                    expr.splice(i - 1, 3, res);
                    continue;
                }
                expr[i++] = "+";
            }
            i++;
        }
    }
    function mergeExprItems(a, b) {
        if (b === '""') return a;
        if (a === '""') return b;
        if (typeof a == "string") {
            if (b instanceof Name2 || a[a.length - 1] !== '"') return;
            if (typeof b != "string") return `${a.slice(0, -1)}${b}"`;
            if (b[0] === '"') return a.slice(0, -1) + b.slice(1);
            return;
        }
        if (typeof b == "string" && b[0] === '"' && !(a instanceof Name2)) return `"${a}${b.slice(1)}`;
        return;
    }
    function strConcat(c1, c2) {
        return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str2`${c1}${c2}`;
    }
    exports.strConcat = strConcat;
    function interpolate(x) {
        return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify2(x) {
        return new _Code(safeStringify(x));
    }
    exports.stringify = stringify2;
    function safeStringify(x) {
        return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports.safeStringify = safeStringify;
    function getProperty(key) {
        return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _2`[${key}]`;
    }
    exports.getProperty = getProperty;
    function getEsmExportName(key) {
        if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
            return new _Code(`${key}`);
        }
        throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
        return new _Code(rx.toString());
    }
    exports.regexpCode = regexpCode;
});
var scope = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
    class ValueError extends Error {
        constructor(name){
            super(`CodeGen: "code" for ${name} not defined`);
            this.value = name.value;
        }
    }
    var UsedValueState;
    (function(UsedValueState2) {
        UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
        UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
    exports.varKinds = {
        const: new code.Name("const"),
        let: new code.Name("let"),
        var: new code.Name("var")
    };
    class Scope {
        constructor({ prefixes , parent  } = {}){
            this._names = {};
            this._prefixes = prefixes;
            this._parent = parent;
        }
        toName(nameOrPrefix) {
            return nameOrPrefix instanceof code.Name ? nameOrPrefix : this.name(nameOrPrefix);
        }
        name(prefix) {
            return new code.Name(this._newName(prefix));
        }
        _newName(prefix) {
            const ng = this._names[prefix] || this._nameGroup(prefix);
            return `${prefix}${ng.index++}`;
        }
        _nameGroup(prefix) {
            var _a, _b;
            if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
                throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
            }
            return this._names[prefix] = {
                prefix,
                index: 0
            };
        }
    }
    exports.Scope = Scope;
    class ValueScopeName extends code.Name {
        constructor(prefix, nameStr){
            super(nameStr);
            this.prefix = prefix;
        }
        setValue(value, { property , itemIndex  }) {
            this.value = value;
            this.scopePath = code._`.${new code.Name(property)}[${itemIndex}]`;
        }
    }
    exports.ValueScopeName = ValueScopeName;
    const line = code._`\n`;
    class ValueScope extends Scope {
        constructor(opts){
            super(opts);
            this._values = {};
            this._scope = opts.scope;
            this.opts = {
                ...opts,
                _n: opts.lines ? line : code.nil
            };
        }
        get() {
            return this._scope;
        }
        name(prefix) {
            return new ValueScopeName(prefix, this._newName(prefix));
        }
        value(nameOrPrefix, value) {
            var _a;
            if (value.ref === void 0) throw new Error("CodeGen: ref must be passed in value");
            const name = this.toName(nameOrPrefix);
            const { prefix  } = name;
            const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
            let vs = this._values[prefix];
            if (vs) {
                const _name = vs.get(valueKey);
                if (_name) return _name;
            } else {
                vs = this._values[prefix] = new Map();
            }
            vs.set(valueKey, name);
            const s = this._scope[prefix] || (this._scope[prefix] = []);
            const itemIndex = s.length;
            s[itemIndex] = value.ref;
            name.setValue(value, {
                property: prefix,
                itemIndex
            });
            return name;
        }
        getValue(prefix, keyOrRef) {
            const vs = this._values[prefix];
            if (!vs) return;
            return vs.get(keyOrRef);
        }
        scopeRefs(scopeName, values = this._values) {
            return this._reduceValues(values, (name)=>{
                if (name.scopePath === void 0) throw new Error(`CodeGen: name "${name}" has no value`);
                return code._`${scopeName}${name.scopePath}`;
            });
        }
        scopeCode(values = this._values, usedValues, getCode) {
            return this._reduceValues(values, (name)=>{
                if (name.value === void 0) throw new Error(`CodeGen: name "${name}" has no value`);
                return name.value.code;
            }, usedValues, getCode);
        }
        _reduceValues(values, valueCode, usedValues = {}, getCode) {
            let code$12 = code.nil;
            for(const prefix in values){
                const vs = values[prefix];
                if (!vs) continue;
                const nameSet = usedValues[prefix] = usedValues[prefix] || new Map();
                vs.forEach((name)=>{
                    if (nameSet.has(name)) return;
                    nameSet.set(name, UsedValueState.Started);
                    let c = valueCode(name);
                    if (c) {
                        const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
                        code$12 = code._`${code$12}${def} ${name} = ${c};${this.opts._n}`;
                    } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
                        code$12 = code._`${code$12}${c}${this.opts._n}`;
                    } else {
                        throw new ValueError(name);
                    }
                    nameSet.set(name, UsedValueState.Completed);
                });
            }
            return code$12;
        }
    }
    exports.ValueScope = ValueScope;
});
var codegen = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
    var code_2 = code;
    Object.defineProperty(exports, "_", {
        enumerable: true,
        get: function() {
            return code_2._;
        }
    });
    Object.defineProperty(exports, "str", {
        enumerable: true,
        get: function() {
            return code_2.str;
        }
    });
    Object.defineProperty(exports, "strConcat", {
        enumerable: true,
        get: function() {
            return code_2.strConcat;
        }
    });
    Object.defineProperty(exports, "nil", {
        enumerable: true,
        get: function() {
            return code_2.nil;
        }
    });
    Object.defineProperty(exports, "getProperty", {
        enumerable: true,
        get: function() {
            return code_2.getProperty;
        }
    });
    Object.defineProperty(exports, "stringify", {
        enumerable: true,
        get: function() {
            return code_2.stringify;
        }
    });
    Object.defineProperty(exports, "regexpCode", {
        enumerable: true,
        get: function() {
            return code_2.regexpCode;
        }
    });
    Object.defineProperty(exports, "Name", {
        enumerable: true,
        get: function() {
            return code_2.Name;
        }
    });
    var scope_2 = scope;
    Object.defineProperty(exports, "Scope", {
        enumerable: true,
        get: function() {
            return scope_2.Scope;
        }
    });
    Object.defineProperty(exports, "ValueScope", {
        enumerable: true,
        get: function() {
            return scope_2.ValueScope;
        }
    });
    Object.defineProperty(exports, "ValueScopeName", {
        enumerable: true,
        get: function() {
            return scope_2.ValueScopeName;
        }
    });
    Object.defineProperty(exports, "varKinds", {
        enumerable: true,
        get: function() {
            return scope_2.varKinds;
        }
    });
    exports.operators = {
        GT: new code._Code(">"),
        GTE: new code._Code(">="),
        LT: new code._Code("<"),
        LTE: new code._Code("<="),
        EQ: new code._Code("==="),
        NEQ: new code._Code("!=="),
        NOT: new code._Code("!"),
        OR: new code._Code("||"),
        AND: new code._Code("&&"),
        ADD: new code._Code("+")
    };
    class Node {
        optimizeNodes() {
            return this;
        }
        optimizeNames(_names, _constants) {
            return this;
        }
    }
    class Def extends Node {
        constructor(varKind, name, rhs){
            super();
            this.varKind = varKind;
            this.name = name;
            this.rhs = rhs;
        }
        render({ es5 , _n  }) {
            const varKind = es5 ? scope.varKinds.var : this.varKind;
            const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
            return `${varKind} ${this.name}${rhs};` + _n;
        }
        optimizeNames(names, constants) {
            if (!names[this.name.str]) return;
            if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants);
            return this;
        }
        get names() {
            return this.rhs instanceof code._CodeOrName ? this.rhs.names : {};
        }
    }
    class Assign extends Node {
        constructor(lhs, rhs, sideEffects){
            super();
            this.lhs = lhs;
            this.rhs = rhs;
            this.sideEffects = sideEffects;
        }
        render({ _n  }) {
            return `${this.lhs} = ${this.rhs};` + _n;
        }
        optimizeNames(names, constants) {
            if (this.lhs instanceof code.Name && !names[this.lhs.str] && !this.sideEffects) return;
            this.rhs = optimizeExpr(this.rhs, names, constants);
            return this;
        }
        get names() {
            const names = this.lhs instanceof code.Name ? {} : {
                ...this.lhs.names
            };
            return addExprNames(names, this.rhs);
        }
    }
    class AssignOp extends Assign {
        constructor(lhs, op, rhs, sideEffects){
            super(lhs, rhs, sideEffects);
            this.op = op;
        }
        render({ _n  }) {
            return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
        }
    }
    class Label extends Node {
        constructor(label){
            super();
            this.label = label;
            this.names = {};
        }
        render({ _n  }) {
            return `${this.label}:` + _n;
        }
    }
    class Break extends Node {
        constructor(label){
            super();
            this.label = label;
            this.names = {};
        }
        render({ _n  }) {
            const label = this.label ? ` ${this.label}` : "";
            return `break${label};` + _n;
        }
    }
    class Throw extends Node {
        constructor(error){
            super();
            this.error = error;
        }
        render({ _n  }) {
            return `throw ${this.error};` + _n;
        }
        get names() {
            return this.error.names;
        }
    }
    class AnyCode extends Node {
        constructor(code2){
            super();
            this.code = code2;
        }
        render({ _n  }) {
            return `${this.code};` + _n;
        }
        optimizeNodes() {
            return `${this.code}` ? this : void 0;
        }
        optimizeNames(names, constants) {
            this.code = optimizeExpr(this.code, names, constants);
            return this;
        }
        get names() {
            return this.code instanceof code._CodeOrName ? this.code.names : {};
        }
    }
    class ParentNode extends Node {
        constructor(nodes = []){
            super();
            this.nodes = nodes;
        }
        render(opts) {
            return this.nodes.reduce((code2, n)=>code2 + n.render(opts), "");
        }
        optimizeNodes() {
            const { nodes  } = this;
            let i = nodes.length;
            while(i--){
                const n = nodes[i].optimizeNodes();
                if (Array.isArray(n)) nodes.splice(i, 1, ...n);
                else if (n) nodes[i] = n;
                else nodes.splice(i, 1);
            }
            return nodes.length > 0 ? this : void 0;
        }
        optimizeNames(names, constants) {
            const { nodes  } = this;
            let i = nodes.length;
            while(i--){
                const n = nodes[i];
                if (n.optimizeNames(names, constants)) continue;
                subtractNames(names, n.names);
                nodes.splice(i, 1);
            }
            return nodes.length > 0 ? this : void 0;
        }
        get names() {
            return this.nodes.reduce((names, n)=>addNames(names, n.names), {});
        }
    }
    class BlockNode extends ParentNode {
        render(opts) {
            return "{" + opts._n + super.render(opts) + "}" + opts._n;
        }
    }
    class Root extends ParentNode {
    }
    class Else extends BlockNode {
    }
    Else.kind = "else";
    class If extends BlockNode {
        constructor(condition, nodes){
            super(nodes);
            this.condition = condition;
        }
        render(opts) {
            let code2 = `if(${this.condition})` + super.render(opts);
            if (this.else) code2 += "else " + this.else.render(opts);
            return code2;
        }
        optimizeNodes() {
            super.optimizeNodes();
            const cond = this.condition;
            if (cond === true) return this.nodes;
            let e = this.else;
            if (e) {
                const ns = e.optimizeNodes();
                e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
            }
            if (e) {
                if (cond === false) return e instanceof If ? e : e.nodes;
                if (this.nodes.length) return this;
                return new If(not2(cond), e instanceof If ? [
                    e
                ] : e.nodes);
            }
            if (cond === false || !this.nodes.length) return void 0;
            return this;
        }
        optimizeNames(names, constants) {
            var _a;
            this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
            if (!(super.optimizeNames(names, constants) || this.else)) return;
            this.condition = optimizeExpr(this.condition, names, constants);
            return this;
        }
        get names() {
            const names = super.names;
            addExprNames(names, this.condition);
            if (this.else) addNames(names, this.else.names);
            return names;
        }
    }
    If.kind = "if";
    class For extends BlockNode {
    }
    For.kind = "for";
    class ForLoop extends For {
        constructor(iteration){
            super();
            this.iteration = iteration;
        }
        render(opts) {
            return `for(${this.iteration})` + super.render(opts);
        }
        optimizeNames(names, constants) {
            if (!super.optimizeNames(names, constants)) return;
            this.iteration = optimizeExpr(this.iteration, names, constants);
            return this;
        }
        get names() {
            return addNames(super.names, this.iteration.names);
        }
    }
    class ForRange extends For {
        constructor(varKind, name, from, to){
            super();
            this.varKind = varKind;
            this.name = name;
            this.from = from;
            this.to = to;
        }
        render(opts) {
            const varKind = opts.es5 ? scope.varKinds.var : this.varKind;
            const { name , from , to  } = this;
            return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
        }
        get names() {
            const names = addExprNames(super.names, this.from);
            return addExprNames(names, this.to);
        }
    }
    class ForIter extends For {
        constructor(loop, varKind, name, iterable){
            super();
            this.loop = loop;
            this.varKind = varKind;
            this.name = name;
            this.iterable = iterable;
        }
        render(opts) {
            return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
        }
        optimizeNames(names, constants) {
            if (!super.optimizeNames(names, constants)) return;
            this.iterable = optimizeExpr(this.iterable, names, constants);
            return this;
        }
        get names() {
            return addNames(super.names, this.iterable.names);
        }
    }
    class Func extends BlockNode {
        constructor(name, args, async){
            super();
            this.name = name;
            this.args = args;
            this.async = async;
        }
        render(opts) {
            const _async = this.async ? "async " : "";
            return `${_async}function ${this.name}(${this.args})` + super.render(opts);
        }
    }
    Func.kind = "func";
    class Return extends ParentNode {
        render(opts) {
            return "return " + super.render(opts);
        }
    }
    Return.kind = "return";
    class Try extends BlockNode {
        render(opts) {
            let code2 = "try" + super.render(opts);
            if (this.catch) code2 += this.catch.render(opts);
            if (this.finally) code2 += this.finally.render(opts);
            return code2;
        }
        optimizeNodes() {
            var _a, _b;
            super.optimizeNodes();
            (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
            (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
            return this;
        }
        optimizeNames(names, constants) {
            var _a, _b;
            super.optimizeNames(names, constants);
            (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
            (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
            return this;
        }
        get names() {
            const names = super.names;
            if (this.catch) addNames(names, this.catch.names);
            if (this.finally) addNames(names, this.finally.names);
            return names;
        }
    }
    class Catch extends BlockNode {
        constructor(error){
            super();
            this.error = error;
        }
        render(opts) {
            return `catch(${this.error})` + super.render(opts);
        }
    }
    Catch.kind = "catch";
    class Finally extends BlockNode {
        render(opts) {
            return "finally" + super.render(opts);
        }
    }
    Finally.kind = "finally";
    class CodeGen2 {
        constructor(extScope, opts = {}){
            this._values = {};
            this._blockStarts = [];
            this._constants = {};
            this.opts = {
                ...opts,
                _n: opts.lines ? "\n" : ""
            };
            this._extScope = extScope;
            this._scope = new scope.Scope({
                parent: extScope
            });
            this._nodes = [
                new Root()
            ];
        }
        toString() {
            return this._root.render(this.opts);
        }
        name(prefix) {
            return this._scope.name(prefix);
        }
        scopeName(prefix) {
            return this._extScope.name(prefix);
        }
        scopeValue(prefixOrName, value) {
            const name = this._extScope.value(prefixOrName, value);
            const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
            vs.add(name);
            return name;
        }
        getScopeValue(prefix, keyOrRef) {
            return this._extScope.getValue(prefix, keyOrRef);
        }
        scopeRefs(scopeName) {
            return this._extScope.scopeRefs(scopeName, this._values);
        }
        scopeCode() {
            return this._extScope.scopeCode(this._values);
        }
        _def(varKind, nameOrPrefix, rhs, constant) {
            const name = this._scope.toName(nameOrPrefix);
            if (rhs !== void 0 && constant) this._constants[name.str] = rhs;
            this._leafNode(new Def(varKind, name, rhs));
            return name;
        }
        const(nameOrPrefix, rhs, _constant) {
            return this._def(scope.varKinds.const, nameOrPrefix, rhs, _constant);
        }
        let(nameOrPrefix, rhs, _constant) {
            return this._def(scope.varKinds.let, nameOrPrefix, rhs, _constant);
        }
        var(nameOrPrefix, rhs, _constant) {
            return this._def(scope.varKinds.var, nameOrPrefix, rhs, _constant);
        }
        assign(lhs, rhs, sideEffects) {
            return this._leafNode(new Assign(lhs, rhs, sideEffects));
        }
        add(lhs, rhs) {
            return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
        }
        code(c) {
            if (typeof c == "function") c();
            else if (c !== code.nil) this._leafNode(new AnyCode(c));
            return this;
        }
        object(...keyValues) {
            const code$12 = [
                "{"
            ];
            for (const [key, value] of keyValues){
                if (code$12.length > 1) code$12.push(",");
                code$12.push(key);
                if (key !== value || this.opts.es5) {
                    code$12.push(":");
                    (0, code.addCodeArg)(code$12, value);
                }
            }
            code$12.push("}");
            return new code._Code(code$12);
        }
        if(condition, thenBody, elseBody) {
            this._blockNode(new If(condition));
            if (thenBody && elseBody) {
                this.code(thenBody).else().code(elseBody).endIf();
            } else if (thenBody) {
                this.code(thenBody).endIf();
            } else if (elseBody) {
                throw new Error('CodeGen: "else" body without "then" body');
            }
            return this;
        }
        elseIf(condition) {
            return this._elseNode(new If(condition));
        }
        else() {
            return this._elseNode(new Else());
        }
        endIf() {
            return this._endBlockNode(If, Else);
        }
        _for(node, forBody) {
            this._blockNode(node);
            if (forBody) this.code(forBody).endFor();
            return this;
        }
        for(iteration, forBody) {
            return this._for(new ForLoop(iteration), forBody);
        }
        forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope.varKinds.var : scope.varKinds.let) {
            const name = this._scope.toName(nameOrPrefix);
            return this._for(new ForRange(varKind, name, from, to), ()=>forBody(name));
        }
        forOf(nameOrPrefix, iterable, forBody, varKind = scope.varKinds.const) {
            const name = this._scope.toName(nameOrPrefix);
            if (this.opts.es5) {
                const arr = iterable instanceof code.Name ? iterable : this.var("_arr", iterable);
                return this.forRange("_i", 0, code._`${arr}.length`, (i)=>{
                    this.var(name, code._`${arr}[${i}]`);
                    forBody(name);
                });
            }
            return this._for(new ForIter("of", varKind, name, iterable), ()=>forBody(name));
        }
        forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope.varKinds.var : scope.varKinds.const) {
            if (this.opts.ownProperties) {
                return this.forOf(nameOrPrefix, code._`Object.keys(${obj})`, forBody);
            }
            const name = this._scope.toName(nameOrPrefix);
            return this._for(new ForIter("in", varKind, name, obj), ()=>forBody(name));
        }
        endFor() {
            return this._endBlockNode(For);
        }
        label(label) {
            return this._leafNode(new Label(label));
        }
        break(label) {
            return this._leafNode(new Break(label));
        }
        return(value) {
            const node = new Return();
            this._blockNode(node);
            this.code(value);
            if (node.nodes.length !== 1) throw new Error('CodeGen: "return" should have one node');
            return this._endBlockNode(Return);
        }
        try(tryBody, catchCode, finallyCode) {
            if (!catchCode && !finallyCode) throw new Error('CodeGen: "try" without "catch" and "finally"');
            const node = new Try();
            this._blockNode(node);
            this.code(tryBody);
            if (catchCode) {
                const error = this.name("e");
                this._currNode = node.catch = new Catch(error);
                catchCode(error);
            }
            if (finallyCode) {
                this._currNode = node.finally = new Finally();
                this.code(finallyCode);
            }
            return this._endBlockNode(Catch, Finally);
        }
        throw(error) {
            return this._leafNode(new Throw(error));
        }
        block(body, nodeCount) {
            this._blockStarts.push(this._nodes.length);
            if (body) this.code(body).endBlock(nodeCount);
            return this;
        }
        endBlock(nodeCount) {
            const len = this._blockStarts.pop();
            if (len === void 0) throw new Error("CodeGen: not in self-balancing block");
            const toClose = this._nodes.length - len;
            if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
                throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
            }
            this._nodes.length = len;
            return this;
        }
        func(name, args = code.nil, async, funcBody) {
            this._blockNode(new Func(name, args, async));
            if (funcBody) this.code(funcBody).endFunc();
            return this;
        }
        endFunc() {
            return this._endBlockNode(Func);
        }
        optimize(n = 1) {
            while(n-- > 0){
                this._root.optimizeNodes();
                this._root.optimizeNames(this._root.names, this._constants);
            }
        }
        _leafNode(node) {
            this._currNode.nodes.push(node);
            return this;
        }
        _blockNode(node) {
            this._currNode.nodes.push(node);
            this._nodes.push(node);
        }
        _endBlockNode(N1, N2) {
            const n = this._currNode;
            if (n instanceof N1 || N2 && n instanceof N2) {
                this._nodes.pop();
                return this;
            }
            throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
        }
        _elseNode(node) {
            const n = this._currNode;
            if (!(n instanceof If)) {
                throw new Error('CodeGen: "else" without "if"');
            }
            this._currNode = n.else = node;
            return this;
        }
        get _root() {
            return this._nodes[0];
        }
        get _currNode() {
            const ns = this._nodes;
            return ns[ns.length - 1];
        }
        set _currNode(node) {
            const ns = this._nodes;
            ns[ns.length - 1] = node;
        }
    }
    exports.CodeGen = CodeGen2;
    function addNames(names, from) {
        for(const n in from)names[n] = (names[n] || 0) + (from[n] || 0);
        return names;
    }
    function addExprNames(names, from) {
        return from instanceof code._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
        if (expr instanceof code.Name) return replaceName(expr);
        if (!canOptimize(expr)) return expr;
        return new code._Code(expr._items.reduce((items2, c)=>{
            if (c instanceof code.Name) c = replaceName(c);
            if (c instanceof code._Code) items2.push(...c._items);
            else items2.push(c);
            return items2;
        }, []));
        function replaceName(n) {
            const c = constants[n.str];
            if (c === void 0 || names[n.str] !== 1) return n;
            delete names[n.str];
            return c;
        }
        function canOptimize(e) {
            return e instanceof code._Code && e._items.some((c)=>c instanceof code.Name && names[c.str] === 1 && constants[c.str] !== void 0);
        }
    }
    function subtractNames(names, from) {
        for(const n in from)names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not2(x) {
        return typeof x == "boolean" || typeof x == "number" || x === null ? !x : code._`!${par(x)}`;
    }
    exports.not = not2;
    const andCode = mappend(exports.operators.AND);
    function and(...args) {
        return args.reduce(andCode);
    }
    exports.and = and;
    const orCode = mappend(exports.operators.OR);
    function or(...args) {
        return args.reduce(orCode);
    }
    exports.or = or;
    function mappend(op) {
        return (x, y)=>x === code.nil ? y : y === code.nil ? x : code._`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
        return x instanceof code.Name ? x : code._`(${x})`;
    }
});
var util = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
    function toHash(arr) {
        const hash = {};
        for (const item of arr)hash[item] = true;
        return hash;
    }
    exports.toHash = toHash;
    function alwaysValidSchema(it, schema) {
        if (typeof schema == "boolean") return schema;
        if (Object.keys(schema).length === 0) return true;
        checkUnknownRules(it, schema);
        return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
        const { opts , self: self1  } = it;
        if (!opts.strictSchema) return;
        if (typeof schema === "boolean") return;
        const rules2 = self1.RULES.keywords;
        for(const key in schema){
            if (!rules2[key]) checkStrictMode(it, `unknown keyword: "${key}"`);
        }
    }
    exports.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules2) {
        if (typeof schema == "boolean") return !schema;
        for(const key in schema)if (rules2[key]) return true;
        return false;
    }
    exports.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
        if (typeof schema == "boolean") return !schema;
        for(const key in schema)if (key !== "$ref" && RULES.all[key]) return true;
        return false;
    }
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef , schemaPath  }, schema, keyword2, $data) {
        if (!$data) {
            if (typeof schema == "number" || typeof schema == "boolean") return schema;
            if (typeof schema == "string") return codegen._`${schema}`;
        }
        return codegen._`${topSchemaRef}${schemaPath}${(0, codegen.getProperty)(keyword2)}`;
    }
    exports.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str2) {
        return unescapeJsonPointer(decodeURIComponent(str2));
    }
    exports.unescapeFragment = unescapeFragment;
    function escapeFragment(str2) {
        return encodeURIComponent(escapeJsonPointer(str2));
    }
    exports.escapeFragment = escapeFragment;
    function escapeJsonPointer(str2) {
        if (typeof str2 == "number") return `${str2}`;
        return str2.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str2) {
        return str2.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
        if (Array.isArray(xs)) {
            for (const x of xs)f(x);
        } else {
            f(xs);
        }
    }
    exports.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames , mergeToName , mergeValues , resultToName  }) {
        return (gen, from, to, toName)=>{
            const res = to === void 0 ? from : to instanceof codegen.Name ? (from instanceof codegen.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
            return toName === codegen.Name && !(res instanceof codegen.Name) ? resultToName(gen, res) : res;
        };
    }
    exports.mergeEvaluated = {
        props: makeMergeEvaluated({
            mergeNames: (gen, from, to)=>gen.if(codegen._`${to} !== true && ${from} !== undefined`, ()=>{
                    gen.if(codegen._`${from} === true`, ()=>gen.assign(to, true), ()=>gen.assign(to, codegen._`${to} || {}`).code(codegen._`Object.assign(${to}, ${from})`));
                }),
            mergeToName: (gen, from, to)=>gen.if(codegen._`${to} !== true`, ()=>{
                    if (from === true) {
                        gen.assign(to, true);
                    } else {
                        gen.assign(to, codegen._`${to} || {}`);
                        setEvaluated(gen, to, from);
                    }
                }),
            mergeValues: (from, to)=>from === true ? true : {
                    ...from,
                    ...to
                },
            resultToName: evaluatedPropsToName
        }),
        items: makeMergeEvaluated({
            mergeNames: (gen, from, to)=>gen.if(codegen._`${to} !== true && ${from} !== undefined`, ()=>gen.assign(to, codegen._`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
            mergeToName: (gen, from, to)=>gen.if(codegen._`${to} !== true`, ()=>gen.assign(to, from === true ? true : codegen._`${to} > ${from} ? ${to} : ${from}`)),
            mergeValues: (from, to)=>from === true ? true : Math.max(from, to),
            resultToName: (gen, items2)=>gen.var("items", items2)
        })
    };
    function evaluatedPropsToName(gen, ps) {
        if (ps === true) return gen.var("props", true);
        const props = gen.var("props", codegen._`{}`);
        if (ps !== void 0) setEvaluated(gen, props, ps);
        return props;
    }
    exports.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
        Object.keys(ps).forEach((p)=>gen.assign(codegen._`${props}${(0, codegen.getProperty)(p)}`, true));
    }
    exports.setEvaluated = setEvaluated;
    const snippets = {};
    function useFunc(gen, f) {
        return gen.scopeValue("func", {
            ref: f,
            code: snippets[f.code] || (snippets[f.code] = new code._Code(f.code))
        });
    }
    exports.useFunc = useFunc;
    var Type;
    (function(Type2) {
        Type2[Type2["Num"] = 0] = "Num";
        Type2[Type2["Str"] = 1] = "Str";
    })(Type = exports.Type || (exports.Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
        if (dataProp instanceof codegen.Name) {
            const isNumber = dataPropType === Type.Num;
            return jsPropertySyntax ? isNumber ? codegen._`"[" + ${dataProp} + "]"` : codegen._`"['" + ${dataProp} + "']"` : isNumber ? codegen._`"/" + ${dataProp}` : codegen._`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
        }
        return jsPropertySyntax ? (0, codegen.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
        if (!mode) return;
        msg = `strict mode: ${msg}`;
        if (mode === true) throw new Error(msg);
        it.self.logger.warn(msg);
    }
    exports.checkStrictMode = checkStrictMode;
});
var names_1 = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const names = {
        data: new codegen.Name("data"),
        valCxt: new codegen.Name("valCxt"),
        instancePath: new codegen.Name("instancePath"),
        parentData: new codegen.Name("parentData"),
        parentDataProperty: new codegen.Name("parentDataProperty"),
        rootData: new codegen.Name("rootData"),
        dynamicAnchors: new codegen.Name("dynamicAnchors"),
        vErrors: new codegen.Name("vErrors"),
        errors: new codegen.Name("errors"),
        this: new codegen.Name("this"),
        self: new codegen.Name("self"),
        scope: new codegen.Name("scope"),
        json: new codegen.Name("json"),
        jsonPos: new codegen.Name("jsonPos"),
        jsonLen: new codegen.Name("jsonLen"),
        jsonPart: new codegen.Name("jsonPart")
    };
    exports.default = names;
});
var errors = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
    exports.keywordError = {
        message: ({ keyword: keyword2  })=>codegen.str`must pass "${keyword2}" keyword validation`
    };
    exports.keyword$DataError = {
        message: ({ keyword: keyword2 , schemaType  })=>schemaType ? codegen.str`"${keyword2}" keyword must be ${schemaType} ($data)` : codegen.str`"${keyword2}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
        const { it  } = cxt;
        const { gen , compositeRule , allErrors  } = it;
        const errObj = errorObjectCode(cxt, error, errorPaths);
        if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
            addError(gen, errObj);
        } else {
            returnErrors(it, codegen._`[${errObj}]`);
        }
    }
    exports.reportError = reportError;
    function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
        const { it  } = cxt;
        const { gen , compositeRule , allErrors  } = it;
        const errObj = errorObjectCode(cxt, error, errorPaths);
        addError(gen, errObj);
        if (!(compositeRule || allErrors)) {
            returnErrors(it, names_1.default.vErrors);
        }
    }
    exports.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
        gen.assign(names_1.default.errors, errsCount);
        gen.if(codegen._`${names_1.default.vErrors} !== null`, ()=>gen.if(errsCount, ()=>gen.assign(codegen._`${names_1.default.vErrors}.length`, errsCount), ()=>gen.assign(names_1.default.vErrors, null)));
    }
    exports.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen , keyword: keyword2 , schemaValue , data , errsCount , it  }) {
        if (errsCount === void 0) throw new Error("ajv implementation error");
        const err = gen.name("err");
        gen.forRange("i", errsCount, names_1.default.errors, (i)=>{
            gen.const(err, codegen._`${names_1.default.vErrors}[${i}]`);
            gen.if(codegen._`${err}.instancePath === undefined`, ()=>gen.assign(codegen._`${err}.instancePath`, (0, codegen.strConcat)(names_1.default.instancePath, it.errorPath)));
            gen.assign(codegen._`${err}.schemaPath`, codegen.str`${it.errSchemaPath}/${keyword2}`);
            if (it.opts.verbose) {
                gen.assign(codegen._`${err}.schema`, schemaValue);
                gen.assign(codegen._`${err}.data`, data);
            }
        });
    }
    exports.extendErrors = extendErrors;
    function addError(gen, errObj) {
        const err = gen.const("err", errObj);
        gen.if(codegen._`${names_1.default.vErrors} === null`, ()=>gen.assign(names_1.default.vErrors, codegen._`[${err}]`), codegen._`${names_1.default.vErrors}.push(${err})`);
        gen.code(codegen._`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
        const { gen , validateName , schemaEnv  } = it;
        if (schemaEnv.$async) {
            gen.throw(codegen._`new ${it.ValidationError}(${errs})`);
        } else {
            gen.assign(codegen._`${validateName}.errors`, errs);
            gen.return(false);
        }
    }
    const E = {
        keyword: new codegen.Name("keyword"),
        schemaPath: new codegen.Name("schemaPath"),
        params: new codegen.Name("params"),
        propertyName: new codegen.Name("propertyName"),
        message: new codegen.Name("message"),
        schema: new codegen.Name("schema"),
        parentSchema: new codegen.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
        const { createErrors  } = cxt.it;
        if (createErrors === false) return codegen._`{}`;
        return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
        const { gen , it  } = cxt;
        const keyValues = [
            errorInstancePath(it, errorPaths),
            errorSchemaPath(cxt, errorPaths)
        ];
        extraErrorProps(cxt, error, keyValues);
        return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath  }, { instancePath  }) {
        const instPath = instancePath ? codegen.str`${errorPath}${(0, util.getErrorPath)(instancePath, util.Type.Str)}` : errorPath;
        return [
            names_1.default.instancePath,
            (0, codegen.strConcat)(names_1.default.instancePath, instPath)
        ];
    }
    function errorSchemaPath({ keyword: keyword2 , it: { errSchemaPath  }  }, { schemaPath , parentSchema  }) {
        let schPath = parentSchema ? errSchemaPath : codegen.str`${errSchemaPath}/${keyword2}`;
        if (schemaPath) {
            schPath = codegen.str`${schPath}${(0, util.getErrorPath)(schemaPath, util.Type.Str)}`;
        }
        return [
            E.schemaPath,
            schPath
        ];
    }
    function extraErrorProps(cxt, { params , message  }, keyValues) {
        const { keyword: keyword2 , data , schemaValue , it  } = cxt;
        const { opts , propertyName , topSchemaRef , schemaPath  } = it;
        keyValues.push([
            E.keyword,
            keyword2
        ], [
            E.params,
            typeof params == "function" ? params(cxt) : params || codegen._`{}`
        ]);
        if (opts.messages) {
            keyValues.push([
                E.message,
                typeof message == "function" ? message(cxt) : message
            ]);
        }
        if (opts.verbose) {
            keyValues.push([
                E.schema,
                schemaValue
            ], [
                E.parentSchema,
                codegen._`${topSchemaRef}${schemaPath}`
            ], [
                names_1.default.data,
                data
            ]);
        }
        if (propertyName) keyValues.push([
            E.propertyName,
            propertyName
        ]);
    }
});
var boolSchema = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
    const boolError = {
        message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
        const { gen , schema , validateName  } = it;
        if (schema === false) {
            falseSchemaError(it, false);
        } else if (typeof schema == "object" && schema.$async === true) {
            gen.return(names_1.default.data);
        } else {
            gen.assign(codegen._`${validateName}.errors`, null);
            gen.return(true);
        }
    }
    exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
        const { gen , schema  } = it;
        if (schema === false) {
            gen.var(valid, false);
            falseSchemaError(it);
        } else {
            gen.var(valid, true);
        }
    }
    exports.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
        const { gen , data  } = it;
        const cxt = {
            gen,
            keyword: "false schema",
            data,
            schema: false,
            schemaCode: false,
            schemaValue: false,
            params: {},
            it
        };
        (0, errors.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
});
var rules = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.getRules = exports.isJSONType = void 0;
    const _jsonTypes = [
        "string",
        "number",
        "integer",
        "boolean",
        "null",
        "object",
        "array"
    ];
    const jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
        return typeof x == "string" && jsonTypes.has(x);
    }
    exports.isJSONType = isJSONType;
    function getRules() {
        const groups = {
            number: {
                type: "number",
                rules: []
            },
            string: {
                type: "string",
                rules: []
            },
            array: {
                type: "array",
                rules: []
            },
            object: {
                type: "object",
                rules: []
            }
        };
        return {
            types: {
                ...groups,
                integer: true,
                boolean: true,
                null: true
            },
            rules: [
                {
                    rules: []
                },
                groups.number,
                groups.string,
                groups.array,
                groups.object
            ],
            post: {
                rules: []
            },
            all: {},
            keywords: {}
        };
    }
    exports.getRules = getRules;
});
var applicability = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema , self: self1  }, type2) {
        const group = self1.RULES.types[type2];
        return group && group !== true && shouldUseGroup(schema, group);
    }
    exports.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
        return group.rules.some((rule)=>shouldUseRule(schema, rule));
    }
    exports.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
        var _a;
        return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd)=>schema[kwd] !== void 0));
    }
    exports.shouldUseRule = shouldUseRule;
});
var dataType = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
    var DataType;
    (function(DataType2) {
        DataType2[DataType2["Correct"] = 0] = "Correct";
        DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType = exports.DataType || (exports.DataType = {}));
    function getSchemaTypes(schema) {
        const types2 = getJSONTypes(schema.type);
        const hasNull = types2.includes("null");
        if (hasNull) {
            if (schema.nullable === false) throw new Error("type: null contradicts nullable: false");
        } else {
            if (!types2.length && schema.nullable !== void 0) {
                throw new Error('"nullable" cannot be used without "type"');
            }
            if (schema.nullable === true) types2.push("null");
        }
        return types2;
    }
    exports.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
        const types2 = Array.isArray(ts) ? ts : ts ? [
            ts
        ] : [];
        if (types2.every(rules.isJSONType)) return types2;
        throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
    }
    exports.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types2) {
        const { gen , data , opts  } = it;
        const coerceTo = coerceToTypes(types2, opts.coerceTypes);
        const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability.schemaHasRulesForType)(it, types2[0]));
        if (checkTypes) {
            const wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
            gen.if(wrongType, ()=>{
                if (coerceTo.length) coerceData(it, types2, coerceTo);
                else reportTypeError(it);
            });
        }
        return checkTypes;
    }
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    const COERCIBLE = new Set([
        "string",
        "number",
        "integer",
        "boolean",
        "null"
    ]);
    function coerceToTypes(types2, coerceTypes) {
        return coerceTypes ? types2.filter((t)=>COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types2, coerceTo) {
        const { gen , data , opts  } = it;
        const dataType2 = gen.let("dataType", codegen._`typeof ${data}`);
        const coerced = gen.let("coerced", codegen._`undefined`);
        if (opts.coerceTypes === "array") {
            gen.if(codegen._`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, ()=>gen.assign(data, codegen._`${data}[0]`).assign(dataType2, codegen._`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), ()=>gen.assign(coerced, data)));
        }
        gen.if(codegen._`${coerced} !== undefined`);
        for (const t of coerceTo){
            if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
                coerceSpecificType(t);
            }
        }
        gen.else();
        reportTypeError(it);
        gen.endIf();
        gen.if(codegen._`${coerced} !== undefined`, ()=>{
            gen.assign(data, coerced);
            assignParentData(it, coerced);
        });
        function coerceSpecificType(t) {
            switch(t){
                case "string":
                    gen.elseIf(codegen._`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, codegen._`"" + ${data}`).elseIf(codegen._`${data} === null`).assign(coerced, codegen._`""`);
                    return;
                case "number":
                    gen.elseIf(codegen._`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, codegen._`+${data}`);
                    return;
                case "integer":
                    gen.elseIf(codegen._`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, codegen._`+${data}`);
                    return;
                case "boolean":
                    gen.elseIf(codegen._`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf(codegen._`${data} === "true" || ${data} === 1`).assign(coerced, true);
                    return;
                case "null":
                    gen.elseIf(codegen._`${data} === "" || ${data} === 0 || ${data} === false`);
                    gen.assign(coerced, null);
                    return;
                case "array":
                    gen.elseIf(codegen._`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, codegen._`[${data}]`);
            }
        }
    }
    function assignParentData({ gen , parentData , parentDataProperty  }, expr) {
        gen.if(codegen._`${parentData} !== undefined`, ()=>gen.assign(codegen._`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
        const EQ = correct === DataType.Correct ? codegen.operators.EQ : codegen.operators.NEQ;
        let cond;
        switch(dataType2){
            case "null":
                return codegen._`${data} ${EQ} null`;
            case "array":
                cond = codegen._`Array.isArray(${data})`;
                break;
            case "object":
                cond = codegen._`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
                break;
            case "integer":
                cond = numCond(codegen._`!(${data} % 1) && !isNaN(${data})`);
                break;
            case "number":
                cond = numCond();
                break;
            default:
                return codegen._`typeof ${data} ${EQ} ${dataType2}`;
        }
        return correct === DataType.Correct ? cond : (0, codegen.not)(cond);
        function numCond(_cond = codegen.nil) {
            return (0, codegen.and)(codegen._`typeof ${data} == "number"`, _cond, strictNums ? codegen._`isFinite(${data})` : codegen.nil);
        }
    }
    exports.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
        if (dataTypes.length === 1) {
            return checkDataType(dataTypes[0], data, strictNums, correct);
        }
        let cond;
        const types2 = (0, util.toHash)(dataTypes);
        if (types2.array && types2.object) {
            const notObj = codegen._`typeof ${data} != "object"`;
            cond = types2.null ? notObj : codegen._`!${data} || ${notObj}`;
            delete types2.null;
            delete types2.array;
            delete types2.object;
        } else {
            cond = codegen.nil;
        }
        if (types2.number) delete types2.integer;
        for(const t in types2)cond = (0, codegen.and)(cond, checkDataType(t, data, strictNums, correct));
        return cond;
    }
    exports.checkDataTypes = checkDataTypes;
    const typeError = {
        message: ({ schema  })=>`must be ${schema}`,
        params: ({ schema , schemaValue  })=>typeof schema == "string" ? codegen._`{type: ${schema}}` : codegen._`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
        const cxt = getTypeErrorContext(it);
        (0, errors.reportError)(cxt, typeError);
    }
    exports.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
        const { gen , data , schema  } = it;
        const schemaCode = (0, util.schemaRefOrVal)(it, schema, "type");
        return {
            gen,
            keyword: "type",
            data,
            schema: schema.type,
            schemaCode,
            schemaValue: schemaCode,
            parentSchema: schema,
            params: {},
            it
        };
    }
});
var defaults = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.assignDefaults = void 0;
    function assignDefaults(it, ty) {
        const { properties: properties2 , items: items2  } = it.schema;
        if (ty === "object" && properties2) {
            for(const key in properties2){
                assignDefault(it, key, properties2[key].default);
            }
        } else if (ty === "array" && Array.isArray(items2)) {
            items2.forEach((sch, i)=>assignDefault(it, i, sch.default));
        }
    }
    exports.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
        const { gen , compositeRule , data , opts  } = it;
        if (defaultValue === void 0) return;
        const childData = codegen._`${data}${(0, codegen.getProperty)(prop)}`;
        if (compositeRule) {
            (0, util.checkStrictMode)(it, `default is ignored for: ${childData}`);
            return;
        }
        let condition = codegen._`${childData} === undefined`;
        if (opts.useDefaults === "empty") {
            condition = codegen._`${condition} || ${childData} === null || ${childData} === ""`;
        }
        gen.if(condition, codegen._`${childData} = ${(0, codegen.stringify)(defaultValue)}`);
    }
});
var code$1 = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
    const util_2 = util;
    function checkReportMissingProp(cxt, prop) {
        const { gen , data , it  } = cxt;
        gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), ()=>{
            cxt.setParams({
                missingProperty: codegen._`${prop}`
            }, true);
            cxt.error();
        });
    }
    exports.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen , data , it: { opts  }  }, properties2, missing) {
        return (0, codegen.or)(...properties2.map((prop)=>(0, codegen.and)(noPropertyInData(gen, data, prop, opts.ownProperties), codegen._`${missing} = ${prop}`)));
    }
    exports.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
        cxt.setParams({
            missingProperty: missing
        }, true);
        cxt.error();
    }
    exports.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
        return gen.scopeValue("func", {
            ref: Object.prototype.hasOwnProperty,
            code: codegen._`Object.prototype.hasOwnProperty`
        });
    }
    exports.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
        return codegen._`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
        const cond = codegen._`${data}${(0, codegen.getProperty)(property)} !== undefined`;
        return ownProperties ? codegen._`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
        const cond = codegen._`${data}${(0, codegen.getProperty)(property)} === undefined`;
        return ownProperties ? (0, codegen.or)(cond, (0, codegen.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
        return schemaMap ? Object.keys(schemaMap).filter((p)=>p !== "__proto__") : [];
    }
    exports.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
        return allSchemaProperties(schemaMap).filter((p)=>!(0, util.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode , data , it: { gen , topSchemaRef , schemaPath , errorPath  } , it  }, func, context, passSchema) {
        const dataAndSchema = passSchema ? codegen._`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
        const valCxt = [
            [
                names_1.default.instancePath,
                (0, codegen.strConcat)(names_1.default.instancePath, errorPath)
            ],
            [
                names_1.default.parentData,
                it.parentData
            ],
            [
                names_1.default.parentDataProperty,
                it.parentDataProperty
            ],
            [
                names_1.default.rootData,
                names_1.default.rootData
            ]
        ];
        if (it.opts.dynamicRef) valCxt.push([
            names_1.default.dynamicAnchors,
            names_1.default.dynamicAnchors
        ]);
        const args = codegen._`${dataAndSchema}, ${gen.object(...valCxt)}`;
        return context !== codegen.nil ? codegen._`${func}.call(${context}, ${args})` : codegen._`${func}(${args})`;
    }
    exports.callValidateCode = callValidateCode;
    const newRegExp = codegen._`new RegExp`;
    function usePattern({ gen , it: { opts  }  }, pattern2) {
        const u = opts.unicodeRegExp ? "u" : "";
        const { regExp  } = opts.code;
        const rx = regExp(pattern2, u);
        return gen.scopeValue("pattern", {
            key: rx.toString(),
            ref: rx,
            code: codegen._`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern2}, ${u})`
        });
    }
    exports.usePattern = usePattern;
    function validateArray(cxt) {
        const { gen , data , keyword: keyword2 , it  } = cxt;
        const valid = gen.name("valid");
        if (it.allErrors) {
            const validArr = gen.let("valid", true);
            validateItems(()=>gen.assign(validArr, false));
            return validArr;
        }
        gen.var(valid, true);
        validateItems(()=>gen.break());
        return valid;
        function validateItems(notValid) {
            const len = gen.const("len", codegen._`${data}.length`);
            gen.forRange("i", 0, len, (i)=>{
                cxt.subschema({
                    keyword: keyword2,
                    dataProp: i,
                    dataPropType: util.Type.Num
                }, valid);
                gen.if((0, codegen.not)(valid), notValid);
            });
        }
    }
    exports.validateArray = validateArray;
    function validateUnion(cxt) {
        const { gen , schema , keyword: keyword2 , it  } = cxt;
        if (!Array.isArray(schema)) throw new Error("ajv implementation error");
        const alwaysValid = schema.some((sch)=>(0, util.alwaysValidSchema)(it, sch));
        if (alwaysValid && !it.opts.unevaluated) return;
        const valid = gen.let("valid", false);
        const schValid = gen.name("_valid");
        gen.block(()=>schema.forEach((_sch, i)=>{
                const schCxt = cxt.subschema({
                    keyword: keyword2,
                    schemaProp: i,
                    compositeRule: true
                }, schValid);
                gen.assign(valid, codegen._`${valid} || ${schValid}`);
                const merged = cxt.mergeValidEvaluated(schCxt, schValid);
                if (!merged) gen.if((0, codegen.not)(valid));
            }));
        cxt.result(valid, ()=>cxt.reset(), ()=>cxt.error(true));
    }
    exports.validateUnion = validateUnion;
});
var keyword = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
    function macroKeywordCode(cxt, def) {
        const { gen , keyword: keyword2 , schema , parentSchema , it  } = cxt;
        const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
        const schemaRef = useKeyword(gen, keyword2, macroSchema);
        if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true);
        const valid = gen.name("valid");
        cxt.subschema({
            schema: macroSchema,
            schemaPath: codegen.nil,
            errSchemaPath: `${it.errSchemaPath}/${keyword2}`,
            topSchemaRef: schemaRef,
            compositeRule: true
        }, valid);
        cxt.pass(valid, ()=>cxt.error(true));
    }
    exports.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
        var _a;
        const { gen , keyword: keyword2 , schema , parentSchema , $data , it  } = cxt;
        checkAsyncKeyword(it, def);
        const validate2 = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
        const validateRef = useKeyword(gen, keyword2, validate2);
        const valid = gen.let("valid");
        cxt.block$data(valid, validateKeyword);
        cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
        function validateKeyword() {
            if (def.errors === false) {
                assignValid();
                if (def.modifying) modifyData(cxt);
                reportErrs(()=>cxt.error());
            } else {
                const ruleErrs = def.async ? validateAsync() : validateSync();
                if (def.modifying) modifyData(cxt);
                reportErrs(()=>addErrs(cxt, ruleErrs));
            }
        }
        function validateAsync() {
            const ruleErrs = gen.let("ruleErrs", null);
            gen.try(()=>assignValid(codegen._`await `), (e)=>gen.assign(valid, false).if(codegen._`${e} instanceof ${it.ValidationError}`, ()=>gen.assign(ruleErrs, codegen._`${e}.errors`), ()=>gen.throw(e)));
            return ruleErrs;
        }
        function validateSync() {
            const validateErrs = codegen._`${validateRef}.errors`;
            gen.assign(validateErrs, null);
            assignValid(codegen.nil);
            return validateErrs;
        }
        function assignValid(_await = def.async ? codegen._`await ` : codegen.nil) {
            const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
            const passSchema = !("compile" in def && !$data || def.schema === false);
            gen.assign(valid, codegen._`${_await}${(0, code$1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
        }
        function reportErrs(errors2) {
            var _a2;
            gen.if((0, codegen.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors2);
        }
    }
    exports.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
        const { gen , data , it  } = cxt;
        gen.if(it.parentData, ()=>gen.assign(data, codegen._`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
        const { gen  } = cxt;
        gen.if(codegen._`Array.isArray(${errs})`, ()=>{
            gen.assign(names_1.default.vErrors, codegen._`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, codegen._`${names_1.default.vErrors}.length`);
            (0, errors.extendErrors)(cxt);
        }, ()=>cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv  }, def) {
        if (def.async && !schemaEnv.$async) throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword2, result) {
        if (result === void 0) throw new Error(`keyword "${keyword2}" failed to compile`);
        return gen.scopeValue("keyword", typeof result == "function" ? {
            ref: result
        } : {
            ref: result,
            code: (0, codegen.stringify)(result)
        });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
        return !schemaType.length || schemaType.some((st)=>st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema , opts , self: self1 , errSchemaPath  }, def, keyword2) {
        if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword2) : def.keyword !== keyword2) {
            throw new Error("ajv implementation error");
        }
        const deps = def.dependencies;
        if (deps === null || deps === void 0 ? void 0 : deps.some((kwd)=>!Object.prototype.hasOwnProperty.call(schema, kwd))) {
            throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
        }
        if (def.validateSchema) {
            const valid = def.validateSchema(schema[keyword2]);
            if (!valid) {
                const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self1.errorsText(def.validateSchema.errors);
                if (opts.validateSchema === "log") self1.logger.error(msg);
                else throw new Error(msg);
            }
        }
    }
    exports.validateKeywordUsage = validateKeywordUsage;
});
var subschema = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
    function getSubschema(it, { keyword: keyword2 , schemaProp , schema , schemaPath , errSchemaPath , topSchemaRef  }) {
        if (keyword2 !== void 0 && schema !== void 0) {
            throw new Error('both "keyword" and "schema" passed, only one allowed');
        }
        if (keyword2 !== void 0) {
            const sch = it.schema[keyword2];
            return schemaProp === void 0 ? {
                schema: sch,
                schemaPath: codegen._`${it.schemaPath}${(0, codegen.getProperty)(keyword2)}`,
                errSchemaPath: `${it.errSchemaPath}/${keyword2}`
            } : {
                schema: sch[schemaProp],
                schemaPath: codegen._`${it.schemaPath}${(0, codegen.getProperty)(keyword2)}${(0, codegen.getProperty)(schemaProp)}`,
                errSchemaPath: `${it.errSchemaPath}/${keyword2}/${(0, util.escapeFragment)(schemaProp)}`
            };
        }
        if (schema !== void 0) {
            if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
                throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
            }
            return {
                schema,
                schemaPath,
                topSchemaRef,
                errSchemaPath
            };
        }
        throw new Error('either "keyword" or "schema" must be passed');
    }
    exports.getSubschema = getSubschema;
    function extendSubschemaData(subschema2, it, { dataProp , dataPropType: dpType , data , dataTypes , propertyName  }) {
        if (data !== void 0 && dataProp !== void 0) {
            throw new Error('both "data" and "dataProp" passed, only one allowed');
        }
        const { gen  } = it;
        if (dataProp !== void 0) {
            const { errorPath , dataPathArr , opts  } = it;
            const nextData = gen.let("data", codegen._`${it.data}${(0, codegen.getProperty)(dataProp)}`, true);
            dataContextProps(nextData);
            subschema2.errorPath = codegen.str`${errorPath}${(0, util.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
            subschema2.parentDataProperty = codegen._`${dataProp}`;
            subschema2.dataPathArr = [
                ...dataPathArr,
                subschema2.parentDataProperty
            ];
        }
        if (data !== void 0) {
            const nextData1 = data instanceof codegen.Name ? data : gen.let("data", data, true);
            dataContextProps(nextData1);
            if (propertyName !== void 0) subschema2.propertyName = propertyName;
        }
        if (dataTypes) subschema2.dataTypes = dataTypes;
        function dataContextProps(_nextData) {
            subschema2.data = _nextData;
            subschema2.dataLevel = it.dataLevel + 1;
            subschema2.dataTypes = [];
            it.definedProperties = new Set();
            subschema2.parentData = it.data;
            subschema2.dataNames = [
                ...it.dataNames,
                _nextData
            ];
        }
    }
    exports.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema2, { jtdDiscriminator , jtdMetadata , compositeRule , createErrors , allErrors  }) {
        if (compositeRule !== void 0) subschema2.compositeRule = compositeRule;
        if (createErrors !== void 0) subschema2.createErrors = createErrors;
        if (allErrors !== void 0) subschema2.allErrors = allErrors;
        subschema2.jtdDiscriminator = jtdDiscriminator;
        subschema2.jtdMetadata = jtdMetadata;
    }
    exports.extendSubschemaMode = extendSubschemaMode;
});
var resolve6 = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
    const SIMPLE_INLINED = new Set([
        "type",
        "format",
        "pattern",
        "maxLength",
        "minLength",
        "maxProperties",
        "minProperties",
        "maxItems",
        "minItems",
        "maximum",
        "minimum",
        "uniqueItems",
        "multipleOf",
        "required",
        "enum",
        "const"
    ]);
    function inlineRef(schema, limit = true) {
        if (typeof schema == "boolean") return true;
        if (limit === true) return !hasRef(schema);
        if (!limit) return false;
        return countKeys(schema) <= limit;
    }
    exports.inlineRef = inlineRef;
    const REF_KEYWORDS = new Set([
        "$ref",
        "$recursiveRef",
        "$recursiveAnchor",
        "$dynamicRef",
        "$dynamicAnchor"
    ]);
    function hasRef(schema) {
        for(const key in schema){
            if (REF_KEYWORDS.has(key)) return true;
            const sch = schema[key];
            if (Array.isArray(sch) && sch.some(hasRef)) return true;
            if (typeof sch == "object" && hasRef(sch)) return true;
        }
        return false;
    }
    function countKeys(schema) {
        let count = 0;
        for(const key in schema){
            if (key === "$ref") return Infinity;
            count++;
            if (SIMPLE_INLINED.has(key)) continue;
            if (typeof schema[key] == "object") {
                (0, util.eachItem)(schema[key], (sch)=>count += countKeys(sch));
            }
            if (count === Infinity) return Infinity;
        }
        return count;
    }
    function getFullPath(resolver, id2 = "", normalize) {
        if (normalize !== false) id2 = normalizeId(id2);
        const p = resolver.parse(id2);
        return _getFullPath(resolver, p);
    }
    exports.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
        const serialized = resolver.serialize(p);
        return serialized.split("#")[0] + "#";
    }
    exports._getFullPath = _getFullPath;
    const TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id2) {
        return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id2) {
        id2 = normalizeId(id2);
        return resolver.resolve(baseId, id2);
    }
    exports.resolveUrl = resolveUrl;
    const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
        if (typeof schema == "boolean") return {};
        const { schemaId , uriResolver  } = this.opts;
        const schId = normalizeId(schema[schemaId] || baseId);
        const baseIds = {
            "": schId
        };
        const pathPrefix = getFullPath(uriResolver, schId, false);
        const localRefs = {};
        const schemaRefs = new Set();
        jsonSchemaTraverse(schema, {
            allKeys: true
        }, (sch, jsonPtr, _2, parentJsonPtr)=>{
            if (parentJsonPtr === void 0) return;
            const fullPath = pathPrefix + jsonPtr;
            let baseId2 = baseIds[parentJsonPtr];
            if (typeof sch[schemaId] == "string") baseId2 = addRef.call(this, sch[schemaId]);
            addAnchor.call(this, sch.$anchor);
            addAnchor.call(this, sch.$dynamicAnchor);
            baseIds[jsonPtr] = baseId2;
            function addRef(ref2) {
                const _resolve = this.opts.uriResolver.resolve;
                ref2 = normalizeId(baseId2 ? _resolve(baseId2, ref2) : ref2);
                if (schemaRefs.has(ref2)) throw ambiguos(ref2);
                schemaRefs.add(ref2);
                let schOrRef = this.refs[ref2];
                if (typeof schOrRef == "string") schOrRef = this.refs[schOrRef];
                if (typeof schOrRef == "object") {
                    checkAmbiguosRef(sch, schOrRef.schema, ref2);
                } else if (ref2 !== normalizeId(fullPath)) {
                    if (ref2[0] === "#") {
                        checkAmbiguosRef(sch, localRefs[ref2], ref2);
                        localRefs[ref2] = sch;
                    } else {
                        this.refs[ref2] = fullPath;
                    }
                }
                return ref2;
            }
            function addAnchor(anchor) {
                if (typeof anchor == "string") {
                    if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor "${anchor}"`);
                    addRef.call(this, `#${anchor}`);
                }
            }
        });
        return localRefs;
        function checkAmbiguosRef(sch1, sch2, ref2) {
            if (sch2 !== void 0 && !fastDeepEqual(sch1, sch2)) throw ambiguos(ref2);
        }
        function ambiguos(ref2) {
            return new Error(`reference "${ref2}" resolves to more than one schema`);
        }
    }
    exports.getSchemaRefs = getSchemaRefs;
});
var validate = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
    const dataType_2 = dataType;
    function validateFunctionCode(it) {
        if (isSchemaObj(it)) {
            checkKeywords(it);
            if (schemaCxtHasRules(it)) {
                topSchemaObjCode(it);
                return;
            }
        }
        validateFunction(it, ()=>(0, boolSchema.topBoolOrEmptySchema)(it));
    }
    exports.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen , validateName , schema , schemaEnv , opts  }, body) {
        if (opts.code.es5) {
            gen.func(validateName, codegen._`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, ()=>{
                gen.code(codegen._`"use strict"; ${funcSourceUrl(schema, opts)}`);
                destructureValCxtES5(gen, opts);
                gen.code(body);
            });
        } else {
            gen.func(validateName, codegen._`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, ()=>gen.code(funcSourceUrl(schema, opts)).code(body));
        }
    }
    function destructureValCxt(opts) {
        return codegen._`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? codegen._`, ${names_1.default.dynamicAnchors}={}` : codegen.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
        gen.if(names_1.default.valCxt, ()=>{
            gen.var(names_1.default.instancePath, codegen._`${names_1.default.valCxt}.${names_1.default.instancePath}`);
            gen.var(names_1.default.parentData, codegen._`${names_1.default.valCxt}.${names_1.default.parentData}`);
            gen.var(names_1.default.parentDataProperty, codegen._`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
            gen.var(names_1.default.rootData, codegen._`${names_1.default.valCxt}.${names_1.default.rootData}`);
            if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, codegen._`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
        }, ()=>{
            gen.var(names_1.default.instancePath, codegen._`""`);
            gen.var(names_1.default.parentData, codegen._`undefined`);
            gen.var(names_1.default.parentDataProperty, codegen._`undefined`);
            gen.var(names_1.default.rootData, names_1.default.data);
            if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, codegen._`{}`);
        });
    }
    function topSchemaObjCode(it) {
        const { schema , opts , gen  } = it;
        validateFunction(it, ()=>{
            if (opts.$comment && schema.$comment) commentKeyword(it);
            checkNoDefault(it);
            gen.let(names_1.default.vErrors, null);
            gen.let(names_1.default.errors, 0);
            if (opts.unevaluated) resetEvaluated(it);
            typeAndKeywords(it);
            returnResults(it);
        });
        return;
    }
    function resetEvaluated(it) {
        const { gen , validateName  } = it;
        it.evaluated = gen.const("evaluated", codegen._`${validateName}.evaluated`);
        gen.if(codegen._`${it.evaluated}.dynamicProps`, ()=>gen.assign(codegen._`${it.evaluated}.props`, codegen._`undefined`));
        gen.if(codegen._`${it.evaluated}.dynamicItems`, ()=>gen.assign(codegen._`${it.evaluated}.items`, codegen._`undefined`));
    }
    function funcSourceUrl(schema, opts) {
        const schId = typeof schema == "object" && schema[opts.schemaId];
        return schId && (opts.code.source || opts.code.process) ? codegen._`/*# sourceURL=${schId} */` : codegen.nil;
    }
    function subschemaCode(it, valid) {
        if (isSchemaObj(it)) {
            checkKeywords(it);
            if (schemaCxtHasRules(it)) {
                subSchemaObjCode(it, valid);
                return;
            }
        }
        (0, boolSchema.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema , self: self1  }) {
        if (typeof schema == "boolean") return !schema;
        for(const key in schema)if (self1.RULES.all[key]) return true;
        return false;
    }
    function isSchemaObj(it) {
        return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
        const { schema , gen , opts  } = it;
        if (opts.$comment && schema.$comment) commentKeyword(it);
        updateContext(it);
        checkAsyncSchema(it);
        const errsCount = gen.const("_errs", names_1.default.errors);
        typeAndKeywords(it, errsCount);
        gen.var(valid, codegen._`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
        (0, util.checkUnknownRules)(it);
        checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
        if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);
        const types2 = (0, dataType.getSchemaTypes)(it.schema);
        const checkedTypes = (0, dataType.coerceAndCheckDataType)(it, types2);
        schemaKeywords(it, types2, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
        const { schema , errSchemaPath , opts , self: self1  } = it;
        if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util.schemaHasRulesButRef)(schema, self1.RULES)) {
            self1.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
        }
    }
    function checkNoDefault(it) {
        const { schema , opts  } = it;
        if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
            (0, util.checkStrictMode)(it, "default is ignored in the schema root");
        }
    }
    function updateContext(it) {
        const schId = it.schema[it.opts.schemaId];
        if (schId) it.baseId = (0, resolve6.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
        if (it.schema.$async && !it.schemaEnv.$async) throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen , schemaEnv , schema , errSchemaPath , opts  }) {
        const msg = schema.$comment;
        if (opts.$comment === true) {
            gen.code(codegen._`${names_1.default.self}.logger.log(${msg})`);
        } else if (typeof opts.$comment == "function") {
            const schemaPath = codegen.str`${errSchemaPath}/$comment`;
            const rootName = gen.scopeValue("root", {
                ref: schemaEnv.root
            });
            gen.code(codegen._`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
        }
    }
    function returnResults(it) {
        const { gen , schemaEnv , validateName , ValidationError , opts  } = it;
        if (schemaEnv.$async) {
            gen.if(codegen._`${names_1.default.errors} === 0`, ()=>gen.return(names_1.default.data), ()=>gen.throw(codegen._`new ${ValidationError}(${names_1.default.vErrors})`));
        } else {
            gen.assign(codegen._`${validateName}.errors`, names_1.default.vErrors);
            if (opts.unevaluated) assignEvaluated(it);
            gen.return(codegen._`${names_1.default.errors} === 0`);
        }
    }
    function assignEvaluated({ gen , evaluated , props , items: items2  }) {
        if (props instanceof codegen.Name) gen.assign(codegen._`${evaluated}.props`, props);
        if (items2 instanceof codegen.Name) gen.assign(codegen._`${evaluated}.items`, items2);
    }
    function schemaKeywords(it, types2, typeErrors, errsCount) {
        const { gen , schema , data , allErrors , opts , self: self1  } = it;
        const { RULES  } = self1;
        if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util.schemaHasRulesButRef)(schema, RULES))) {
            gen.block(()=>keywordCode(it, "$ref", RULES.all.$ref.definition));
            return;
        }
        if (!opts.jtd) checkStrictTypes(it, types2);
        gen.block(()=>{
            for (const group of RULES.rules)groupKeywords(group);
            groupKeywords(RULES.post);
        });
        function groupKeywords(group) {
            if (!(0, applicability.shouldUseGroup)(schema, group)) return;
            if (group.type) {
                gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
                iterateKeywords(it, group);
                if (types2.length === 1 && types2[0] === group.type && typeErrors) {
                    gen.else();
                    (0, dataType_2.reportTypeError)(it);
                }
                gen.endIf();
            } else {
                iterateKeywords(it, group);
            }
            if (!allErrors) gen.if(codegen._`${names_1.default.errors} === ${errsCount || 0}`);
        }
    }
    function iterateKeywords(it, group) {
        const { gen , schema , opts: { useDefaults  }  } = it;
        if (useDefaults) (0, defaults.assignDefaults)(it, group.type);
        gen.block(()=>{
            for (const rule of group.rules){
                if ((0, applicability.shouldUseRule)(schema, rule)) {
                    keywordCode(it, rule.keyword, rule.definition, group.type);
                }
            }
        });
    }
    function checkStrictTypes(it, types2) {
        if (it.schemaEnv.meta || !it.opts.strictTypes) return;
        checkContextTypes(it, types2);
        if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types2);
        checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types2) {
        if (!types2.length) return;
        if (!it.dataTypes.length) {
            it.dataTypes = types2;
            return;
        }
        types2.forEach((t)=>{
            if (!includesType(it.dataTypes, t)) {
                strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
            }
        });
        it.dataTypes = it.dataTypes.filter((t)=>includesType(types2, t));
    }
    function checkMultipleTypes(it, ts) {
        if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
            strictTypesError(it, "use allowUnionTypes to allow union type keyword");
        }
    }
    function checkKeywordTypes(it, ts) {
        const rules2 = it.self.RULES.all;
        for(const keyword2 in rules2){
            const rule = rules2[keyword2];
            if (typeof rule == "object" && (0, applicability.shouldUseRule)(it.schema, rule)) {
                const { type: type2  } = rule.definition;
                if (type2.length && !type2.some((t)=>hasApplicableType(ts, t))) {
                    strictTypesError(it, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
                }
            }
        }
    }
    function hasApplicableType(schTs, kwdT) {
        return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
        return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function strictTypesError(it, msg) {
        const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
        msg += ` at "${schemaPath}" (strictTypes)`;
        (0, util.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    class KeywordCxt2 {
        constructor(it, def, keyword$1){
            (0, keyword.validateKeywordUsage)(it, def, keyword$1);
            this.gen = it.gen;
            this.allErrors = it.allErrors;
            this.keyword = keyword$1;
            this.data = it.data;
            this.schema = it.schema[keyword$1];
            this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
            this.schemaValue = (0, util.schemaRefOrVal)(it, this.schema, keyword$1, this.$data);
            this.schemaType = def.schemaType;
            this.parentSchema = it.schema;
            this.params = {};
            this.it = it;
            this.def = def;
            if (this.$data) {
                this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
            } else {
                this.schemaCode = this.schemaValue;
                if (!(0, keyword.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
                    throw new Error(`${keyword$1} value must be ${JSON.stringify(def.schemaType)}`);
                }
            }
            if ("code" in def ? def.trackErrors : def.errors !== false) {
                this.errsCount = it.gen.const("_errs", names_1.default.errors);
            }
        }
        result(condition, successAction, failAction) {
            this.failResult((0, codegen.not)(condition), successAction, failAction);
        }
        failResult(condition, successAction, failAction) {
            this.gen.if(condition);
            if (failAction) failAction();
            else this.error();
            if (successAction) {
                this.gen.else();
                successAction();
                if (this.allErrors) this.gen.endIf();
            } else {
                if (this.allErrors) this.gen.endIf();
                else this.gen.else();
            }
        }
        pass(condition, failAction) {
            this.failResult((0, codegen.not)(condition), void 0, failAction);
        }
        fail(condition) {
            if (condition === void 0) {
                this.error();
                if (!this.allErrors) this.gen.if(false);
                return;
            }
            this.gen.if(condition);
            this.error();
            if (this.allErrors) this.gen.endIf();
            else this.gen.else();
        }
        fail$data(condition) {
            if (!this.$data) return this.fail(condition);
            const { schemaCode  } = this;
            this.fail(codegen._`${schemaCode} !== undefined && (${(0, codegen.or)(this.invalid$data(), condition)})`);
        }
        error(append, errorParams, errorPaths) {
            if (errorParams) {
                this.setParams(errorParams);
                this._error(append, errorPaths);
                this.setParams({});
                return;
            }
            this._error(append, errorPaths);
        }
        _error(append, errorPaths) {
            (append ? errors.reportExtraError : errors.reportError)(this, this.def.error, errorPaths);
        }
        $dataError() {
            (0, errors.reportError)(this, this.def.$dataError || errors.keyword$DataError);
        }
        reset() {
            if (this.errsCount === void 0) throw new Error('add "trackErrors" to keyword definition');
            (0, errors.resetErrorsCount)(this.gen, this.errsCount);
        }
        ok(cond) {
            if (!this.allErrors) this.gen.if(cond);
        }
        setParams(obj, assign) {
            if (assign) Object.assign(this.params, obj);
            else this.params = obj;
        }
        block$data(valid, codeBlock, $dataValid = codegen.nil) {
            this.gen.block(()=>{
                this.check$data(valid, $dataValid);
                codeBlock();
            });
        }
        check$data(valid = codegen.nil, $dataValid = codegen.nil) {
            if (!this.$data) return;
            const { gen , schemaCode , schemaType , def  } = this;
            gen.if((0, codegen.or)(codegen._`${schemaCode} === undefined`, $dataValid));
            if (valid !== codegen.nil) gen.assign(valid, true);
            if (schemaType.length || def.validateSchema) {
                gen.elseIf(this.invalid$data());
                this.$dataError();
                if (valid !== codegen.nil) gen.assign(valid, false);
            }
            gen.else();
        }
        invalid$data() {
            const { gen , schemaCode , schemaType , def , it  } = this;
            return (0, codegen.or)(wrong$DataType(), invalid$DataSchema());
            function wrong$DataType() {
                if (schemaType.length) {
                    if (!(schemaCode instanceof codegen.Name)) throw new Error("ajv implementation error");
                    const st = Array.isArray(schemaType) ? schemaType : [
                        schemaType
                    ];
                    return codegen._`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
                }
                return codegen.nil;
            }
            function invalid$DataSchema() {
                if (def.validateSchema) {
                    const validateSchemaRef = gen.scopeValue("validate$data", {
                        ref: def.validateSchema
                    });
                    return codegen._`!${validateSchemaRef}(${schemaCode})`;
                }
                return codegen.nil;
            }
        }
        subschema(appl, valid) {
            const subschema$1 = (0, subschema.getSubschema)(this.it, appl);
            (0, subschema.extendSubschemaData)(subschema$1, this.it, appl);
            (0, subschema.extendSubschemaMode)(subschema$1, appl);
            const nextContext = {
                ...this.it,
                ...subschema$1,
                items: void 0,
                props: void 0
            };
            subschemaCode(nextContext, valid);
            return nextContext;
        }
        mergeEvaluated(schemaCxt, toName) {
            const { it , gen  } = this;
            if (!it.opts.unevaluated) return;
            if (it.props !== true && schemaCxt.props !== void 0) {
                it.props = util.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
            }
            if (it.items !== true && schemaCxt.items !== void 0) {
                it.items = util.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
            }
        }
        mergeValidEvaluated(schemaCxt, valid) {
            const { it , gen  } = this;
            if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
                gen.if(valid, ()=>this.mergeEvaluated(schemaCxt, codegen.Name));
                return true;
            }
        }
    }
    exports.KeywordCxt = KeywordCxt2;
    function keywordCode(it, keyword$1, def, ruleType) {
        const cxt = new KeywordCxt2(it, def, keyword$1);
        if ("code" in def) {
            def.code(cxt, ruleType);
        } else if (cxt.$data && def.validate) {
            (0, keyword.funcKeywordCode)(cxt, def);
        } else if ("macro" in def) {
            (0, keyword.macroKeywordCode)(cxt, def);
        } else if (def.compile || def.validate) {
            (0, keyword.funcKeywordCode)(cxt, def);
        }
    }
    const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel , dataNames , dataPathArr  }) {
        let jsonPointer;
        let data;
        if ($data === "") return names_1.default.rootData;
        if ($data[0] === "/") {
            if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`);
            jsonPointer = $data;
            data = names_1.default.rootData;
        } else {
            const matches = RELATIVE_JSON_POINTER.exec($data);
            if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`);
            const up = +matches[1];
            jsonPointer = matches[2];
            if (jsonPointer === "#") {
                if (up >= dataLevel) throw new Error(errorMsg("property/index", up));
                return dataPathArr[dataLevel - up];
            }
            if (up > dataLevel) throw new Error(errorMsg("data", up));
            data = dataNames[dataLevel - up];
            if (!jsonPointer) return data;
        }
        let expr = data;
        const segments = jsonPointer.split("/");
        for (const segment of segments){
            if (segment) {
                data = codegen._`${data}${(0, codegen.getProperty)((0, util.unescapeJsonPointer)(segment))}`;
                expr = codegen._`${expr} && ${data}`;
            }
        }
        return expr;
        function errorMsg(pointerType, up) {
            return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
        }
    }
    exports.getData = getData;
});
var validation_error = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    class ValidationError extends Error {
        constructor(errors2){
            super("validation failed");
            this.errors = errors2;
            this.ajv = this.validation = true;
        }
    }
    exports.default = ValidationError;
});
var ref_error = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    class MissingRefError extends Error {
        constructor(resolver, baseId, ref2, msg){
            super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
            this.missingRef = (0, resolve6.resolveUrl)(resolver, baseId, ref2);
            this.missingSchema = (0, resolve6.normalizeId)((0, resolve6.getFullPath)(resolver, this.missingRef));
        }
    }
    exports.default = MissingRefError;
});
var compile = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
    class SchemaEnv {
        constructor(env){
            var _a;
            this.refs = {};
            this.dynamicAnchors = {};
            let schema;
            if (typeof env.schema == "object") schema = env.schema;
            this.schema = env.schema;
            this.schemaId = env.schemaId;
            this.root = env.root || this;
            this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve6.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
            this.schemaPath = env.schemaPath;
            this.localRefs = env.localRefs;
            this.meta = env.meta;
            this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
            this.refs = {};
        }
    }
    exports.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
        const _sch = getCompilingSchema.call(this, sch);
        if (_sch) return _sch;
        const rootId = (0, resolve6.getFullPath)(this.opts.uriResolver, sch.root.baseId);
        const { es5 , lines  } = this.opts.code;
        const { ownProperties  } = this.opts;
        const gen = new codegen.CodeGen(this.scope, {
            es5,
            lines,
            ownProperties
        });
        let _ValidationError;
        if (sch.$async) {
            _ValidationError = gen.scopeValue("Error", {
                ref: validation_error.default,
                code: codegen._`require("ajv/dist/runtime/validation_error").default`
            });
        }
        const validateName = gen.scopeName("validate");
        sch.validateName = validateName;
        const schemaCxt = {
            gen,
            allErrors: this.opts.allErrors,
            data: names_1.default.data,
            parentData: names_1.default.parentData,
            parentDataProperty: names_1.default.parentDataProperty,
            dataNames: [
                names_1.default.data
            ],
            dataPathArr: [
                codegen.nil
            ],
            dataLevel: 0,
            dataTypes: [],
            definedProperties: new Set(),
            topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? {
                ref: sch.schema,
                code: (0, codegen.stringify)(sch.schema)
            } : {
                ref: sch.schema
            }),
            validateName,
            ValidationError: _ValidationError,
            schema: sch.schema,
            schemaEnv: sch,
            rootId,
            baseId: sch.baseId || rootId,
            schemaPath: codegen.nil,
            errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
            errorPath: codegen._`""`,
            opts: this.opts,
            self: this
        };
        let sourceCode;
        try {
            this._compilations.add(sch);
            (0, validate.validateFunctionCode)(schemaCxt);
            gen.optimize(this.opts.code.optimize);
            const validateCode = gen.toString();
            sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
            if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch);
            const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
            const validate$1 = makeValidate(this, this.scope.get());
            this.scope.value(validateName, {
                ref: validate$1
            });
            validate$1.errors = null;
            validate$1.schema = sch.schema;
            validate$1.schemaEnv = sch;
            if (sch.$async) validate$1.$async = true;
            if (this.opts.code.source === true) {
                validate$1.source = {
                    validateName,
                    validateCode,
                    scopeValues: gen._values
                };
            }
            if (this.opts.unevaluated) {
                const { props , items: items2  } = schemaCxt;
                validate$1.evaluated = {
                    props: props instanceof codegen.Name ? void 0 : props,
                    items: items2 instanceof codegen.Name ? void 0 : items2,
                    dynamicProps: props instanceof codegen.Name,
                    dynamicItems: items2 instanceof codegen.Name
                };
                if (validate$1.source) validate$1.source.evaluated = (0, codegen.stringify)(validate$1.evaluated);
            }
            sch.validate = validate$1;
            return sch;
        } catch (e) {
            delete sch.validate;
            delete sch.validateName;
            if (sourceCode) this.logger.error("Error compiling schema, function code:", sourceCode);
            throw e;
        } finally{
            this._compilations.delete(sch);
        }
    }
    exports.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref2) {
        var _a;
        ref2 = (0, resolve6.resolveUrl)(this.opts.uriResolver, baseId, ref2);
        const schOrFunc = root.refs[ref2];
        if (schOrFunc) return schOrFunc;
        let _sch = resolve$1.call(this, root, ref2);
        if (_sch === void 0) {
            const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref2];
            const { schemaId  } = this.opts;
            if (schema) _sch = new SchemaEnv({
                schema,
                schemaId,
                root,
                baseId
            });
        }
        if (_sch === void 0) return;
        return root.refs[ref2] = inlineOrCompile.call(this, _sch);
    }
    exports.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
        if ((0, resolve6.inlineRef)(sch.schema, this.opts.inlineRefs)) return sch.schema;
        return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
        for (const sch of this._compilations){
            if (sameSchemaEnv(sch, schEnv)) return sch;
        }
    }
    exports.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
        return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve$1(root, ref2) {
        let sch;
        while(typeof (sch = this.refs[ref2]) == "string")ref2 = sch;
        return sch || this.schemas[ref2] || resolveSchema.call(this, root, ref2);
    }
    function resolveSchema(root, ref2) {
        const p = this.opts.uriResolver.parse(ref2);
        const refPath = (0, resolve6._getFullPath)(this.opts.uriResolver, p);
        let baseId = (0, resolve6.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
        if (Object.keys(root.schema).length > 0 && refPath === baseId) {
            return getJsonPointer.call(this, p, root);
        }
        const id2 = (0, resolve6.normalizeId)(refPath);
        const schOrRef = this.refs[id2] || this.schemas[id2];
        if (typeof schOrRef == "string") {
            const sch = resolveSchema.call(this, root, schOrRef);
            if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object") return;
            return getJsonPointer.call(this, p, sch);
        }
        if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object") return;
        if (!schOrRef.validate) compileSchema.call(this, schOrRef);
        if (id2 === (0, resolve6.normalizeId)(ref2)) {
            const { schema  } = schOrRef;
            const { schemaId  } = this.opts;
            const schId = schema[schemaId];
            if (schId) baseId = (0, resolve6.resolveUrl)(this.opts.uriResolver, baseId, schId);
            return new SchemaEnv({
                schema,
                schemaId,
                root,
                baseId
            });
        }
        return getJsonPointer.call(this, p, schOrRef);
    }
    exports.resolveSchema = resolveSchema;
    const PREVENT_SCOPE_CHANGE = new Set([
        "properties",
        "patternProperties",
        "enum",
        "dependencies",
        "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId , schema , root  }) {
        var _a;
        if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/") return;
        for (const part of parsedRef.fragment.slice(1).split("/")){
            if (typeof schema === "boolean") return;
            const partSchema = schema[(0, util.unescapeFragment)(part)];
            if (partSchema === void 0) return;
            schema = partSchema;
            const schId = typeof schema === "object" && schema[this.opts.schemaId];
            if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
                baseId = (0, resolve6.resolveUrl)(this.opts.uriResolver, baseId, schId);
            }
        }
        let env;
        if (typeof schema != "boolean" && schema.$ref && !(0, util.schemaHasRulesButRef)(schema, this.RULES)) {
            const $ref = (0, resolve6.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
            env = resolveSchema.call(this, root, $ref);
        }
        const { schemaId  } = this.opts;
        env = env || new SchemaEnv({
            schema,
            schemaId,
            root,
            baseId
        });
        if (env.schema !== env.root.schema) return env;
        return void 0;
    }
});
const $id = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type = "object";
const required = [
    "$data"
];
const properties = {
    $data: {
        type: "string",
        anyOf: [
            {
                format: "relative-json-pointer"
            },
            {
                format: "json-pointer"
            }
        ]
    }
};
var $dataRefSchema = {
    $id,
    description,
    type,
    required,
    properties,
    additionalProperties: false
};
var uri_1 = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    __pika_web_default_export_for_treeshaking__.code = 'require("ajv/dist/runtime/uri").default';
    exports.default = __pika_web_default_export_for_treeshaking__;
});
var core = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    Object.defineProperty(exports, "KeywordCxt", {
        enumerable: true,
        get: function() {
            return validate.KeywordCxt;
        }
    });
    Object.defineProperty(exports, "_", {
        enumerable: true,
        get: function() {
            return codegen._;
        }
    });
    Object.defineProperty(exports, "str", {
        enumerable: true,
        get: function() {
            return codegen.str;
        }
    });
    Object.defineProperty(exports, "stringify", {
        enumerable: true,
        get: function() {
            return codegen.stringify;
        }
    });
    Object.defineProperty(exports, "nil", {
        enumerable: true,
        get: function() {
            return codegen.nil;
        }
    });
    Object.defineProperty(exports, "Name", {
        enumerable: true,
        get: function() {
            return codegen.Name;
        }
    });
    Object.defineProperty(exports, "CodeGen", {
        enumerable: true,
        get: function() {
            return codegen.CodeGen;
        }
    });
    const codegen_2 = codegen;
    const defaultRegExp = (str2, flags)=>new RegExp(str2, flags);
    defaultRegExp.code = "new RegExp";
    const META_IGNORE_OPTIONS = [
        "removeAdditional",
        "useDefaults",
        "coerceTypes"
    ];
    const EXT_SCOPE_NAMES = new Set([
        "validate",
        "serialize",
        "parse",
        "wrapper",
        "root",
        "schema",
        "keyword",
        "pattern",
        "formats",
        "validate$data",
        "func",
        "obj",
        "Error"
    ]);
    const removedOptions = {
        errorDataPath: "",
        format: "`validateFormats: false` can be used instead.",
        nullable: '"nullable" keyword is supported by default.',
        jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
        extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
        missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
        processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
        sourceCode: "Use option `code: {source: true}`",
        strictDefaults: "It is default now, see option `strict`.",
        strictKeywords: "It is default now, see option `strict`.",
        uniqueItems: '"uniqueItems" keyword is always validated.',
        unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
        cache: "Map is used as cache, schema object as key.",
        serialize: "Map is used as cache, schema object as key.",
        ajvErrors: "It is default now."
    };
    const deprecatedOptions = {
        ignoreKeywordsWithRef: "",
        jsPropertySyntax: "",
        unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    function requiredOptions(o) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
        const s = o.strict;
        const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
        const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
        const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
        const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
        return {
            strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
            strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
            strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
            strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
            strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
            code: o.code ? {
                ...o.code,
                optimize,
                regExp
            } : {
                optimize,
                regExp
            },
            loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : 200,
            loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : 200,
            meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
            messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
            inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
            schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
            addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
            validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
            validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
            unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
            int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
            uriResolver
        };
    }
    class Ajv {
        constructor(opts = {}){
            this.schemas = {};
            this.refs = {};
            this.formats = {};
            this._compilations = new Set();
            this._loading = {};
            this._cache = new Map();
            opts = this.opts = {
                ...opts,
                ...requiredOptions(opts)
            };
            const { es5 , lines  } = this.opts.code;
            this.scope = new codegen_2.ValueScope({
                scope: {},
                prefixes: EXT_SCOPE_NAMES,
                es5,
                lines
            });
            this.logger = getLogger(opts.logger);
            const formatOpt = opts.validateFormats;
            opts.validateFormats = false;
            this.RULES = (0, rules.getRules)();
            checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
            checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
            this._metaOpts = getMetaSchemaOptions.call(this);
            if (opts.formats) addInitialFormats.call(this);
            this._addVocabularies();
            this._addDefaultMetaSchema();
            if (opts.keywords) addInitialKeywords.call(this, opts.keywords);
            if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
            addInitialSchemas.call(this);
            opts.validateFormats = formatOpt;
        }
        _addVocabularies() {
            this.addKeyword("$async");
        }
        _addDefaultMetaSchema() {
            const { $data , meta , schemaId  } = this.opts;
            let _dataRefSchema = $dataRefSchema;
            if (schemaId === "id") {
                _dataRefSchema = {
                    ...$dataRefSchema
                };
                _dataRefSchema.id = _dataRefSchema.$id;
                delete _dataRefSchema.$id;
            }
            if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
        }
        defaultMeta() {
            const { meta , schemaId  } = this.opts;
            return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
        }
        validate(schemaKeyRef, data) {
            let v;
            if (typeof schemaKeyRef == "string") {
                v = this.getSchema(schemaKeyRef);
                if (!v) throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
            } else {
                v = this.compile(schemaKeyRef);
            }
            const valid = v(data);
            if (!("$async" in v)) this.errors = v.errors;
            return valid;
        }
        compile(schema, _meta) {
            const sch = this._addSchema(schema, _meta);
            return sch.validate || this._compileSchemaEnv(sch);
        }
        compileAsync(schema, meta) {
            if (typeof this.opts.loadSchema != "function") {
                throw new Error("options.loadSchema should be a function");
            }
            const { loadSchema  } = this.opts;
            return runCompileAsync.call(this, schema, meta);
            async function runCompileAsync(_schema, _meta) {
                await loadMetaSchema.call(this, _schema.$schema);
                const sch = this._addSchema(_schema, _meta);
                return sch.validate || _compileAsync.call(this, sch);
            }
            async function loadMetaSchema($ref) {
                if ($ref && !this.getSchema($ref)) {
                    await runCompileAsync.call(this, {
                        $ref
                    }, true);
                }
            }
            async function _compileAsync(sch) {
                try {
                    return this._compileSchemaEnv(sch);
                } catch (e) {
                    if (!(e instanceof ref_error.default)) throw e;
                    checkLoaded.call(this, e);
                    await loadMissingSchema.call(this, e.missingSchema);
                    return _compileAsync.call(this, sch);
                }
            }
            function checkLoaded({ missingSchema: ref2 , missingRef  }) {
                if (this.refs[ref2]) {
                    throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
                }
            }
            async function loadMissingSchema(ref2) {
                const _schema = await _loadSchema.call(this, ref2);
                if (!this.refs[ref2]) await loadMetaSchema.call(this, _schema.$schema);
                if (!this.refs[ref2]) this.addSchema(_schema, ref2, meta);
            }
            async function _loadSchema(ref2) {
                const p = this._loading[ref2];
                if (p) return p;
                try {
                    return await (this._loading[ref2] = loadSchema(ref2));
                } finally{
                    delete this._loading[ref2];
                }
            }
        }
        addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
            if (Array.isArray(schema)) {
                for (const sch of schema)this.addSchema(sch, void 0, _meta, _validateSchema);
                return this;
            }
            let id2;
            if (typeof schema === "object") {
                const { schemaId  } = this.opts;
                id2 = schema[schemaId];
                if (id2 !== void 0 && typeof id2 != "string") {
                    throw new Error(`schema ${schemaId} must be string`);
                }
            }
            key = (0, resolve6.normalizeId)(key || id2);
            this._checkUnique(key);
            this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
            return this;
        }
        addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
            this.addSchema(schema, key, true, _validateSchema);
            return this;
        }
        validateSchema(schema, throwOrLogError) {
            if (typeof schema == "boolean") return true;
            let $schema2;
            $schema2 = schema.$schema;
            if ($schema2 !== void 0 && typeof $schema2 != "string") {
                throw new Error("$schema must be a string");
            }
            $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
            if (!$schema2) {
                this.logger.warn("meta-schema not available");
                this.errors = null;
                return true;
            }
            const valid = this.validate($schema2, schema);
            if (!valid && throwOrLogError) {
                const message = "schema is invalid: " + this.errorsText();
                if (this.opts.validateSchema === "log") this.logger.error(message);
                else throw new Error(message);
            }
            return valid;
        }
        getSchema(keyRef) {
            let sch;
            while(typeof (sch = getSchEnv.call(this, keyRef)) == "string")keyRef = sch;
            if (sch === void 0) {
                const { schemaId  } = this.opts;
                const root = new compile.SchemaEnv({
                    schema: {},
                    schemaId
                });
                sch = compile.resolveSchema.call(this, root, keyRef);
                if (!sch) return;
                this.refs[keyRef] = sch;
            }
            return sch.validate || this._compileSchemaEnv(sch);
        }
        removeSchema(schemaKeyRef) {
            if (schemaKeyRef instanceof RegExp) {
                this._removeAllSchemas(this.schemas, schemaKeyRef);
                this._removeAllSchemas(this.refs, schemaKeyRef);
                return this;
            }
            switch(typeof schemaKeyRef){
                case "undefined":
                    this._removeAllSchemas(this.schemas);
                    this._removeAllSchemas(this.refs);
                    this._cache.clear();
                    return this;
                case "string":
                    {
                        const sch = getSchEnv.call(this, schemaKeyRef);
                        if (typeof sch == "object") this._cache.delete(sch.schema);
                        delete this.schemas[schemaKeyRef];
                        delete this.refs[schemaKeyRef];
                        return this;
                    }
                case "object":
                    {
                        const cacheKey = schemaKeyRef;
                        this._cache.delete(cacheKey);
                        let id2 = schemaKeyRef[this.opts.schemaId];
                        if (id2) {
                            id2 = (0, resolve6.normalizeId)(id2);
                            delete this.schemas[id2];
                            delete this.refs[id2];
                        }
                        return this;
                    }
                default:
                    throw new Error("ajv.removeSchema: invalid parameter");
            }
        }
        addVocabulary(definitions2) {
            for (const def of definitions2)this.addKeyword(def);
            return this;
        }
        addKeyword(kwdOrDef, def) {
            let keyword2;
            if (typeof kwdOrDef == "string") {
                keyword2 = kwdOrDef;
                if (typeof def == "object") {
                    this.logger.warn("these parameters are deprecated, see docs for addKeyword");
                    def.keyword = keyword2;
                }
            } else if (typeof kwdOrDef == "object" && def === void 0) {
                def = kwdOrDef;
                keyword2 = def.keyword;
                if (Array.isArray(keyword2) && !keyword2.length) {
                    throw new Error("addKeywords: keyword must be string or non-empty array");
                }
            } else {
                throw new Error("invalid addKeywords parameters");
            }
            checkKeyword.call(this, keyword2, def);
            if (!def) {
                (0, util.eachItem)(keyword2, (kwd)=>addRule.call(this, kwd));
                return this;
            }
            keywordMetaschema.call(this, def);
            const definition = {
                ...def,
                type: (0, dataType.getJSONTypes)(def.type),
                schemaType: (0, dataType.getJSONTypes)(def.schemaType)
            };
            (0, util.eachItem)(keyword2, definition.type.length === 0 ? (k)=>addRule.call(this, k, definition) : (k)=>definition.type.forEach((t)=>addRule.call(this, k, definition, t)));
            return this;
        }
        getKeyword(keyword2) {
            const rule = this.RULES.all[keyword2];
            return typeof rule == "object" ? rule.definition : !!rule;
        }
        removeKeyword(keyword2) {
            const { RULES  } = this;
            delete RULES.keywords[keyword2];
            delete RULES.all[keyword2];
            for (const group of RULES.rules){
                const i = group.rules.findIndex((rule)=>rule.keyword === keyword2);
                if (i >= 0) group.rules.splice(i, 1);
            }
            return this;
        }
        addFormat(name, format2) {
            if (typeof format2 == "string") format2 = new RegExp(format2);
            this.formats[name] = format2;
            return this;
        }
        errorsText(errors2 = this.errors, { separator =", " , dataVar ="data"  } = {}) {
            if (!errors2 || errors2.length === 0) return "No errors";
            return errors2.map((e)=>`${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg)=>text + separator + msg);
        }
        $dataMetaSchema(metaSchema, keywordsJsonPointers) {
            const rules2 = this.RULES.all;
            metaSchema = JSON.parse(JSON.stringify(metaSchema));
            for (const jsonPointer of keywordsJsonPointers){
                const segments = jsonPointer.split("/").slice(1);
                let keywords = metaSchema;
                for (const seg of segments)keywords = keywords[seg];
                for(const key in rules2){
                    const rule = rules2[key];
                    if (typeof rule != "object") continue;
                    const { $data  } = rule.definition;
                    const schema = keywords[key];
                    if ($data && schema) keywords[key] = schemaOrData(schema);
                }
            }
            return metaSchema;
        }
        _removeAllSchemas(schemas, regex) {
            for(const keyRef in schemas){
                const sch = schemas[keyRef];
                if (!regex || regex.test(keyRef)) {
                    if (typeof sch == "string") {
                        delete schemas[keyRef];
                    } else if (sch && !sch.meta) {
                        this._cache.delete(sch.schema);
                        delete schemas[keyRef];
                    }
                }
            }
        }
        _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
            let id2;
            const { schemaId  } = this.opts;
            if (typeof schema == "object") {
                id2 = schema[schemaId];
            } else {
                if (this.opts.jtd) throw new Error("schema must be object");
                else if (typeof schema != "boolean") throw new Error("schema must be object or boolean");
            }
            let sch = this._cache.get(schema);
            if (sch !== void 0) return sch;
            baseId = (0, resolve6.normalizeId)(id2 || baseId);
            const localRefs = resolve6.getSchemaRefs.call(this, schema, baseId);
            sch = new compile.SchemaEnv({
                schema,
                schemaId,
                meta,
                baseId,
                localRefs
            });
            this._cache.set(sch.schema, sch);
            if (addSchema && !baseId.startsWith("#")) {
                if (baseId) this._checkUnique(baseId);
                this.refs[baseId] = sch;
            }
            if (validateSchema) this.validateSchema(schema, true);
            return sch;
        }
        _checkUnique(id2) {
            if (this.schemas[id2] || this.refs[id2]) {
                throw new Error(`schema with key or id "${id2}" already exists`);
            }
        }
        _compileSchemaEnv(sch) {
            if (sch.meta) this._compileMetaSchema(sch);
            else compile.compileSchema.call(this, sch);
            if (!sch.validate) throw new Error("ajv implementation error");
            return sch.validate;
        }
        _compileMetaSchema(sch) {
            const currentOpts = this.opts;
            this.opts = this._metaOpts;
            try {
                compile.compileSchema.call(this, sch);
            } finally{
                this.opts = currentOpts;
            }
        }
    }
    exports.default = Ajv;
    Ajv.ValidationError = validation_error.default;
    Ajv.MissingRefError = ref_error.default;
    function checkOptions(checkOpts, options, msg, log = "error") {
        for(const key in checkOpts){
            const opt = key;
            if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
        }
    }
    function getSchEnv(keyRef) {
        keyRef = (0, resolve6.normalizeId)(keyRef);
        return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
        const optsSchemas = this.opts.schemas;
        if (!optsSchemas) return;
        if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas);
        else for(const key in optsSchemas)this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
        for(const name in this.opts.formats){
            const format2 = this.opts.formats[name];
            if (format2) this.addFormat(name, format2);
        }
    }
    function addInitialKeywords(defs) {
        if (Array.isArray(defs)) {
            this.addVocabulary(defs);
            return;
        }
        this.logger.warn("keywords option as map is deprecated, pass array");
        for(const keyword2 in defs){
            const def = defs[keyword2];
            if (!def.keyword) def.keyword = keyword2;
            this.addKeyword(def);
        }
    }
    function getMetaSchemaOptions() {
        const metaOpts = {
            ...this.opts
        };
        for (const opt of META_IGNORE_OPTIONS)delete metaOpts[opt];
        return metaOpts;
    }
    const noLogs = {
        log () {},
        warn () {},
        error () {}
    };
    function getLogger(logger) {
        if (logger === false) return noLogs;
        if (logger === void 0) return console;
        if (logger.log && logger.warn && logger.error) return logger;
        throw new Error("logger must implement log, warn and error methods");
    }
    const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword2, def) {
        const { RULES  } = this;
        (0, util.eachItem)(keyword2, (kwd)=>{
            if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`);
            if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`);
        });
        if (!def) return;
        if (def.$data && !("code" in def || "validate" in def)) {
            throw new Error('$data keyword must have "code" or "validate" function');
        }
    }
    function addRule(keyword2, definition, dataType$1) {
        var _a;
        const post = definition === null || definition === void 0 ? void 0 : definition.post;
        if (dataType$1 && post) throw new Error('keyword with "post" flag cannot have "type"');
        const { RULES  } = this;
        let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t  })=>t === dataType$1);
        if (!ruleGroup) {
            ruleGroup = {
                type: dataType$1,
                rules: []
            };
            RULES.rules.push(ruleGroup);
        }
        RULES.keywords[keyword2] = true;
        if (!definition) return;
        const rule = {
            keyword: keyword2,
            definition: {
                ...definition,
                type: (0, dataType.getJSONTypes)(definition.type),
                schemaType: (0, dataType.getJSONTypes)(definition.schemaType)
            }
        };
        if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before);
        else ruleGroup.rules.push(rule);
        RULES.all[keyword2] = rule;
        (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd)=>this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
        const i = ruleGroup.rules.findIndex((_rule)=>_rule.keyword === before);
        if (i >= 0) {
            ruleGroup.rules.splice(i, 0, rule);
        } else {
            ruleGroup.rules.push(rule);
            this.logger.warn(`rule ${before} is not defined`);
        }
    }
    function keywordMetaschema(def) {
        let { metaSchema  } = def;
        if (metaSchema === void 0) return;
        if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema);
        def.validateSchema = this.compile(metaSchema, true);
    }
    const $dataRef = {
        $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
        return {
            anyOf: [
                schema,
                $dataRef
            ]
        };
    }
});
var id = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const def = {
        keyword: "id",
        code () {
            throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
        }
    };
    exports.default = def;
});
var ref = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.callRef = exports.getValidate = void 0;
    const def = {
        keyword: "$ref",
        schemaType: "string",
        code (cxt) {
            const { gen , schema: $ref , it  } = cxt;
            const { baseId , schemaEnv: env , validateName , opts , self: self1  } = it;
            const { root  } = env;
            if (($ref === "#" || $ref === "#/") && baseId === root.baseId) return callRootRef();
            const schOrEnv = compile.resolveRef.call(self1, root, baseId, $ref);
            if (schOrEnv === void 0) throw new ref_error.default(it.opts.uriResolver, baseId, $ref);
            if (schOrEnv instanceof compile.SchemaEnv) return callValidate(schOrEnv);
            return inlineRefSchema(schOrEnv);
            function callRootRef() {
                if (env === root) return callRef(cxt, validateName, env, env.$async);
                const rootName = gen.scopeValue("root", {
                    ref: root
                });
                return callRef(cxt, codegen._`${rootName}.validate`, root, root.$async);
            }
            function callValidate(sch) {
                const v = getValidate(cxt, sch);
                callRef(cxt, v, sch, sch.$async);
            }
            function inlineRefSchema(sch) {
                const schName = gen.scopeValue("schema", opts.code.source === true ? {
                    ref: sch,
                    code: (0, codegen.stringify)(sch)
                } : {
                    ref: sch
                });
                const valid = gen.name("valid");
                const schCxt = cxt.subschema({
                    schema: sch,
                    dataTypes: [],
                    schemaPath: codegen.nil,
                    topSchemaRef: schName,
                    errSchemaPath: $ref
                }, valid);
                cxt.mergeEvaluated(schCxt);
                cxt.ok(valid);
            }
        }
    };
    function getValidate(cxt, sch) {
        const { gen  } = cxt;
        return sch.validate ? gen.scopeValue("validate", {
            ref: sch.validate
        }) : codegen._`${gen.scopeValue("wrapper", {
            ref: sch
        })}.validate`;
    }
    exports.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
        const { gen , it  } = cxt;
        const { allErrors , schemaEnv: env , opts  } = it;
        const passCxt = opts.passContext ? names_1.default.this : codegen.nil;
        if ($async) callAsyncRef();
        else callSyncRef();
        function callAsyncRef() {
            if (!env.$async) throw new Error("async schema referenced by sync schema");
            const valid = gen.let("valid");
            gen.try(()=>{
                gen.code(codegen._`await ${(0, code$1.callValidateCode)(cxt, v, passCxt)}`);
                addEvaluatedFrom(v);
                if (!allErrors) gen.assign(valid, true);
            }, (e)=>{
                gen.if(codegen._`!(${e} instanceof ${it.ValidationError})`, ()=>gen.throw(e));
                addErrorsFrom(e);
                if (!allErrors) gen.assign(valid, false);
            });
            cxt.ok(valid);
        }
        function callSyncRef() {
            cxt.result((0, code$1.callValidateCode)(cxt, v, passCxt), ()=>addEvaluatedFrom(v), ()=>addErrorsFrom(v));
        }
        function addErrorsFrom(source) {
            const errs = codegen._`${source}.errors`;
            gen.assign(names_1.default.vErrors, codegen._`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
            gen.assign(names_1.default.errors, codegen._`${names_1.default.vErrors}.length`);
        }
        function addEvaluatedFrom(source) {
            var _a;
            if (!it.opts.unevaluated) return;
            const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
            if (it.props !== true) {
                if (schEvaluated && !schEvaluated.dynamicProps) {
                    if (schEvaluated.props !== void 0) {
                        it.props = util.mergeEvaluated.props(gen, schEvaluated.props, it.props);
                    }
                } else {
                    const props = gen.var("props", codegen._`${source}.evaluated.props`);
                    it.props = util.mergeEvaluated.props(gen, props, it.props, codegen.Name);
                }
            }
            if (it.items !== true) {
                if (schEvaluated && !schEvaluated.dynamicItems) {
                    if (schEvaluated.items !== void 0) {
                        it.items = util.mergeEvaluated.items(gen, schEvaluated.items, it.items);
                    }
                } else {
                    const items2 = gen.var("items", codegen._`${source}.evaluated.items`);
                    it.items = util.mergeEvaluated.items(gen, items2, it.items, codegen.Name);
                }
            }
        }
    }
    exports.callRef = callRef;
    exports.default = def;
});
var core_1 = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const core2 = [
        "$schema",
        "$id",
        "$defs",
        "$vocabulary",
        {
            keyword: "$comment"
        },
        "definitions",
        id.default,
        ref.default
    ];
    exports.default = core2;
});
var limitNumber = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const ops = codegen.operators;
    const KWDs = {
        maximum: {
            okStr: "<=",
            ok: ops.LTE,
            fail: ops.GT
        },
        minimum: {
            okStr: ">=",
            ok: ops.GTE,
            fail: ops.LT
        },
        exclusiveMaximum: {
            okStr: "<",
            ok: ops.LT,
            fail: ops.GTE
        },
        exclusiveMinimum: {
            okStr: ">",
            ok: ops.GT,
            fail: ops.LTE
        }
    };
    const error = {
        message: ({ keyword: keyword2 , schemaCode  })=>codegen.str`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
        params: ({ keyword: keyword2 , schemaCode  })=>codegen._`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
    };
    const def = {
        keyword: Object.keys(KWDs),
        type: "number",
        schemaType: "number",
        $data: true,
        error,
        code (cxt) {
            const { keyword: keyword2 , data , schemaCode  } = cxt;
            cxt.fail$data(codegen._`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
        }
    };
    exports.default = def;
});
var multipleOf = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const error = {
        message: ({ schemaCode  })=>codegen.str`must be multiple of ${schemaCode}`,
        params: ({ schemaCode  })=>codegen._`{multipleOf: ${schemaCode}}`
    };
    const def = {
        keyword: "multipleOf",
        type: "number",
        schemaType: "number",
        $data: true,
        error,
        code (cxt) {
            const { gen , data , schemaCode , it  } = cxt;
            const prec = it.opts.multipleOfPrecision;
            const res = gen.let("res");
            const invalid = prec ? codegen._`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : codegen._`${res} !== parseInt(${res})`;
            cxt.fail$data(codegen._`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
        }
    };
    exports.default = def;
});
var ucs2length_1 = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    function ucs2length(str2) {
        const len = str2.length;
        let length = 0;
        let pos = 0;
        let value;
        while(pos < len){
            length++;
            value = str2.charCodeAt(pos++);
            if (value >= 55296 && value <= 56319 && pos < len) {
                value = str2.charCodeAt(pos);
                if ((value & 64512) === 56320) pos++;
            }
        }
        return length;
    }
    exports.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
});
var limitLength = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const error = {
        message ({ keyword: keyword2 , schemaCode  }) {
            const comp = keyword2 === "maxLength" ? "more" : "fewer";
            return codegen.str`must NOT have ${comp} than ${schemaCode} characters`;
        },
        params: ({ schemaCode  })=>codegen._`{limit: ${schemaCode}}`
    };
    const def = {
        keyword: [
            "maxLength",
            "minLength"
        ],
        type: "string",
        schemaType: "number",
        $data: true,
        error,
        code (cxt) {
            const { keyword: keyword2 , data , schemaCode , it  } = cxt;
            const op = keyword2 === "maxLength" ? codegen.operators.GT : codegen.operators.LT;
            const len = it.opts.unicode === false ? codegen._`${data}.length` : codegen._`${(0, util.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
            cxt.fail$data(codegen._`${len} ${op} ${schemaCode}`);
        }
    };
    exports.default = def;
});
var pattern = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const error = {
        message: ({ schemaCode  })=>codegen.str`must match pattern "${schemaCode}"`,
        params: ({ schemaCode  })=>codegen._`{pattern: ${schemaCode}}`
    };
    const def = {
        keyword: "pattern",
        type: "string",
        schemaType: "string",
        $data: true,
        error,
        code (cxt) {
            const { data , $data , schema , schemaCode , it  } = cxt;
            const u = it.opts.unicodeRegExp ? "u" : "";
            const regExp = $data ? codegen._`(new RegExp(${schemaCode}, ${u}))` : (0, code$1.usePattern)(cxt, schema);
            cxt.fail$data(codegen._`!${regExp}.test(${data})`);
        }
    };
    exports.default = def;
});
var limitProperties = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const error = {
        message ({ keyword: keyword2 , schemaCode  }) {
            const comp = keyword2 === "maxProperties" ? "more" : "fewer";
            return codegen.str`must NOT have ${comp} than ${schemaCode} properties`;
        },
        params: ({ schemaCode  })=>codegen._`{limit: ${schemaCode}}`
    };
    const def = {
        keyword: [
            "maxProperties",
            "minProperties"
        ],
        type: "object",
        schemaType: "number",
        $data: true,
        error,
        code (cxt) {
            const { keyword: keyword2 , data , schemaCode  } = cxt;
            const op = keyword2 === "maxProperties" ? codegen.operators.GT : codegen.operators.LT;
            cxt.fail$data(codegen._`Object.keys(${data}).length ${op} ${schemaCode}`);
        }
    };
    exports.default = def;
});
var required$1 = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const error = {
        message: ({ params: { missingProperty  }  })=>codegen.str`must have required property '${missingProperty}'`,
        params: ({ params: { missingProperty  }  })=>codegen._`{missingProperty: ${missingProperty}}`
    };
    const def = {
        keyword: "required",
        type: "object",
        schemaType: "array",
        $data: true,
        error,
        code (cxt) {
            const { gen , schema , schemaCode , data , $data , it  } = cxt;
            const { opts  } = it;
            if (!$data && schema.length === 0) return;
            const useLoop = schema.length >= opts.loopRequired;
            if (it.allErrors) allErrorsMode();
            else exitOnErrorMode();
            if (opts.strictRequired) {
                const props = cxt.parentSchema.properties;
                const { definedProperties  } = cxt.it;
                for (const requiredKey of schema){
                    if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
                        const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
                        const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
                        (0, util.checkStrictMode)(it, msg, it.opts.strictRequired);
                    }
                }
            }
            function allErrorsMode() {
                if (useLoop || $data) {
                    cxt.block$data(codegen.nil, loopAllRequired);
                } else {
                    for (const prop of schema){
                        (0, code$1.checkReportMissingProp)(cxt, prop);
                    }
                }
            }
            function exitOnErrorMode() {
                const missing = gen.let("missing");
                if (useLoop || $data) {
                    const valid = gen.let("valid", true);
                    cxt.block$data(valid, ()=>loopUntilMissing(missing, valid));
                    cxt.ok(valid);
                } else {
                    gen.if((0, code$1.checkMissingProp)(cxt, schema, missing));
                    (0, code$1.reportMissingProp)(cxt, missing);
                    gen.else();
                }
            }
            function loopAllRequired() {
                gen.forOf("prop", schemaCode, (prop)=>{
                    cxt.setParams({
                        missingProperty: prop
                    });
                    gen.if((0, code$1.noPropertyInData)(gen, data, prop, opts.ownProperties), ()=>cxt.error());
                });
            }
            function loopUntilMissing(missing, valid) {
                cxt.setParams({
                    missingProperty: missing
                });
                gen.forOf(missing, schemaCode, ()=>{
                    gen.assign(valid, (0, code$1.propertyInData)(gen, data, missing, opts.ownProperties));
                    gen.if((0, codegen.not)(valid), ()=>{
                        cxt.error();
                        gen.break();
                    });
                }, codegen.nil);
            }
        }
    };
    exports.default = def;
});
var limitItems = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const error = {
        message ({ keyword: keyword2 , schemaCode  }) {
            const comp = keyword2 === "maxItems" ? "more" : "fewer";
            return codegen.str`must NOT have ${comp} than ${schemaCode} items`;
        },
        params: ({ schemaCode  })=>codegen._`{limit: ${schemaCode}}`
    };
    const def = {
        keyword: [
            "maxItems",
            "minItems"
        ],
        type: "array",
        schemaType: "number",
        $data: true,
        error,
        code (cxt) {
            const { keyword: keyword2 , data , schemaCode  } = cxt;
            const op = keyword2 === "maxItems" ? codegen.operators.GT : codegen.operators.LT;
            cxt.fail$data(codegen._`${data}.length ${op} ${schemaCode}`);
        }
    };
    exports.default = def;
});
var equal_1 = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    fastDeepEqual.code = 'require("ajv/dist/runtime/equal").default';
    exports.default = fastDeepEqual;
});
var uniqueItems = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const error = {
        message: ({ params: { i , j  }  })=>codegen.str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
        params: ({ params: { i , j  }  })=>codegen._`{i: ${i}, j: ${j}}`
    };
    const def = {
        keyword: "uniqueItems",
        type: "array",
        schemaType: "boolean",
        $data: true,
        error,
        code (cxt) {
            const { gen , data , $data , schema , parentSchema , schemaCode , it  } = cxt;
            if (!$data && !schema) return;
            const valid = gen.let("valid");
            const itemTypes = parentSchema.items ? (0, dataType.getSchemaTypes)(parentSchema.items) : [];
            cxt.block$data(valid, validateUniqueItems, codegen._`${schemaCode} === false`);
            cxt.ok(valid);
            function validateUniqueItems() {
                const i = gen.let("i", codegen._`${data}.length`);
                const j = gen.let("j");
                cxt.setParams({
                    i,
                    j
                });
                gen.assign(valid, true);
                gen.if(codegen._`${i} > 1`, ()=>(canOptimize() ? loopN : loopN2)(i, j));
            }
            function canOptimize() {
                return itemTypes.length > 0 && !itemTypes.some((t)=>t === "object" || t === "array");
            }
            function loopN(i, j) {
                const item = gen.name("item");
                const wrongType = (0, dataType.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType.DataType.Wrong);
                const indices = gen.const("indices", codegen._`{}`);
                gen.for(codegen._`;${i}--;`, ()=>{
                    gen.let(item, codegen._`${data}[${i}]`);
                    gen.if(wrongType, codegen._`continue`);
                    if (itemTypes.length > 1) gen.if(codegen._`typeof ${item} == "string"`, codegen._`${item} += "_"`);
                    gen.if(codegen._`typeof ${indices}[${item}] == "number"`, ()=>{
                        gen.assign(j, codegen._`${indices}[${item}]`);
                        cxt.error();
                        gen.assign(valid, false).break();
                    }).code(codegen._`${indices}[${item}] = ${i}`);
                });
            }
            function loopN2(i, j) {
                const eql = (0, util.useFunc)(gen, equal_1.default);
                const outer = gen.name("outer");
                gen.label(outer).for(codegen._`;${i}--;`, ()=>gen.for(codegen._`${j} = ${i}; ${j}--;`, ()=>gen.if(codegen._`${eql}(${data}[${i}], ${data}[${j}])`, ()=>{
                            cxt.error();
                            gen.assign(valid, false).break(outer);
                        })));
            }
        }
    };
    exports.default = def;
});
var _const = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const error = {
        message: "must be equal to constant",
        params: ({ schemaCode  })=>codegen._`{allowedValue: ${schemaCode}}`
    };
    const def = {
        keyword: "const",
        $data: true,
        error,
        code (cxt) {
            const { gen , data , $data , schemaCode , schema  } = cxt;
            if ($data || schema && typeof schema == "object") {
                cxt.fail$data(codegen._`!${(0, util.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
            } else {
                cxt.fail(codegen._`${schema} !== ${data}`);
            }
        }
    };
    exports.default = def;
});
var _enum = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const error = {
        message: "must be equal to one of the allowed values",
        params: ({ schemaCode  })=>codegen._`{allowedValues: ${schemaCode}}`
    };
    const def = {
        keyword: "enum",
        schemaType: "array",
        $data: true,
        error,
        code (cxt) {
            const { gen , data , $data , schema , schemaCode , it  } = cxt;
            if (!$data && schema.length === 0) throw new Error("enum must have non-empty array");
            const useLoop = schema.length >= it.opts.loopEnum;
            let eql;
            const getEql = ()=>eql !== null && eql !== void 0 ? eql : eql = (0, util.useFunc)(gen, equal_1.default);
            let valid;
            if (useLoop || $data) {
                valid = gen.let("valid");
                cxt.block$data(valid, loopEnum);
            } else {
                if (!Array.isArray(schema)) throw new Error("ajv implementation error");
                const vSchema = gen.const("vSchema", schemaCode);
                valid = (0, codegen.or)(...schema.map((_x, i)=>equalCode(vSchema, i)));
            }
            cxt.pass(valid);
            function loopEnum() {
                gen.assign(valid, false);
                gen.forOf("v", schemaCode, (v)=>gen.if(codegen._`${getEql()}(${data}, ${v})`, ()=>gen.assign(valid, true).break()));
            }
            function equalCode(vSchema, i) {
                const sch = schema[i];
                return typeof sch === "object" && sch !== null ? codegen._`${getEql()}(${data}, ${vSchema}[${i}])` : codegen._`${data} === ${sch}`;
            }
        }
    };
    exports.default = def;
});
var validation_1 = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const validation = [
        limitNumber.default,
        multipleOf.default,
        limitLength.default,
        pattern.default,
        limitProperties.default,
        required$1.default,
        limitItems.default,
        uniqueItems.default,
        {
            keyword: "type",
            schemaType: [
                "string",
                "array"
            ]
        },
        {
            keyword: "nullable",
            schemaType: "boolean"
        },
        _const.default,
        _enum.default
    ];
    exports.default = validation;
});
var additionalItems = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.validateAdditionalItems = void 0;
    const error = {
        message: ({ params: { len  }  })=>codegen.str`must NOT have more than ${len} items`,
        params: ({ params: { len  }  })=>codegen._`{limit: ${len}}`
    };
    const def = {
        keyword: "additionalItems",
        type: "array",
        schemaType: [
            "boolean",
            "object"
        ],
        before: "uniqueItems",
        error,
        code (cxt) {
            const { parentSchema , it  } = cxt;
            const { items: items2  } = parentSchema;
            if (!Array.isArray(items2)) {
                (0, util.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
                return;
            }
            validateAdditionalItems(cxt, items2);
        }
    };
    function validateAdditionalItems(cxt, items2) {
        const { gen , schema , data , keyword: keyword2 , it  } = cxt;
        it.items = true;
        const len = gen.const("len", codegen._`${data}.length`);
        if (schema === false) {
            cxt.setParams({
                len: items2.length
            });
            cxt.pass(codegen._`${len} <= ${items2.length}`);
        } else if (typeof schema == "object" && !(0, util.alwaysValidSchema)(it, schema)) {
            const valid = gen.var("valid", codegen._`${len} <= ${items2.length}`);
            gen.if((0, codegen.not)(valid), ()=>validateItems(valid));
            cxt.ok(valid);
        }
        function validateItems(valid) {
            gen.forRange("i", items2.length, len, (i)=>{
                cxt.subschema({
                    keyword: keyword2,
                    dataProp: i,
                    dataPropType: util.Type.Num
                }, valid);
                if (!it.allErrors) gen.if((0, codegen.not)(valid), ()=>gen.break());
            });
        }
    }
    exports.validateAdditionalItems = validateAdditionalItems;
    exports.default = def;
});
var items = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.validateTuple = void 0;
    const def = {
        keyword: "items",
        type: "array",
        schemaType: [
            "object",
            "array",
            "boolean"
        ],
        before: "uniqueItems",
        code (cxt) {
            const { schema , it  } = cxt;
            if (Array.isArray(schema)) return validateTuple(cxt, "additionalItems", schema);
            it.items = true;
            if ((0, util.alwaysValidSchema)(it, schema)) return;
            cxt.ok((0, code$1.validateArray)(cxt));
        }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
        const { gen , parentSchema , data , keyword: keyword2 , it  } = cxt;
        checkStrictTuple(parentSchema);
        if (it.opts.unevaluated && schArr.length && it.items !== true) {
            it.items = util.mergeEvaluated.items(gen, schArr.length, it.items);
        }
        const valid = gen.name("valid");
        const len = gen.const("len", codegen._`${data}.length`);
        schArr.forEach((sch, i)=>{
            if ((0, util.alwaysValidSchema)(it, sch)) return;
            gen.if(codegen._`${len} > ${i}`, ()=>cxt.subschema({
                    keyword: keyword2,
                    schemaProp: i,
                    dataProp: i
                }, valid));
            cxt.ok(valid);
        });
        function checkStrictTuple(sch) {
            const { opts , errSchemaPath  } = it;
            const l = schArr.length;
            const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
            if (opts.strictTuples && !fullTuple) {
                const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
                (0, util.checkStrictMode)(it, msg, opts.strictTuples);
            }
        }
    }
    exports.validateTuple = validateTuple;
    exports.default = def;
});
var prefixItems = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const def = {
        keyword: "prefixItems",
        type: "array",
        schemaType: [
            "array"
        ],
        before: "uniqueItems",
        code: (cxt)=>(0, items.validateTuple)(cxt, "items")
    };
    exports.default = def;
});
var items2020 = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const error = {
        message: ({ params: { len  }  })=>codegen.str`must NOT have more than ${len} items`,
        params: ({ params: { len  }  })=>codegen._`{limit: ${len}}`
    };
    const def = {
        keyword: "items",
        type: "array",
        schemaType: [
            "object",
            "boolean"
        ],
        before: "uniqueItems",
        error,
        code (cxt) {
            const { schema , parentSchema , it  } = cxt;
            const { prefixItems: prefixItems2  } = parentSchema;
            it.items = true;
            if ((0, util.alwaysValidSchema)(it, schema)) return;
            if (prefixItems2) (0, additionalItems.validateAdditionalItems)(cxt, prefixItems2);
            else cxt.ok((0, code$1.validateArray)(cxt));
        }
    };
    exports.default = def;
});
var contains = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const error = {
        message: ({ params: { min , max  }  })=>max === void 0 ? codegen.str`must contain at least ${min} valid item(s)` : codegen.str`must contain at least ${min} and no more than ${max} valid item(s)`,
        params: ({ params: { min , max  }  })=>max === void 0 ? codegen._`{minContains: ${min}}` : codegen._`{minContains: ${min}, maxContains: ${max}}`
    };
    const def = {
        keyword: "contains",
        type: "array",
        schemaType: [
            "object",
            "boolean"
        ],
        before: "uniqueItems",
        trackErrors: true,
        error,
        code (cxt) {
            const { gen , schema , parentSchema , data , it  } = cxt;
            let min;
            let max;
            const { minContains , maxContains  } = parentSchema;
            if (it.opts.next) {
                min = minContains === void 0 ? 1 : minContains;
                max = maxContains;
            } else {
                min = 1;
            }
            const len = gen.const("len", codegen._`${data}.length`);
            cxt.setParams({
                min,
                max
            });
            if (max === void 0 && min === 0) {
                (0, util.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
                return;
            }
            if (max !== void 0 && min > max) {
                (0, util.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
                cxt.fail();
                return;
            }
            if ((0, util.alwaysValidSchema)(it, schema)) {
                let cond = codegen._`${len} >= ${min}`;
                if (max !== void 0) cond = codegen._`${cond} && ${len} <= ${max}`;
                cxt.pass(cond);
                return;
            }
            it.items = true;
            const valid = gen.name("valid");
            if (max === void 0 && min === 1) {
                validateItems(valid, ()=>gen.if(valid, ()=>gen.break()));
            } else if (min === 0) {
                gen.let(valid, true);
                if (max !== void 0) gen.if(codegen._`${data}.length > 0`, validateItemsWithCount);
            } else {
                gen.let(valid, false);
                validateItemsWithCount();
            }
            cxt.result(valid, ()=>cxt.reset());
            function validateItemsWithCount() {
                const schValid = gen.name("_valid");
                const count = gen.let("count", 0);
                validateItems(schValid, ()=>gen.if(schValid, ()=>checkLimits(count)));
            }
            function validateItems(_valid, block) {
                gen.forRange("i", 0, len, (i)=>{
                    cxt.subschema({
                        keyword: "contains",
                        dataProp: i,
                        dataPropType: util.Type.Num,
                        compositeRule: true
                    }, _valid);
                    block();
                });
            }
            function checkLimits(count) {
                gen.code(codegen._`${count}++`);
                if (max === void 0) {
                    gen.if(codegen._`${count} >= ${min}`, ()=>gen.assign(valid, true).break());
                } else {
                    gen.if(codegen._`${count} > ${max}`, ()=>gen.assign(valid, false).break());
                    if (min === 1) gen.assign(valid, true);
                    else gen.if(codegen._`${count} >= ${min}`, ()=>gen.assign(valid, true));
                }
            }
        }
    };
    exports.default = def;
});
var dependencies = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
    exports.error = {
        message: ({ params: { property , depsCount , deps  }  })=>{
            const property_ies = depsCount === 1 ? "property" : "properties";
            return codegen.str`must have ${property_ies} ${deps} when property ${property} is present`;
        },
        params: ({ params: { property , depsCount , deps , missingProperty  }  })=>codegen._`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
    };
    const def = {
        keyword: "dependencies",
        type: "object",
        schemaType: "object",
        error: exports.error,
        code (cxt) {
            const [propDeps, schDeps] = splitDependencies(cxt);
            validatePropertyDeps(cxt, propDeps);
            validateSchemaDeps(cxt, schDeps);
        }
    };
    function splitDependencies({ schema  }) {
        const propertyDeps = {};
        const schemaDeps = {};
        for(const key in schema){
            if (key === "__proto__") continue;
            const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
            deps[key] = schema[key];
        }
        return [
            propertyDeps,
            schemaDeps
        ];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
        const { gen , data , it  } = cxt;
        if (Object.keys(propertyDeps).length === 0) return;
        const missing = gen.let("missing");
        for(const prop in propertyDeps){
            const deps = propertyDeps[prop];
            if (deps.length === 0) continue;
            const hasProperty = (0, code$1.propertyInData)(gen, data, prop, it.opts.ownProperties);
            cxt.setParams({
                property: prop,
                depsCount: deps.length,
                deps: deps.join(", ")
            });
            if (it.allErrors) {
                gen.if(hasProperty, ()=>{
                    for (const depProp of deps){
                        (0, code$1.checkReportMissingProp)(cxt, depProp);
                    }
                });
            } else {
                gen.if(codegen._`${hasProperty} && (${(0, code$1.checkMissingProp)(cxt, deps, missing)})`);
                (0, code$1.reportMissingProp)(cxt, missing);
                gen.else();
            }
        }
    }
    exports.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
        const { gen , data , keyword: keyword2 , it  } = cxt;
        const valid = gen.name("valid");
        for(const prop in schemaDeps){
            if ((0, util.alwaysValidSchema)(it, schemaDeps[prop])) continue;
            gen.if((0, code$1.propertyInData)(gen, data, prop, it.opts.ownProperties), ()=>{
                const schCxt = cxt.subschema({
                    keyword: keyword2,
                    schemaProp: prop
                }, valid);
                cxt.mergeValidEvaluated(schCxt, valid);
            }, ()=>gen.var(valid, true));
            cxt.ok(valid);
        }
    }
    exports.validateSchemaDeps = validateSchemaDeps;
    exports.default = def;
});
var propertyNames = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const error = {
        message: "property name must be valid",
        params: ({ params  })=>codegen._`{propertyName: ${params.propertyName}}`
    };
    const def = {
        keyword: "propertyNames",
        type: "object",
        schemaType: [
            "object",
            "boolean"
        ],
        error,
        code (cxt) {
            const { gen , schema , data , it  } = cxt;
            if ((0, util.alwaysValidSchema)(it, schema)) return;
            const valid = gen.name("valid");
            gen.forIn("key", data, (key)=>{
                cxt.setParams({
                    propertyName: key
                });
                cxt.subschema({
                    keyword: "propertyNames",
                    data: key,
                    dataTypes: [
                        "string"
                    ],
                    propertyName: key,
                    compositeRule: true
                }, valid);
                gen.if((0, codegen.not)(valid), ()=>{
                    cxt.error(true);
                    if (!it.allErrors) gen.break();
                });
            });
            cxt.ok(valid);
        }
    };
    exports.default = def;
});
var additionalProperties$1 = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const error = {
        message: "must NOT have additional properties",
        params: ({ params  })=>codegen._`{additionalProperty: ${params.additionalProperty}}`
    };
    const def = {
        keyword: "additionalProperties",
        type: [
            "object"
        ],
        schemaType: [
            "boolean",
            "object"
        ],
        allowUndefined: true,
        trackErrors: true,
        error,
        code (cxt) {
            const { gen , schema , parentSchema , data , errsCount , it  } = cxt;
            if (!errsCount) throw new Error("ajv implementation error");
            const { allErrors , opts  } = it;
            it.props = true;
            if (opts.removeAdditional !== "all" && (0, util.alwaysValidSchema)(it, schema)) return;
            const props = (0, code$1.allSchemaProperties)(parentSchema.properties);
            const patProps = (0, code$1.allSchemaProperties)(parentSchema.patternProperties);
            checkAdditionalProperties();
            cxt.ok(codegen._`${errsCount} === ${names_1.default.errors}`);
            function checkAdditionalProperties() {
                gen.forIn("key", data, (key)=>{
                    if (!props.length && !patProps.length) additionalPropertyCode(key);
                    else gen.if(isAdditional(key), ()=>additionalPropertyCode(key));
                });
            }
            function isAdditional(key) {
                let definedProp;
                if (props.length > 8) {
                    const propsSchema = (0, util.schemaRefOrVal)(it, parentSchema.properties, "properties");
                    definedProp = (0, code$1.isOwnProperty)(gen, propsSchema, key);
                } else if (props.length) {
                    definedProp = (0, codegen.or)(...props.map((p)=>codegen._`${key} === ${p}`));
                } else {
                    definedProp = codegen.nil;
                }
                if (patProps.length) {
                    definedProp = (0, codegen.or)(definedProp, ...patProps.map((p)=>codegen._`${(0, code$1.usePattern)(cxt, p)}.test(${key})`));
                }
                return (0, codegen.not)(definedProp);
            }
            function deleteAdditional(key) {
                gen.code(codegen._`delete ${data}[${key}]`);
            }
            function additionalPropertyCode(key) {
                if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
                    deleteAdditional(key);
                    return;
                }
                if (schema === false) {
                    cxt.setParams({
                        additionalProperty: key
                    });
                    cxt.error();
                    if (!allErrors) gen.break();
                    return;
                }
                if (typeof schema == "object" && !(0, util.alwaysValidSchema)(it, schema)) {
                    const valid = gen.name("valid");
                    if (opts.removeAdditional === "failing") {
                        applyAdditionalSchema(key, valid, false);
                        gen.if((0, codegen.not)(valid), ()=>{
                            cxt.reset();
                            deleteAdditional(key);
                        });
                    } else {
                        applyAdditionalSchema(key, valid);
                        if (!allErrors) gen.if((0, codegen.not)(valid), ()=>gen.break());
                    }
                }
            }
            function applyAdditionalSchema(key, valid, errors2) {
                const subschema2 = {
                    keyword: "additionalProperties",
                    dataProp: key,
                    dataPropType: util.Type.Str
                };
                if (errors2 === false) {
                    Object.assign(subschema2, {
                        compositeRule: true,
                        createErrors: false,
                        allErrors: false
                    });
                }
                cxt.subschema(subschema2, valid);
            }
        }
    };
    exports.default = def;
});
var properties$1 = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const def = {
        keyword: "properties",
        type: "object",
        schemaType: "object",
        code (cxt) {
            const { gen , schema , parentSchema , data , it  } = cxt;
            if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
                additionalProperties$1.default.code(new validate.KeywordCxt(it, additionalProperties$1.default, "additionalProperties"));
            }
            const allProps = (0, code$1.allSchemaProperties)(schema);
            for (const prop of allProps){
                it.definedProperties.add(prop);
            }
            if (it.opts.unevaluated && allProps.length && it.props !== true) {
                it.props = util.mergeEvaluated.props(gen, (0, util.toHash)(allProps), it.props);
            }
            const properties2 = allProps.filter((p)=>!(0, util.alwaysValidSchema)(it, schema[p]));
            if (properties2.length === 0) return;
            const valid = gen.name("valid");
            for (const prop1 of properties2){
                if (hasDefault(prop1)) {
                    applyPropertySchema(prop1);
                } else {
                    gen.if((0, code$1.propertyInData)(gen, data, prop1, it.opts.ownProperties));
                    applyPropertySchema(prop1);
                    if (!it.allErrors) gen.else().var(valid, true);
                    gen.endIf();
                }
                cxt.it.definedProperties.add(prop1);
                cxt.ok(valid);
            }
            function hasDefault(prop) {
                return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
            }
            function applyPropertySchema(prop) {
                cxt.subschema({
                    keyword: "properties",
                    schemaProp: prop,
                    dataProp: prop
                }, valid);
            }
        }
    };
    exports.default = def;
});
var patternProperties = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const util_2 = util;
    const def = {
        keyword: "patternProperties",
        type: "object",
        schemaType: "object",
        code (cxt) {
            const { gen , schema , data , parentSchema , it  } = cxt;
            const { opts  } = it;
            const patterns = (0, code$1.allSchemaProperties)(schema);
            const alwaysValidPatterns = patterns.filter((p)=>(0, util.alwaysValidSchema)(it, schema[p]));
            if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
                return;
            }
            const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
            const valid = gen.name("valid");
            if (it.props !== true && !(it.props instanceof codegen.Name)) {
                it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
            }
            const { props  } = it;
            validatePatternProperties();
            function validatePatternProperties() {
                for (const pat of patterns){
                    if (checkProperties) checkMatchingProperties(pat);
                    if (it.allErrors) {
                        validateProperties(pat);
                    } else {
                        gen.var(valid, true);
                        validateProperties(pat);
                        gen.if(valid);
                    }
                }
            }
            function checkMatchingProperties(pat) {
                for(const prop in checkProperties){
                    if (new RegExp(pat).test(prop)) {
                        (0, util.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
                    }
                }
            }
            function validateProperties(pat) {
                gen.forIn("key", data, (key)=>{
                    gen.if(codegen._`${(0, code$1.usePattern)(cxt, pat)}.test(${key})`, ()=>{
                        const alwaysValid = alwaysValidPatterns.includes(pat);
                        if (!alwaysValid) {
                            cxt.subschema({
                                keyword: "patternProperties",
                                schemaProp: pat,
                                dataProp: key,
                                dataPropType: util_2.Type.Str
                            }, valid);
                        }
                        if (it.opts.unevaluated && props !== true) {
                            gen.assign(codegen._`${props}[${key}]`, true);
                        } else if (!alwaysValid && !it.allErrors) {
                            gen.if((0, codegen.not)(valid), ()=>gen.break());
                        }
                    });
                });
            }
        }
    };
    exports.default = def;
});
var not = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const def = {
        keyword: "not",
        schemaType: [
            "object",
            "boolean"
        ],
        trackErrors: true,
        code (cxt) {
            const { gen , schema , it  } = cxt;
            if ((0, util.alwaysValidSchema)(it, schema)) {
                cxt.fail();
                return;
            }
            const valid = gen.name("valid");
            cxt.subschema({
                keyword: "not",
                compositeRule: true,
                createErrors: false,
                allErrors: false
            }, valid);
            cxt.failResult(valid, ()=>cxt.reset(), ()=>cxt.error());
        },
        error: {
            message: "must NOT be valid"
        }
    };
    exports.default = def;
});
var anyOf = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const def = {
        keyword: "anyOf",
        schemaType: "array",
        trackErrors: true,
        code: code$1.validateUnion,
        error: {
            message: "must match a schema in anyOf"
        }
    };
    exports.default = def;
});
var oneOf = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const error = {
        message: "must match exactly one schema in oneOf",
        params: ({ params  })=>codegen._`{passingSchemas: ${params.passing}}`
    };
    const def = {
        keyword: "oneOf",
        schemaType: "array",
        trackErrors: true,
        error,
        code (cxt) {
            const { gen , schema , parentSchema , it  } = cxt;
            if (!Array.isArray(schema)) throw new Error("ajv implementation error");
            if (it.opts.discriminator && parentSchema.discriminator) return;
            const schArr = schema;
            const valid = gen.let("valid", false);
            const passing = gen.let("passing", null);
            const schValid = gen.name("_valid");
            cxt.setParams({
                passing
            });
            gen.block(validateOneOf);
            cxt.result(valid, ()=>cxt.reset(), ()=>cxt.error(true));
            function validateOneOf() {
                schArr.forEach((sch, i)=>{
                    let schCxt;
                    if ((0, util.alwaysValidSchema)(it, sch)) {
                        gen.var(schValid, true);
                    } else {
                        schCxt = cxt.subschema({
                            keyword: "oneOf",
                            schemaProp: i,
                            compositeRule: true
                        }, schValid);
                    }
                    if (i > 0) {
                        gen.if(codegen._`${schValid} && ${valid}`).assign(valid, false).assign(passing, codegen._`[${passing}, ${i}]`).else();
                    }
                    gen.if(schValid, ()=>{
                        gen.assign(valid, true);
                        gen.assign(passing, i);
                        if (schCxt) cxt.mergeEvaluated(schCxt, codegen.Name);
                    });
                });
            }
        }
    };
    exports.default = def;
});
var allOf = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const def = {
        keyword: "allOf",
        schemaType: "array",
        code (cxt) {
            const { gen , schema , it  } = cxt;
            if (!Array.isArray(schema)) throw new Error("ajv implementation error");
            const valid = gen.name("valid");
            schema.forEach((sch, i)=>{
                if ((0, util.alwaysValidSchema)(it, sch)) return;
                const schCxt = cxt.subschema({
                    keyword: "allOf",
                    schemaProp: i
                }, valid);
                cxt.ok(valid);
                cxt.mergeEvaluated(schCxt);
            });
        }
    };
    exports.default = def;
});
var _if = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const error = {
        message: ({ params  })=>codegen.str`must match "${params.ifClause}" schema`,
        params: ({ params  })=>codegen._`{failingKeyword: ${params.ifClause}}`
    };
    const def = {
        keyword: "if",
        schemaType: [
            "object",
            "boolean"
        ],
        trackErrors: true,
        error,
        code (cxt) {
            const { gen , parentSchema , it  } = cxt;
            if (parentSchema.then === void 0 && parentSchema.else === void 0) {
                (0, util.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
            }
            const hasThen = hasSchema(it, "then");
            const hasElse = hasSchema(it, "else");
            if (!hasThen && !hasElse) return;
            const valid = gen.let("valid", true);
            const schValid = gen.name("_valid");
            validateIf();
            cxt.reset();
            if (hasThen && hasElse) {
                const ifClause = gen.let("ifClause");
                cxt.setParams({
                    ifClause
                });
                gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
            } else if (hasThen) {
                gen.if(schValid, validateClause("then"));
            } else {
                gen.if((0, codegen.not)(schValid), validateClause("else"));
            }
            cxt.pass(valid, ()=>cxt.error(true));
            function validateIf() {
                const schCxt = cxt.subschema({
                    keyword: "if",
                    compositeRule: true,
                    createErrors: false,
                    allErrors: false
                }, schValid);
                cxt.mergeEvaluated(schCxt);
            }
            function validateClause(keyword2, ifClause) {
                return ()=>{
                    const schCxt = cxt.subschema({
                        keyword: keyword2
                    }, schValid);
                    gen.assign(valid, schValid);
                    cxt.mergeValidEvaluated(schCxt, valid);
                    if (ifClause) gen.assign(ifClause, codegen._`${keyword2}`);
                    else cxt.setParams({
                        ifClause: keyword2
                    });
                };
            }
        }
    };
    function hasSchema(it, keyword2) {
        const schema = it.schema[keyword2];
        return schema !== void 0 && !(0, util.alwaysValidSchema)(it, schema);
    }
    exports.default = def;
});
var thenElse = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const def = {
        keyword: [
            "then",
            "else"
        ],
        schemaType: [
            "object",
            "boolean"
        ],
        code ({ keyword: keyword2 , parentSchema , it  }) {
            if (parentSchema.if === void 0) (0, util.checkStrictMode)(it, `"${keyword2}" without "if" is ignored`);
        }
    };
    exports.default = def;
});
var applicator = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    function getApplicator(draft2020 = false) {
        const applicator2 = [
            not.default,
            anyOf.default,
            oneOf.default,
            allOf.default,
            _if.default,
            thenElse.default,
            propertyNames.default,
            additionalProperties$1.default,
            dependencies.default,
            properties$1.default,
            patternProperties.default
        ];
        if (draft2020) applicator2.push(prefixItems.default, items2020.default);
        else applicator2.push(additionalItems.default, items.default);
        applicator2.push(contains.default);
        return applicator2;
    }
    exports.default = getApplicator;
});
var format6 = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const error = {
        message: ({ schemaCode  })=>codegen.str`must match format "${schemaCode}"`,
        params: ({ schemaCode  })=>codegen._`{format: ${schemaCode}}`
    };
    const def = {
        keyword: "format",
        type: [
            "number",
            "string"
        ],
        schemaType: "string",
        $data: true,
        error,
        code (cxt, ruleType) {
            const { gen , data , $data , schema , schemaCode , it  } = cxt;
            const { opts , errSchemaPath , schemaEnv , self: self1  } = it;
            if (!opts.validateFormats) return;
            if ($data) validate$DataFormat();
            else validateFormat();
            function validate$DataFormat() {
                const fmts = gen.scopeValue("formats", {
                    ref: self1.formats,
                    code: opts.code.formats
                });
                const fDef = gen.const("fDef", codegen._`${fmts}[${schemaCode}]`);
                const fType = gen.let("fType");
                const format2 = gen.let("format");
                gen.if(codegen._`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, ()=>gen.assign(fType, codegen._`${fDef}.type || "string"`).assign(format2, codegen._`${fDef}.validate`), ()=>gen.assign(fType, codegen._`"string"`).assign(format2, fDef));
                cxt.fail$data((0, codegen.or)(unknownFmt(), invalidFmt()));
                function unknownFmt() {
                    if (opts.strictSchema === false) return codegen.nil;
                    return codegen._`${schemaCode} && !${format2}`;
                }
                function invalidFmt() {
                    const callFormat = schemaEnv.$async ? codegen._`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : codegen._`${format2}(${data})`;
                    const validData = codegen._`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
                    return codegen._`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
                }
            }
            function validateFormat() {
                const formatDef = self1.formats[schema];
                if (!formatDef) {
                    unknownFormat();
                    return;
                }
                if (formatDef === true) return;
                const [fmtType, format2, fmtRef] = getFormat(formatDef);
                if (fmtType === ruleType) cxt.pass(validCondition());
                function unknownFormat() {
                    if (opts.strictSchema === false) {
                        self1.logger.warn(unknownMsg());
                        return;
                    }
                    throw new Error(unknownMsg());
                    function unknownMsg() {
                        return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
                    }
                }
                function getFormat(fmtDef) {
                    const code2 = fmtDef instanceof RegExp ? (0, codegen.regexpCode)(fmtDef) : opts.code.formats ? codegen._`${opts.code.formats}${(0, codegen.getProperty)(schema)}` : void 0;
                    const fmt = gen.scopeValue("formats", {
                        key: schema,
                        ref: fmtDef,
                        code: code2
                    });
                    if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
                        return [
                            fmtDef.type || "string",
                            fmtDef.validate,
                            codegen._`${fmt}.validate`
                        ];
                    }
                    return [
                        "string",
                        fmtDef,
                        fmt
                    ];
                }
                function validCondition() {
                    if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
                        if (!schemaEnv.$async) throw new Error("async format in sync schema");
                        return codegen._`await ${fmtRef}(${data})`;
                    }
                    return typeof format2 == "function" ? codegen._`${fmtRef}(${data})` : codegen._`${fmtRef}.test(${data})`;
                }
            }
        }
    };
    exports.default = def;
});
var format_2 = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const format$1 = [
        format6.default
    ];
    exports.default = format$1;
});
var metadata = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.contentVocabulary = exports.metadataVocabulary = void 0;
    exports.metadataVocabulary = [
        "title",
        "description",
        "default",
        "deprecated",
        "readOnly",
        "writeOnly",
        "examples"
    ];
    exports.contentVocabulary = [
        "contentMediaType",
        "contentEncoding",
        "contentSchema"
    ];
});
var draft7 = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const draft7Vocabularies = [
        core_1.default,
        validation_1.default,
        (0, applicator.default)(),
        format_2.default,
        metadata.metadataVocabulary,
        metadata.contentVocabulary
    ];
    exports.default = draft7Vocabularies;
});
var types1 = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.DiscrError = void 0;
    (function(DiscrError) {
        DiscrError["Tag"] = "tag";
        DiscrError["Mapping"] = "mapping";
    })(exports.DiscrError || (exports.DiscrError = {}));
});
var discriminator = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const error = {
        message: ({ params: { discrError , tagName  }  })=>discrError === types1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
        params: ({ params: { discrError , tag , tagName  }  })=>codegen._`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    const def = {
        keyword: "discriminator",
        type: "object",
        schemaType: "object",
        error,
        code (cxt) {
            const { gen , data , schema , parentSchema , it  } = cxt;
            const { oneOf: oneOf2  } = parentSchema;
            if (!it.opts.discriminator) {
                throw new Error("discriminator: requires discriminator option");
            }
            const tagName = schema.propertyName;
            if (typeof tagName != "string") throw new Error("discriminator: requires propertyName");
            if (schema.mapping) throw new Error("discriminator: mapping is not supported");
            if (!oneOf2) throw new Error("discriminator: requires oneOf keyword");
            const valid = gen.let("valid", false);
            const tag = gen.const("tag", codegen._`${data}${(0, codegen.getProperty)(tagName)}`);
            gen.if(codegen._`typeof ${tag} == "string"`, ()=>validateMapping(), ()=>cxt.error(false, {
                    discrError: types1.DiscrError.Tag,
                    tag,
                    tagName
                }));
            cxt.ok(valid);
            function validateMapping() {
                const mapping = getMapping();
                gen.if(false);
                for(const tagValue in mapping){
                    gen.elseIf(codegen._`${tag} === ${tagValue}`);
                    gen.assign(valid, applyTagSchema(mapping[tagValue]));
                }
                gen.else();
                cxt.error(false, {
                    discrError: types1.DiscrError.Mapping,
                    tag,
                    tagName
                });
                gen.endIf();
            }
            function applyTagSchema(schemaProp) {
                const _valid = gen.name("valid");
                const schCxt = cxt.subschema({
                    keyword: "oneOf",
                    schemaProp
                }, _valid);
                cxt.mergeEvaluated(schCxt, codegen.Name);
                return _valid;
            }
            function getMapping() {
                var _a;
                const oneOfMapping = {};
                const topRequired = hasRequired(parentSchema);
                let tagRequired = true;
                for(let i = 0; i < oneOf2.length; i++){
                    let sch = oneOf2[i];
                    if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util.schemaHasRulesButRef)(sch, it.self.RULES)) {
                        sch = compile.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);
                        if (sch instanceof compile.SchemaEnv) sch = sch.schema;
                    }
                    const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
                    if (typeof propSch != "object") {
                        throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
                    }
                    tagRequired = tagRequired && (topRequired || hasRequired(sch));
                    addMappings(propSch, i);
                }
                if (!tagRequired) throw new Error(`discriminator: "${tagName}" must be required`);
                return oneOfMapping;
                function hasRequired({ required: required2  }) {
                    return Array.isArray(required2) && required2.includes(tagName);
                }
                function addMappings(sch, i) {
                    if (sch.const) {
                        addMapping(sch.const, i);
                    } else if (sch.enum) {
                        for (const tagValue of sch.enum){
                            addMapping(tagValue, i);
                        }
                    } else {
                        throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
                    }
                }
                function addMapping(tagValue, i) {
                    if (typeof tagValue != "string" || tagValue in oneOfMapping) {
                        throw new Error(`discriminator: "${tagName}" values must be unique strings`);
                    }
                    oneOfMapping[tagValue] = i;
                }
            }
        }
    };
    exports.default = def;
});
const $schema = "http://json-schema.org/draft-07/schema#";
const $id$1 = "http://json-schema.org/draft-07/schema#";
const title = "Core schema meta-schema";
const definitions = {
    schemaArray: {
        type: "array",
        minItems: 1,
        items: {
            $ref: "#"
        }
    },
    nonNegativeInteger: {
        type: "integer",
        minimum: 0
    },
    nonNegativeIntegerDefault0: {
        allOf: [
            {
                $ref: "#/definitions/nonNegativeInteger"
            },
            {
                default: 0
            }
        ]
    },
    simpleTypes: {
        enum: [
            "array",
            "boolean",
            "integer",
            "null",
            "number",
            "object",
            "string"
        ]
    },
    stringArray: {
        type: "array",
        items: {
            type: "string"
        },
        uniqueItems: true,
        default: []
    }
};
const type$1 = [
    "object",
    "boolean"
];
const properties$2 = {
    $id: {
        type: "string",
        format: "uri-reference"
    },
    $schema: {
        type: "string",
        format: "uri"
    },
    $ref: {
        type: "string",
        format: "uri-reference"
    },
    $comment: {
        type: "string"
    },
    title: {
        type: "string"
    },
    description: {
        type: "string"
    },
    default: true,
    readOnly: {
        type: "boolean",
        default: false
    },
    examples: {
        type: "array",
        items: true
    },
    multipleOf: {
        type: "number",
        exclusiveMinimum: 0
    },
    maximum: {
        type: "number"
    },
    exclusiveMaximum: {
        type: "number"
    },
    minimum: {
        type: "number"
    },
    exclusiveMinimum: {
        type: "number"
    },
    maxLength: {
        $ref: "#/definitions/nonNegativeInteger"
    },
    minLength: {
        $ref: "#/definitions/nonNegativeIntegerDefault0"
    },
    pattern: {
        type: "string",
        format: "regex"
    },
    additionalItems: {
        $ref: "#"
    },
    items: {
        anyOf: [
            {
                $ref: "#"
            },
            {
                $ref: "#/definitions/schemaArray"
            }
        ],
        default: true
    },
    maxItems: {
        $ref: "#/definitions/nonNegativeInteger"
    },
    minItems: {
        $ref: "#/definitions/nonNegativeIntegerDefault0"
    },
    uniqueItems: {
        type: "boolean",
        default: false
    },
    contains: {
        $ref: "#"
    },
    maxProperties: {
        $ref: "#/definitions/nonNegativeInteger"
    },
    minProperties: {
        $ref: "#/definitions/nonNegativeIntegerDefault0"
    },
    required: {
        $ref: "#/definitions/stringArray"
    },
    additionalProperties: {
        $ref: "#"
    },
    definitions: {
        type: "object",
        additionalProperties: {
            $ref: "#"
        },
        default: {}
    },
    properties: {
        type: "object",
        additionalProperties: {
            $ref: "#"
        },
        default: {}
    },
    patternProperties: {
        type: "object",
        additionalProperties: {
            $ref: "#"
        },
        propertyNames: {
            format: "regex"
        },
        default: {}
    },
    dependencies: {
        type: "object",
        additionalProperties: {
            anyOf: [
                {
                    $ref: "#"
                },
                {
                    $ref: "#/definitions/stringArray"
                }
            ]
        }
    },
    propertyNames: {
        $ref: "#"
    },
    const: true,
    enum: {
        type: "array",
        items: true,
        minItems: 1,
        uniqueItems: true
    },
    type: {
        anyOf: [
            {
                $ref: "#/definitions/simpleTypes"
            },
            {
                type: "array",
                items: {
                    $ref: "#/definitions/simpleTypes"
                },
                minItems: 1,
                uniqueItems: true
            }
        ]
    },
    format: {
        type: "string"
    },
    contentMediaType: {
        type: "string"
    },
    contentEncoding: {
        type: "string"
    },
    if: {
        $ref: "#"
    },
    then: {
        $ref: "#"
    },
    else: {
        $ref: "#"
    },
    allOf: {
        $ref: "#/definitions/schemaArray"
    },
    anyOf: {
        $ref: "#/definitions/schemaArray"
    },
    oneOf: {
        $ref: "#/definitions/schemaArray"
    },
    not: {
        $ref: "#"
    }
};
var draft7MetaSchema = {
    $schema,
    $id: $id$1,
    title,
    definitions,
    type: type$1,
    properties: properties$2,
    default: true
};
var ajv = createCommonjsModule2(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    const META_SUPPORT_DATA = [
        "/properties"
    ];
    const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    class Ajv extends core.default {
        _addVocabularies() {
            super._addVocabularies();
            draft7.default.forEach((v)=>this.addVocabulary(v));
            if (this.opts.discriminator) this.addKeyword(discriminator.default);
        }
        _addDefaultMetaSchema() {
            super._addDefaultMetaSchema();
            if (!this.opts.meta) return;
            const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
            this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
            this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
        }
        defaultMeta() {
            return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
        }
    }
    module.exports = exports = Ajv;
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = Ajv;
    Object.defineProperty(exports, "KeywordCxt", {
        enumerable: true,
        get: function() {
            return validate.KeywordCxt;
        }
    });
    Object.defineProperty(exports, "_", {
        enumerable: true,
        get: function() {
            return codegen._;
        }
    });
    Object.defineProperty(exports, "str", {
        enumerable: true,
        get: function() {
            return codegen.str;
        }
    });
    Object.defineProperty(exports, "stringify", {
        enumerable: true,
        get: function() {
            return codegen.stringify;
        }
    });
    Object.defineProperty(exports, "nil", {
        enumerable: true,
        get: function() {
            return codegen.nil;
        }
    });
    Object.defineProperty(exports, "Name", {
        enumerable: true,
        get: function() {
            return codegen.Name;
        }
    });
    Object.defineProperty(exports, "CodeGen", {
        enumerable: true,
        get: function() {
            return codegen.CodeGen;
        }
    });
});
var __pika_web_default_export_for_treeshaking__1 = getDefaultExportFromCjs1(ajv);
ajv.CodeGen;
ajv.KeywordCxt;
ajv.Name;
ajv._;
ajv.nil;
ajv.str;
ajv.stringify;
function getErrors(validator) {
    return (validator.errors || []).map((e)=>e.message).join('; ');
}
var AuthorizationType;
(function(AuthorizationType) {
    AuthorizationType[AuthorizationType["none"] = 0] = "none";
    AuthorizationType[AuthorizationType["read"] = 1] = "read";
    AuthorizationType[AuthorizationType["write"] = 2] = "write";
    AuthorizationType[AuthorizationType["create"] = 3] = "create";
})(AuthorizationType || (AuthorizationType = {}));
const ajv1 = new __pika_web_default_export_for_treeshaking__1({
    allErrors: true,
    strictSchema: false,
    allowUnionTypes: true
});
class Service {
    static Identity = new Service().setMethodPath("all", "/", (msg)=>Promise.resolve(msg));
    methodFuncs = {};
    schemas = {};
    initFunc = ()=>Promise.resolve();
    funcByUrl(method, url) {
        const pathMap = this.methodFuncs[method];
        if (!pathMap) return undefined;
        const matchPath = longestMatchingPath(pathMap, url.servicePath);
        if (!matchPath) return undefined;
        const matchPathElements = matchPath.split('/').filter((el)=>!!el);
        return [
            matchPathElements,
            pathMap[matchPath]
        ];
    }
    pathsAt(path) {
        if (!path.startsWith('/')) path = '/' + path;
        if (!path.endsWith('/')) path += '/';
        const paths = new Set();
        const isMatch = (p)=>{
            const rest = after(p, path);
            return rest && !rest.includes('/');
        };
        Object.values(this.methodFuncs).forEach((pm)=>Object.keys(pm).filter((p)=>isMatch(p)).forEach((p)=>paths.add(p)));
        return Array.from(paths.values()).map((p)=>{
            const name = after(p, path);
            return Object.keys(this.methodFuncs["getDirectory"]).some((k)=>k === p) ? [
                `${name}/`
            ] : [
                name
            ];
        });
    }
    enhanceContext(context, config, msg) {
        const proxyAdapterSource = context.manifest.proxyAdapterSource;
        if (proxyAdapterSource) {
            context.makeProxyRequest = async (msg)=>{
                const proxyAdapter = await context.getAdapter(proxyAdapterSource, config.proxyAdapterConfig || {});
                const proxyMsg = await proxyAdapter.buildMessage(msg);
                return await context.makeRequest(proxyMsg);
            };
        }
        context.traceparent = msg?.getHeader('traceparent') || undefined;
        context.tracestate = msg?.getHeader('tracestate') || undefined;
        return context;
    }
    func = (msg, context, config)=>{
        const method = msg.method.toLowerCase();
        const callMethodFunc = ([matchPathElements, methodFunc], msg, context, config)=>{
            msg.url.basePathElements = msg.url.basePathElements.concat(matchPathElements);
            const enhancedContext = this.enhanceContext(context, config, msg);
            return Promise.resolve(methodFunc(msg, enhancedContext, config));
        };
        if (method === 'options') return Promise.resolve(msg);
        if (msg.url.isDirectory) {
            const pathFunc = this.funcByUrl(method + 'Directory', msg.url);
            if (pathFunc) {
                return callMethodFunc(pathFunc, msg, context, config);
            }
        }
        let pathFunc1 = this.funcByUrl(method, msg.url);
        if (pathFunc1) return callMethodFunc(pathFunc1, msg, context, config);
        if (method === 'put' && this.methodFuncs['post'] && !context.manifest.isFilter) {
            pathFunc1 = this.funcByUrl('post', msg.url);
            if (!pathFunc1) return Promise.resolve(msg.setStatus(404, 'Not found'));
            return callMethodFunc(pathFunc1, msg, context, config).then((msg)=>{
                if (msg.data) msg.data = undefined;
                return msg;
            });
        }
        if (method === 'head') {
            pathFunc1 = this.funcByUrl('get', msg.url) || this.funcByUrl('all', msg.url);
            if (pathFunc1) {
                return callMethodFunc(pathFunc1, msg, context, config).then((msg)=>{
                    if (msg.data) msg.data = undefined;
                    return msg;
                });
            } else {
                return Promise.resolve(msg.setStatus(404, 'Not found'));
            }
        }
        if (this.methodFuncs['all']) {
            pathFunc1 = this.funcByUrl('all', msg.url);
            if (!pathFunc1) return Promise.resolve(msg.setStatus(404, 'Not found'));
            return callMethodFunc(pathFunc1, msg, context, config);
        }
        return Promise.resolve(context.manifest.isFilter ? msg : msg.setStatus(404, 'Not found'));
    };
    authType = (msg)=>{
        switch(msg.method){
            case "OPTIONS":
                return Promise.resolve(AuthorizationType.none);
            case "GET":
            case "HEAD":
            case "POST":
                return Promise.resolve(AuthorizationType.read);
            default:
                return Promise.resolve(AuthorizationType.write);
        }
    };
    setMethodPath(method, path, func, schema) {
        if (!path.startsWith('/')) path = '/' + path;
        if (schema) {
            const validator = ajv1.compile(schema);
            const innerFunc = func;
            func = async (msg, context, config)=>{
                if (!await msg.validate(validator)) {
                    return msg.setStatus(400, getErrors(validator));
                } else {
                    return innerFunc(msg, context, config);
                }
            };
            if (this.schemas[method]) {
                this.schemas[method][path] = schema;
            } else {
                this.schemas[method] = {
                    [path]: schema
                };
            }
        }
        if (this.methodFuncs[method]) {
            this.methodFuncs[method][path] = func;
        } else {
            this.methodFuncs[method] = {
                [path]: func
            };
        }
        return this;
    }
    initializer(initFunc) {
        this.initFunc = (context, config)=>{
            this.enhanceContext(context, config);
            return initFunc(context, config);
        };
    }
    get = (func)=>this.setMethodPath('get', '/', func);
    getPath = (path, func)=>this.setMethodPath('get', path, func);
    getDirectory = (func)=>this.setMethodPath('getDirectory', '/', func);
    getDirectoryPath = (path, func)=>this.setMethodPath('getDirectory', path, func);
    post = (func, schema)=>this.setMethodPath('post', '/', func, schema);
    postPath = (path, func, schema)=>this.setMethodPath('post', path, func, schema);
    postDirectory = (func)=>this.setMethodPath('postDirectory', '/', func);
    postDirectoryPath = (path, func)=>this.setMethodPath('postDirectory', path, func);
    put = (func, schema)=>this.setMethodPath('put', '/', func, schema);
    putPath = (path, func, schema)=>this.setMethodPath('put', path, func, schema);
    putDirectory = (func)=>this.setMethodPath('putDirectory', '/', func);
    putDirectoryPath = (path, func)=>this.setMethodPath('putDirectory', path, func);
    delete = (func)=>this.setMethodPath('delete', '/', func);
    deletePath = (path, func)=>this.setMethodPath('delete', path, func);
    deleteDirectory = (func)=>this.setMethodPath('deleteDirectory', '/', func);
    deleteDirectoryPath = (path, func)=>this.setMethodPath('deleteDirectory', path, func);
    patch = (func)=>this.setMethodPath('patch', '/', func);
    patchPath = (path, func)=>this.setMethodPath('patch', path, func);
    all = (func)=>this.setMethodPath('all', '/', func);
    allPath = (path, func)=>this.setMethodPath('all', path, func);
}
class AuthService extends Service {
    setUser = (func)=>{
        this.setUserFunc = func;
    };
    setUserFunc = (msg)=>Promise.resolve(msg);
}
class BaseStateClass {
    load(_context, _config) {
        return Promise.resolve();
    }
    unload() {
        return Promise.resolve();
    }
}
const nullState = (_cons)=>{
    throw new Error('State not set');
};
var Source;
(function(Source) {
    Source[Source["External"] = 0] = "External";
    Source[Source["Internal"] = 1] = "Internal";
    Source[Source["Outer"] = 2] = "Outer";
})(Source || (Source = {}));
async function getUserFromEmail(context, userUrlPattern, msg, email, internalPrivilege = false) {
    if (!email) return null;
    const userUrl = resolvePathPatternWithObject(userUrlPattern, {
        email
    }, [], '', '');
    const getUser = msg.copy().setMethod("GET").setUrl(userUrl);
    getUser.startSpan();
    getUser.internalPrivilege = internalPrivilege;
    const fullUserMsg = await context.makeRequest(getUser);
    getUser.internalPrivilege = false;
    const fullUser = fullUserMsg && fullUserMsg.data && fullUserMsg.ok ? await fullUserMsg.data.asJson().catch(()=>null) : null;
    return fullUser;
}
async function saveUser(context, userUrlPattern, msg, user, internalPrivilege = false) {
    const userUrl = resolvePathPatternWithObject(userUrlPattern, {
        email: user.email
    }, [], '', '');
    const putUser = msg.copy().setUrl(userUrl).setMethod('PUT').setDataJson(user);
    putUser.internalPrivilege = internalPrivilege;
    const putUserMsg = await context.makeRequest(putUser);
    putUser.internalPrivilege = false;
    return putUserMsg;
}
function userIsAnon(user) {
    return !user.email;
}
var __dirname = "/tmp/cdn/_7L5tse9km4CJVhsMBees/node_modules/bcx-expression-evaluator/dist";
function getDefaultExportFromCjs2(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function createCommonjsModule3(fn, basedir, module) {
    return module = {
        path: basedir,
        exports: {},
        require: function(path, base) {
            return commonjsRequire3(path, base === void 0 || base === null ? module.path : base);
        }
    }, fn(module, module.exports), module.exports;
}
function commonjsRequire3() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var dist = createCommonjsModule3(function(module) {
    function _extends() {
        _extends = Object.assign || function(target) {
            for(var i = 1; i < arguments.length; i++){
                var source = arguments[i];
                for(var key in source){
                    if (Object.prototype.hasOwnProperty.call(source, key)) {
                        target[key] = source[key];
                    }
                }
            }
            return target;
        };
        return _extends.apply(this, arguments);
    }
    function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
    }
    function _defineProperties(target, props) {
        for(var i = 0; i < props.length; i++){
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
    }
    module.exports = function(t, e) {
        var i = {};
        function __webpack_require__(e2) {
            if (i[e2]) {
                return i[e2].exports;
            }
            var n = i[e2] = {
                i: e2,
                l: false,
                exports: {}
            };
            var s = true;
            try {
                t[e2].call(n.exports, n, n.exports, __webpack_require__);
                s = false;
            } finally{
                if (s) delete i[e2];
            }
            n.l = true;
            return n.exports;
        }
        __webpack_require__.ab = __dirname + "/";
        function startup() {
            return __webpack_require__(81);
        }
        e(__webpack_require__);
        return startup();
    }({
        81: function _(t, e, i) {
            i.r(e);
            var Token = function() {
                function Token2(t2, e2) {
                    this.index = t2;
                    this.text = e2;
                }
                var _proto = Token2.prototype;
                _proto.withOp = function withOp(t2) {
                    this.opKey = t2;
                    return this;
                };
                _proto.withGetterSetter = function withGetterSetter(t2) {
                    this.key = t2;
                    return this;
                };
                _proto.withValue = function withValue(t2) {
                    this.value = t2;
                    return this;
                };
                _proto.toString = function toString() {
                    return "Token(" + this.text + ")";
                };
                return Token2;
            }();
            var Lexer = function() {
                function Lexer2() {}
                var _proto2 = Lexer2.prototype;
                _proto2.lex = function lex(t2, e2) {
                    var i2 = new Scanner(t2, e2);
                    var n2 = [];
                    var s2 = i2.scanToken();
                    while(s2){
                        n2.push(s2);
                        s2 = i2.scanToken();
                    }
                    return n2;
                };
                return Lexer2;
            }();
            var n = 0;
            var s = 1;
            var r = 2;
            var a = 3;
            var Scanner = function() {
                function Scanner2(t2, e2) {
                    if (e2 === void 0) {
                        e2 = {};
                    }
                    this.input = t2;
                    this.length = t2.length;
                    this.peek = 0;
                    this.index = -1;
                    this.stringInterpolationMode = e2.stringInterpolationMode || false;
                    var i2 = this.stringInterpolationMode ? r : n;
                    this.contextStack = [
                        i2
                    ];
                    this.advance();
                }
                var _proto3 = Scanner2.prototype;
                _proto3.scanToken = function scanToken() {
                    var t2 = this.index;
                    if (this.context !== r) {
                        while(this.peek <= d){
                            if (++this.index >= this.length) {
                                this.peek = h;
                                return null;
                            }
                            this.peek = this.input.charCodeAt(this.index);
                        }
                        if (isIdentifierStart(this.peek)) {
                            return this.scanIdentifier();
                        }
                        if (isDigit(this.peek)) {
                            return this.scanNumber(this.index);
                        }
                        switch(this.peek){
                            case I:
                                this.advance();
                                return isDigit(this.peek) ? this.scanNumber(t2) : new Token(t2, ".");
                            case et:
                                this.contextStack.push(s);
                                return this.scanCharacter(t2, String.fromCharCode(this.peek));
                            case nt:
                                this.contextStack.pop();
                                return this.scanCharacter(t2, String.fromCharCode(this.peek));
                            case S:
                            case C:
                            case Z:
                            case Y:
                            case A:
                            case m:
                            case M:
                                return this.scanCharacter(t2, String.fromCharCode(this.peek));
                            case y:
                            case v:
                                return this.scanString();
                            case _2:
                            case L:
                            case b:
                            case j:
                            case g:
                            case J:
                            case F:
                                return this.scanOperator(t2, String.fromCharCode(this.peek));
                            case O:
                            case q:
                            case x:
                            case P:
                                return this.scanComplexOperator(t2, P, String.fromCharCode(this.peek), "=");
                            case k:
                                return this.scanComplexOperator(t2, k, "&", "&");
                            case it:
                                return this.scanComplexOperator(t2, it, "|", "|");
                            case E:
                                this.contextStack.push(r);
                                return this.scanCharacter(t2, String.fromCharCode(this.peek));
                            case st:
                                while(isWhitespace(this.peek)){
                                    this.advance();
                                }
                                return this.scanToken();
                        }
                        var _e = String.fromCharCode(this.peek);
                        this.error("Unexpected character [" + _e + "]");
                        return null;
                    } else {
                        if (this.peek === E) {
                            if (this.isRootLevelOfStringInterpolationMode) {
                                return this.scanString();
                            } else {
                                this.contextStack.pop();
                                return this.scanCharacter(t2, String.fromCharCode(this.peek));
                            }
                        } else if (this.isStartOfInterpolation()) {
                            var _t = this.scanStartOfInterpolation();
                            this.contextStack.push(a);
                            return _t;
                        } else if (this.peek) {
                            return this.scanString();
                        }
                    }
                };
                _proto3.scanCharacter = function scanCharacter(t2, e2) {
                    assert(this.peek === e2.charCodeAt(0));
                    this.advance();
                    return new Token(t2, e2);
                };
                _proto3.scanOperator = function scanOperator(t2, e2) {
                    assert(this.peek === e2.charCodeAt(0));
                    assert(o.indexOf(e2) !== -1);
                    this.advance();
                    return new Token(t2, e2).withOp(e2);
                };
                _proto3.scanComplexOperator = function scanComplexOperator(t2, e2, i2, n2) {
                    assert(this.peek === i2.charCodeAt(0));
                    this.advance();
                    var s2 = i2;
                    if (this.peek === e2) {
                        this.advance();
                        s2 += n2;
                    }
                    if (this.peek === e2) {
                        this.advance();
                        s2 += n2;
                    }
                    assert(o.indexOf(s2) !== -1);
                    return new Token(t2, s2).withOp(s2);
                };
                _proto3.scanIdentifier = function scanIdentifier() {
                    assert(isIdentifierStart(this.peek));
                    var t2 = this.index;
                    this.advance();
                    while(isIdentifierPart(this.peek)){
                        this.advance();
                    }
                    var e2 = this.input.substring(t2, this.index);
                    var i2 = new Token(t2, e2);
                    if (o.indexOf(e2) !== -1) {
                        i2.withOp(e2);
                    } else {
                        i2.withGetterSetter(e2);
                    }
                    return i2;
                };
                _proto3.scanNumber = function scanNumber(t2) {
                    assert(isDigit(this.peek));
                    var e2 = this.index === t2;
                    this.advance();
                    while(true){
                        if (!isDigit(this.peek)) {
                            if (this.peek === I) {
                                e2 = false;
                            } else if (isExponentStart(this.peek)) {
                                this.advance();
                                if (isExponentSign(this.peek)) {
                                    this.advance();
                                }
                                if (!isDigit(this.peek)) {
                                    this.error("Invalid exponent", -1);
                                }
                                e2 = false;
                            } else {
                                break;
                            }
                        }
                        this.advance();
                    }
                    var i2 = this.input.substring(t2, this.index);
                    var n2 = e2 ? parseInt(i2, 10) : parseFloat(i2);
                    return new Token(t2, i2).withValue(n2);
                };
                _proto3.scanString = function scanString() {
                    if (this.context !== r) {
                        assert(this.peek === y || this.peek === v);
                    }
                    var t2 = this.index;
                    var e2;
                    if (this.context !== r) {
                        e2 = this.peek;
                        this.advance();
                    } else {
                        e2 = this.isRootLevelOfStringInterpolationMode ? h : E;
                    }
                    var i2;
                    var n2 = this.index;
                    while(this.peek !== e2 && !this.isStartOfInterpolation()){
                        if (this.peek === z) {
                            if (!i2) {
                                i2 = [];
                            }
                            i2.push(this.input.substring(n2, this.index));
                            this.advance();
                            var _t2 = void 0;
                            if (this.peek === N) {
                                var _e2 = this.input.substring(this.index + 1, this.index + 5);
                                if (!/[A-Z0-9]{4}/.test(_e2)) {
                                    this.error("Invalid unicode escape [\\u" + _e2 + "]");
                                }
                                _t2 = parseInt(_e2, 16);
                                for(var _t3 = 0; _t3 < 5; ++_t3){
                                    this.advance();
                                }
                            } else {
                                _t2 = lexer_unescape(this.peek);
                                this.advance();
                            }
                            i2.push(String.fromCharCode(_t2));
                            n2 = this.index;
                        } else if (e2 !== h && this.peek === h) {
                            this.error("Unterminated quote");
                        } else {
                            this.advance();
                        }
                    }
                    var s2 = this.input.substring(n2, this.index);
                    if (this.context !== r) {
                        this.advance();
                    }
                    var a2 = this.input.substring(t2, this.index);
                    var o2 = s2;
                    if (i2 !== null && i2 !== void 0) {
                        i2.push(s2);
                        o2 = i2.join("");
                    }
                    return new Token(t2, a2).withValue(o2);
                };
                _proto3.scanStartOfInterpolation = function scanStartOfInterpolation() {
                    assert(this.isStartOfInterpolation());
                    var t2 = this.index;
                    this.advance();
                    this.advance();
                    return new Token(t2, "${");
                };
                _proto3.advance = function advance() {
                    if (++this.index >= this.length) {
                        this.peek = h;
                    } else {
                        this.peek = this.input.charCodeAt(this.index);
                    }
                };
                _proto3.error = function error(t2, e2) {
                    if (e2 === void 0) {
                        e2 = 0;
                    }
                    var i2 = this.index + e2;
                    throw new Error("Lexer Error: " + t2 + " at column " + i2 + " in expression [" + this.input + "]");
                };
                _proto3.isStartOfInterpolation = function isStartOfInterpolation() {
                    if (this.context === r) {
                        return this.peek === w && this.input.charCodeAt(this.index + 1) === et;
                    }
                };
                _createClass(Scanner2, [
                    {
                        key: "context",
                        get: function get() {
                            return this.contextStack[this.contextStack.length - 1];
                        }
                    },
                    {
                        key: "isRootLevelOfStringInterpolationMode",
                        get: function get() {
                            return this.stringInterpolationMode && this.contextStack.length === 1;
                        }
                    }
                ]);
                return Scanner2;
            }();
            var o = [
                "undefined",
                "null",
                "true",
                "false",
                "+",
                "-",
                "*",
                "/",
                "%",
                "^",
                "=",
                "==",
                "===",
                "!=",
                "!==",
                "<",
                ">",
                "<=",
                ">=",
                "&&",
                "||",
                "&",
                "|",
                "!",
                "?"
            ];
            var h = 0;
            var c = 9;
            var p = 10;
            var l = 11;
            var u = 12;
            var f = 13;
            var d = 32;
            var x = 33;
            var v = 34;
            var w = 36;
            var g = 37;
            var k = 38;
            var y = 39;
            var S = 40;
            var C = 41;
            var b = 42;
            var _2 = 43;
            var A = 44;
            var L = 45;
            var I = 46;
            var j = 47;
            var m = 58;
            var M = 59;
            var O = 60;
            var P = 61;
            var q = 62;
            var F = 63;
            var U = 48;
            var W = 57;
            var V = 65;
            var B = 69;
            var K = 90;
            var Z = 91;
            var z = 92;
            var Y = 93;
            var J = 94;
            var D = 95;
            var E = 96;
            var H = 97;
            var G = 101;
            var X = 102;
            var Q = 110;
            var T = 114;
            var $ = 116;
            var N = 117;
            var R = 118;
            var tt = 122;
            var et = 123;
            var it = 124;
            var nt = 125;
            var st = 160;
            function isWhitespace(t2) {
                return t2 >= c && t2 <= d || t2 === st;
            }
            function isIdentifierStart(t2) {
                return H <= t2 && t2 <= tt || V <= t2 && t2 <= K || t2 === D || t2 === w;
            }
            function isIdentifierPart(t2) {
                return H <= t2 && t2 <= tt || V <= t2 && t2 <= K || U <= t2 && t2 <= W || t2 === D || t2 === w;
            }
            function isDigit(t2) {
                return U <= t2 && t2 <= W;
            }
            function isExponentStart(t2) {
                return t2 === G || t2 === B;
            }
            function isExponentSign(t2) {
                return t2 === L || t2 === _2;
            }
            function lexer_unescape(t2) {
                switch(t2){
                    case Q:
                        return p;
                    case X:
                        return u;
                    case T:
                        return f;
                    case $:
                        return c;
                    case R:
                        return l;
                    default:
                        return t2;
                }
            }
            function assert(t2, e2) {
                if (!t2) {
                    throw e2 || "Assertion failed";
                }
            }
            var Unparser = function() {
                function Unparser2(t2) {
                    this.buffer = t2;
                }
                Unparser2.unparse = function unparse(t2) {
                    var e2 = [];
                    var i2 = new Unparser2(e2);
                    t2.accept(i2);
                    return e2.join("");
                };
                var _proto4 = Unparser2.prototype;
                _proto4.write = function write(t2) {
                    this.buffer.push(t2);
                };
                _proto4.writeArgs = function writeArgs(t2) {
                    this.write("(");
                    for(var _e3 = 0, _i = t2.length; _e3 < _i; ++_e3){
                        if (_e3 !== 0) {
                            this.write(",");
                        }
                        t2[_e3].accept(this);
                    }
                    this.write(")");
                };
                _proto4.visitAssign = function visitAssign(t2) {
                    t2.target.accept(this);
                    this.write("=");
                    t2.value.accept(this);
                };
                _proto4.visitConditional = function visitConditional(t2) {
                    t2.condition.accept(this);
                    this.write("?");
                    t2.yes.accept(this);
                    this.write(":");
                    t2.no.accept(this);
                };
                _proto4.visitAccessThis = function visitAccessThis(t2) {
                    if (t2.ancestor === 0) {
                        this.write("$this");
                        return;
                    }
                    this.write("$parent");
                    var e2 = t2.ancestor - 1;
                    while(e2--){
                        this.write(".$parent");
                    }
                };
                _proto4.visitAccessScope = function visitAccessScope(t2) {
                    var e2 = t2.ancestor;
                    while(e2--){
                        this.write("$parent.");
                    }
                    this.write(t2.name);
                };
                _proto4.visitAccessMember = function visitAccessMember(t2) {
                    t2.object.accept(this);
                    this.write("." + t2.name);
                };
                _proto4.visitAccessKeyed = function visitAccessKeyed(t2) {
                    t2.object.accept(this);
                    this.write("[");
                    t2.key.accept(this);
                    this.write("]");
                };
                _proto4.visitCallScope = function visitCallScope(t2) {
                    var e2 = t2.ancestor;
                    while(e2--){
                        this.write("$parent.");
                    }
                    this.write(t2.name);
                    this.writeArgs(t2.args);
                };
                _proto4.visitCallFunction = function visitCallFunction(t2) {
                    t2.func.accept(this);
                    this.writeArgs(t2.args);
                };
                _proto4.visitCallMember = function visitCallMember(t2) {
                    t2.object.accept(this);
                    this.write("." + t2.name);
                    this.writeArgs(t2.args);
                };
                _proto4.visitPrefix = function visitPrefix(t2) {
                    this.write("(" + t2.operation);
                    t2.expression.accept(this);
                    this.write(")");
                };
                _proto4.visitBinary = function visitBinary(t2) {
                    t2.left.accept(this);
                    this.write(t2.operation);
                    t2.right.accept(this);
                };
                _proto4.visitLiteralPrimitive = function visitLiteralPrimitive(t2) {
                    this.write("" + t2.value);
                };
                _proto4.visitLiteralArray = function visitLiteralArray(t2) {
                    var e2 = t2.elements;
                    this.write("[");
                    for(var _t4 = 0, _i2 = e2.length; _t4 < _i2; ++_t4){
                        if (_t4 !== 0) {
                            this.write(",");
                        }
                        e2[_t4].accept(this);
                    }
                    this.write("]");
                };
                _proto4.visitLiteralObject = function visitLiteralObject(t2) {
                    var e2 = t2.keys;
                    var i2 = t2.values;
                    this.write("{");
                    for(var _t5 = 0, _n = e2.length; _t5 < _n; ++_t5){
                        if (_t5 !== 0) {
                            this.write(",");
                        }
                        this.write("'" + e2[_t5] + "':");
                        i2[_t5].accept(this);
                    }
                    this.write("}");
                };
                _proto4.visitLiteralString = function visitLiteralString(t2) {
                    var e2 = t2.value.replace(/'/g, "'");
                    this.write("'" + e2 + "'");
                };
                _proto4.visitStringInterpolation = function visitStringInterpolation(t2) {
                    var e2 = t2.parts;
                    this.write("(''");
                    for(var _t6 = 0, _i3 = e2.length; _t6 < _i3; ++_t6){
                        e2[_t6];
                        this.write("+(");
                        e2[_t6].accept(this);
                        this.write(")");
                    }
                    this.write(")");
                };
                return Unparser2;
            }();
            function has(t2, e2) {
                var i2 = typeof t2;
                return (i2 === "object" || i2 === "function") && e2 in t2;
            }
            function createOverrideContext2(t2, e2) {
                return {
                    bindingContext: t2,
                    parentOverrideContext: e2 || null
                };
            }
            function getContextFor(t2, e2, i2) {
                var n2 = e2.overrideContext;
                if (i2) {
                    while(i2 && n2){
                        i2--;
                        n2 = n2.parentOverrideContext;
                    }
                    if (i2 || !n2) {
                        return void 0;
                    }
                    return has(n2, t2) ? n2 : n2.bindingContext;
                }
                while(n2 && !has(n2, t2) && !(n2.bindingContext && has(n2.bindingContext, t2))){
                    n2 = n2.parentOverrideContext;
                }
                if (n2) {
                    return has(n2, t2) ? n2 : n2.bindingContext;
                }
                return e2.bindingContext || e2.overrideContext;
            }
            function createSimpleScope2(t2, e2) {
                if (e2) {
                    return {
                        bindingContext: t2,
                        overrideContext: createOverrideContext2(t2, createOverrideContext2(e2))
                    };
                }
                return {
                    bindingContext: t2,
                    overrideContext: createOverrideContext2(t2)
                };
            }
            var ast_Expression = function() {
                function ast_Expression2() {
                    this.isAssignable = false;
                }
                var _proto5 = ast_Expression2.prototype;
                _proto5.evaluate = function evaluate3(t2, e2) {
                    throw new Error('Binding expression "' + this + '" cannot be evaluated.');
                };
                _proto5.evaluateWith = function evaluateWith(t2, e2, i2) {
                    return this.evaluate(createSimpleScope2(t2, e2), i2);
                };
                _proto5.assign = function assign(t2, e2) {
                    throw new Error('Binding expression "' + this + '" cannot be assigned to.');
                };
                _proto5.toString = function toString() {
                    return typeof FEATURE_NO_UNPARSER === "undefined" ? Unparser.unparse(this) : Object.prototype.toString.call(this);
                };
                return ast_Expression2;
            }();
            var Assign = function(_ast_Expression) {
                _inheritsLoose(Assign2, _ast_Expression);
                function Assign2(t2, e2) {
                    var _this;
                    _this = _ast_Expression.call(this) || this;
                    _this.target = t2;
                    _this.value = e2;
                    _this.isAssignable = true;
                    return _this;
                }
                var _proto6 = Assign2.prototype;
                _proto6.evaluate = function evaluate3(t2) {
                    return this.target.assign(t2, this.value.evaluate(t2));
                };
                _proto6.accept = function accept(t2) {
                    t2.visitAssign(this);
                };
                _proto6.assign = function assign(t2, e2) {
                    this.value.assign(t2, e2);
                    this.target.assign(t2, e2);
                };
                return Assign2;
            }(ast_Expression);
            var Conditional = function(_ast_Expression2) {
                _inheritsLoose(Conditional2, _ast_Expression2);
                function Conditional2(t2, e2, i2) {
                    var _this2;
                    _this2 = _ast_Expression2.call(this) || this;
                    _this2.condition = t2;
                    _this2.yes = e2;
                    _this2.no = i2;
                    return _this2;
                }
                var _proto7 = Conditional2.prototype;
                _proto7.evaluate = function evaluate3(t2) {
                    return !!this.condition.evaluate(t2) ? this.yes.evaluate(t2) : this.no.evaluate(t2);
                };
                _proto7.accept = function accept(t2) {
                    return t2.visitConditional(this);
                };
                return Conditional2;
            }(ast_Expression);
            var AccessThis = function(_ast_Expression3) {
                _inheritsLoose(AccessThis2, _ast_Expression3);
                function AccessThis2(t2) {
                    var _this3;
                    _this3 = _ast_Expression3.call(this) || this;
                    _this3.ancestor = t2;
                    return _this3;
                }
                var _proto8 = AccessThis2.prototype;
                _proto8.evaluate = function evaluate3(t2) {
                    var e2 = t2.overrideContext;
                    var i2 = this.ancestor;
                    while(i2-- && e2){
                        e2 = e2.parentOverrideContext;
                    }
                    return i2 < 1 && e2 ? e2.bindingContext : void 0;
                };
                _proto8.accept = function accept(t2) {
                    return t2.visitAccessThis(this);
                };
                return AccessThis2;
            }(ast_Expression);
            var ast_AccessScope = function(_ast_Expression4) {
                _inheritsLoose(ast_AccessScope2, _ast_Expression4);
                function ast_AccessScope2(t2, e2) {
                    var _this4;
                    _this4 = _ast_Expression4.call(this) || this;
                    _this4.name = t2;
                    _this4.ancestor = e2;
                    _this4.isAssignable = true;
                    return _this4;
                }
                var _proto9 = ast_AccessScope2.prototype;
                _proto9.evaluate = function evaluate3(t2) {
                    var e2 = getContextFor(this.name, t2, this.ancestor);
                    return e2[this.name];
                };
                _proto9.assign = function assign(t2, e2) {
                    var i2 = getContextFor(this.name, t2, this.ancestor);
                    return i2 ? i2[this.name] = e2 : void 0;
                };
                _proto9.accept = function accept(t2) {
                    return t2.visitAccessScope(this);
                };
                return ast_AccessScope2;
            }(ast_Expression);
            var AccessMember = function(_ast_Expression5) {
                _inheritsLoose(AccessMember2, _ast_Expression5);
                function AccessMember2(t2, e2) {
                    var _this5;
                    _this5 = _ast_Expression5.call(this) || this;
                    _this5.object = t2;
                    _this5.name = e2;
                    _this5.isAssignable = true;
                    return _this5;
                }
                var _proto10 = AccessMember2.prototype;
                _proto10.evaluate = function evaluate3(t2) {
                    var e2 = this.object.evaluate(t2);
                    return e2 === null || e2 === void 0 ? e2 : e2[this.name];
                };
                _proto10.assign = function assign(t2, e2) {
                    var i2 = this.object.evaluate(t2);
                    if (i2 === null || i2 === void 0) {
                        i2 = {};
                        this.object.assign(t2, i2);
                    }
                    i2[this.name] = e2;
                    return e2;
                };
                _proto10.accept = function accept(t2) {
                    return t2.visitAccessMember(this);
                };
                return AccessMember2;
            }(ast_Expression);
            var AccessKeyed = function(_ast_Expression6) {
                _inheritsLoose(AccessKeyed2, _ast_Expression6);
                function AccessKeyed2(t2, e2) {
                    var _this6;
                    _this6 = _ast_Expression6.call(this) || this;
                    _this6.object = t2;
                    _this6.key = e2;
                    _this6.isAssignable = true;
                    return _this6;
                }
                var _proto11 = AccessKeyed2.prototype;
                _proto11.evaluate = function evaluate3(t2) {
                    var e2 = this.object.evaluate(t2);
                    var i2 = this.key.evaluate(t2);
                    return getKeyed(e2, i2);
                };
                _proto11.assign = function assign(t2, e2) {
                    var i2 = this.object.evaluate(t2);
                    var n2 = this.key.evaluate(t2);
                    return setKeyed(i2, n2, e2);
                };
                _proto11.accept = function accept(t2) {
                    return t2.visitAccessKeyed(this);
                };
                return AccessKeyed2;
            }(ast_Expression);
            var ast_CallScope = function(_ast_Expression7) {
                _inheritsLoose(ast_CallScope2, _ast_Expression7);
                function ast_CallScope2(t2, e2, i2) {
                    var _this7;
                    _this7 = _ast_Expression7.call(this) || this;
                    _this7.name = t2;
                    _this7.args = e2;
                    _this7.ancestor = i2;
                    return _this7;
                }
                var _proto12 = ast_CallScope2.prototype;
                _proto12.evaluate = function evaluate3(t2, e2) {
                    var i2 = evalList(t2, this.args);
                    var n2 = getContextFor(this.name, t2, this.ancestor);
                    var s2 = getFunction(n2, this.name, e2);
                    if (s2) {
                        return s2.apply(n2, i2);
                    }
                    return void 0;
                };
                _proto12.accept = function accept(t2) {
                    return t2.visitCallScope(this);
                };
                return ast_CallScope2;
            }(ast_Expression);
            var CallMember = function(_ast_Expression8) {
                _inheritsLoose(CallMember2, _ast_Expression8);
                function CallMember2(t2, e2, i2) {
                    var _this8;
                    _this8 = _ast_Expression8.call(this) || this;
                    _this8.object = t2;
                    _this8.name = e2;
                    _this8.args = i2;
                    return _this8;
                }
                var _proto13 = CallMember2.prototype;
                _proto13.evaluate = function evaluate3(t2, e2) {
                    var i2 = this.object.evaluate(t2);
                    var n2 = evalList(t2, this.args);
                    var s2 = getFunction(i2, this.name, e2);
                    if (s2) {
                        return s2.apply(i2, n2);
                    }
                    return void 0;
                };
                _proto13.accept = function accept(t2) {
                    return t2.visitCallMember(this);
                };
                return CallMember2;
            }(ast_Expression);
            var CallFunction = function(_ast_Expression9) {
                _inheritsLoose(CallFunction2, _ast_Expression9);
                function CallFunction2(t2, e2) {
                    var _this9;
                    _this9 = _ast_Expression9.call(this) || this;
                    _this9.func = t2;
                    _this9.args = e2;
                    return _this9;
                }
                var _proto14 = CallFunction2.prototype;
                _proto14.evaluate = function evaluate3(t2, e2) {
                    var i2 = this.func.evaluate(t2);
                    if (typeof i2 === "function") {
                        return i2.apply(null, evalList(t2, this.args));
                    }
                    if (!e2 && (i2 === null || i2 === void 0)) {
                        return void 0;
                    }
                    throw new Error(this.func + " is not a function");
                };
                _proto14.accept = function accept(t2) {
                    return t2.visitCallFunction(this);
                };
                return CallFunction2;
            }(ast_Expression);
            var Binary = function(_ast_Expression10) {
                _inheritsLoose(Binary2, _ast_Expression10);
                function Binary2(t2, e2, i2) {
                    var _this10;
                    _this10 = _ast_Expression10.call(this) || this;
                    _this10.operation = t2;
                    _this10.left = e2;
                    _this10.right = i2;
                    return _this10;
                }
                var _proto15 = Binary2.prototype;
                _proto15.evaluate = function evaluate3(t2) {
                    var e2 = this.left.evaluate(t2);
                    switch(this.operation){
                        case "&&":
                            return e2 && this.right.evaluate(t2);
                        case "||":
                            return e2 || this.right.evaluate(t2);
                    }
                    var i2 = this.right.evaluate(t2);
                    switch(this.operation){
                        case "==":
                            return e2 == i2;
                        case "===":
                            return e2 === i2;
                        case "!=":
                            return e2 != i2;
                        case "!==":
                            return e2 !== i2;
                    }
                    if (e2 === null || i2 === null || e2 === void 0 || i2 === void 0) {
                        switch(this.operation){
                            case "+":
                                if (e2 !== null && e2 !== void 0) return e2;
                                if (i2 !== null && i2 !== void 0) return i2;
                                return 0;
                            case "-":
                                if (e2 !== null && e2 !== void 0) return e2;
                                if (i2 !== null && i2 !== void 0) return 0 - i2;
                                return 0;
                        }
                    }
                    switch(this.operation){
                        case "+":
                            return autoConvertAdd(e2, i2);
                        case "-":
                            return e2 - i2;
                        case "*":
                            return e2 * i2;
                        case "/":
                            return e2 / i2;
                        case "%":
                            return e2 % i2;
                        case "<":
                            return e2 < i2;
                        case ">":
                            return e2 > i2;
                        case "<=":
                            return e2 <= i2;
                        case ">=":
                            return e2 >= i2;
                        case "^":
                            return e2 ^ i2;
                        case "&":
                            return e2 & i2;
                        case "|":
                            return e2 | i2;
                        case "<<":
                            return e2 << i2;
                        case ">>":
                            return e2 >> i2;
                        case ">>>":
                            return e2 >>> i2;
                    }
                    throw new Error("Internal error [" + this.operation + "] not handled");
                };
                _proto15.accept = function accept(t2) {
                    return t2.visitBinary(this);
                };
                return Binary2;
            }(ast_Expression);
            var PrefixNot = function(_ast_Expression11) {
                _inheritsLoose(PrefixNot2, _ast_Expression11);
                function PrefixNot2(t2, e2) {
                    var _this11;
                    _this11 = _ast_Expression11.call(this) || this;
                    _this11.operation = t2;
                    _this11.expression = e2;
                    return _this11;
                }
                var _proto16 = PrefixNot2.prototype;
                _proto16.evaluate = function evaluate3(t2) {
                    return !this.expression.evaluate(t2);
                };
                _proto16.accept = function accept(t2) {
                    return t2.visitPrefix(this);
                };
                return PrefixNot2;
            }(ast_Expression);
            var LiteralPrimitive = function(_ast_Expression12) {
                _inheritsLoose(LiteralPrimitive2, _ast_Expression12);
                function LiteralPrimitive2(t2) {
                    var _this12;
                    _this12 = _ast_Expression12.call(this) || this;
                    _this12.value = t2;
                    return _this12;
                }
                var _proto17 = LiteralPrimitive2.prototype;
                _proto17.evaluate = function evaluate3(t2) {
                    return this.value;
                };
                _proto17.accept = function accept(t2) {
                    return t2.visitLiteralPrimitive(this);
                };
                return LiteralPrimitive2;
            }(ast_Expression);
            var LiteralString = function(_ast_Expression13) {
                _inheritsLoose(LiteralString2, _ast_Expression13);
                function LiteralString2(t2) {
                    var _this13;
                    _this13 = _ast_Expression13.call(this) || this;
                    _this13.value = t2;
                    return _this13;
                }
                var _proto18 = LiteralString2.prototype;
                _proto18.evaluate = function evaluate3(t2) {
                    return this.value;
                };
                _proto18.accept = function accept(t2) {
                    return t2.visitLiteralString(this);
                };
                return LiteralString2;
            }(ast_Expression);
            var LiteralArray = function(_ast_Expression14) {
                _inheritsLoose(LiteralArray2, _ast_Expression14);
                function LiteralArray2(t2) {
                    var _this14;
                    _this14 = _ast_Expression14.call(this) || this;
                    _this14.elements = t2;
                    return _this14;
                }
                var _proto19 = LiteralArray2.prototype;
                _proto19.evaluate = function evaluate3(t2) {
                    var e2 = this.elements;
                    var i2 = [];
                    for(var _n2 = 0, _s = e2.length; _n2 < _s; ++_n2){
                        i2[_n2] = e2[_n2].evaluate(t2);
                    }
                    return i2;
                };
                _proto19.accept = function accept(t2) {
                    return t2.visitLiteralArray(this);
                };
                return LiteralArray2;
            }(ast_Expression);
            var LiteralObject = function(_ast_Expression15) {
                _inheritsLoose(LiteralObject2, _ast_Expression15);
                function LiteralObject2(t2, e2) {
                    var _this15;
                    _this15 = _ast_Expression15.call(this) || this;
                    _this15.keys = t2;
                    _this15.values = e2;
                    return _this15;
                }
                var _proto20 = LiteralObject2.prototype;
                _proto20.evaluate = function evaluate3(t2) {
                    var e2 = {};
                    var i2 = this.keys;
                    var n2 = this.values;
                    for(var _s2 = 0, _r = i2.length; _s2 < _r; ++_s2){
                        e2[i2[_s2]] = n2[_s2].evaluate(t2);
                    }
                    return e2;
                };
                _proto20.accept = function accept(t2) {
                    return t2.visitLiteralObject(this);
                };
                return LiteralObject2;
            }(ast_Expression);
            var StringInterpolation = function(_ast_Expression16) {
                _inheritsLoose(StringInterpolation2, _ast_Expression16);
                function StringInterpolation2(t2) {
                    var _this16;
                    _this16 = _ast_Expression16.call(this) || this;
                    _this16.parts = t2;
                    return _this16;
                }
                var _proto21 = StringInterpolation2.prototype;
                _proto21.evaluate = function evaluate3(t2) {
                    var e2 = this.parts;
                    var i2 = "";
                    for(var _n3 = 0, _s3 = e2.length; _n3 < _s3; ++_n3){
                        i2 += e2[_n3].evaluate(t2);
                    }
                    return i2;
                };
                _proto21.accept = function accept(t2) {
                    return t2.visitStringInterpolation(this);
                };
                return StringInterpolation2;
            }(ast_Expression);
            function evalList(t2, e2) {
                var i2 = e2.length;
                var n2 = [];
                for(var _s4 = 0; _s4 < i2; _s4++){
                    n2[_s4] = e2[_s4].evaluate(t2);
                }
                return n2;
            }
            function autoConvertAdd(t2, e2) {
                if (t2 !== null && e2 !== null) {
                    if (typeof t2 === "string" && typeof e2 !== "string") {
                        return t2 + e2.toString();
                    }
                    if (typeof t2 !== "string" && typeof e2 === "string") {
                        return t2.toString() + e2;
                    }
                    return t2 + e2;
                }
                if (t2 !== null) {
                    return t2;
                }
                if (e2 !== null) {
                    return e2;
                }
                return 0;
            }
            function getFunction(t2, e2, i2) {
                var n2 = t2 === null || t2 === void 0 ? null : t2[e2];
                if (typeof n2 === "function") {
                    return n2;
                }
                if (!i2 && (n2 === null || n2 === void 0)) {
                    return null;
                }
                throw new Error(e2 + " is not a function");
            }
            function getKeyed(t2, e2) {
                if (Array.isArray(t2)) {
                    return t2[parseInt(e2, 10)];
                } else if (t2) {
                    return t2[e2];
                } else if (t2 === null || t2 === void 0) {
                    return void 0;
                }
                return t2[e2];
            }
            function setKeyed(t2, e2, i2) {
                if (Array.isArray(t2)) {
                    var _n4 = parseInt(e2, 10);
                    if (t2.length <= _n4) {
                        t2.length = _n4 + 1;
                    }
                    t2[_n4] = i2;
                } else {
                    t2[e2] = i2;
                }
                return i2;
            }
            var rt = new Token(-1, null);
            var parser_Parser = function() {
                function parser_Parser2() {
                    this.cache = {};
                    this.lexer = new Lexer();
                }
                var _proto22 = parser_Parser2.prototype;
                _proto22.parse = function parse(t2, e2) {
                    if (e2 === void 0) {
                        e2 = {};
                    }
                    t2 = t2 || "";
                    var i2 = t2 + ":" + JSON.stringify(e2);
                    if (!this.cache[i2]) {
                        var _n5 = new parser_ParserImplementation(this.lexer, t2, e2);
                        this.cache[i2] = _n5.parseExpression();
                        var _s5 = "";
                        for(var _t7 = 0, _e4 = _n5.tokens.length; _t7 < _e4; ++_t7){
                            _s5 += _n5.tokens[_t7].text;
                        }
                        this.cache[i2].toString = function() {
                            return _s5;
                        };
                    }
                    return this.cache[i2];
                };
                return parser_Parser2;
            }();
            var parser_ParserImplementation = function() {
                function parser_ParserImplementation2(t2, e2, i2) {
                    if (i2 === void 0) {
                        i2 = {};
                    }
                    this.rejectAssignment = i2.rejectAssignment || false;
                    this.stringInterpolationMode = i2.stringInterpolationMode || false;
                    this.index = 0;
                    this.input = e2;
                    this.tokens = t2.lex(e2, {
                        stringInterpolationMode: this.stringInterpolationMode
                    });
                }
                var _proto23 = parser_ParserImplementation2.prototype;
                _proto23.parseExpression = function parseExpression() {
                    if (this.index === 0 && this.stringInterpolationMode) {
                        return this.parseStringInterpolation(true);
                    }
                    var t2 = this.peek.index;
                    var e2 = this.parseConditional();
                    while(this.peek.text === "="){
                        if (this.rejectAssignment) {
                            this.error("assignment is not allowed");
                        }
                        if (!e2.isAssignable) {
                            var _e5 = this.index < this.tokens.length ? this.peek.index : this.input.length;
                            var _i5 = this.input.substring(t2, _e5);
                            this.error("Expression " + _i5 + " is not assignable");
                        }
                        this.expect("=");
                        e2 = new Assign(e2, this.parseConditional());
                    }
                    return e2;
                };
                _proto23.parseConditional = function parseConditional() {
                    var t2 = this.peek.index;
                    var e2 = this.parseLogicalOr();
                    if (this.optional("?")) {
                        var _i6 = this.parseExpression();
                        if (!this.optional(":")) {
                            var _e6 = this.index < this.tokens.length ? this.peek.index : this.input.length;
                            var _i7 = this.input.substring(t2, _e6);
                            this.error("Conditional expression " + _i7 + " requires all 3 expressions");
                        }
                        var _n6 = this.parseExpression();
                        e2 = new Conditional(e2, _i6, _n6);
                    }
                    return e2;
                };
                _proto23.parseLogicalOr = function parseLogicalOr() {
                    var t2 = this.parseLogicalAnd();
                    while(this.optional("||")){
                        t2 = new Binary("||", t2, this.parseLogicalAnd());
                    }
                    return t2;
                };
                _proto23.parseLogicalAnd = function parseLogicalAnd() {
                    var t2 = this.parseEquality();
                    while(this.optional("&&")){
                        t2 = new Binary("&&", t2, this.parseEquality());
                    }
                    return t2;
                };
                _proto23.parseEquality = function parseEquality() {
                    var t2 = this.parseRelational();
                    while(true){
                        if (this.optional("==")) {
                            t2 = new Binary("==", t2, this.parseRelational());
                        } else if (this.optional("!=")) {
                            t2 = new Binary("!=", t2, this.parseRelational());
                        } else if (this.optional("===")) {
                            t2 = new Binary("===", t2, this.parseRelational());
                        } else if (this.optional("!==")) {
                            t2 = new Binary("!==", t2, this.parseRelational());
                        } else {
                            return t2;
                        }
                    }
                };
                _proto23.parseRelational = function parseRelational() {
                    var t2 = this.parseAdditive();
                    while(true){
                        if (this.optional("<")) {
                            t2 = new Binary("<", t2, this.parseAdditive());
                        } else if (this.optional(">")) {
                            t2 = new Binary(">", t2, this.parseAdditive());
                        } else if (this.optional("<=")) {
                            t2 = new Binary("<=", t2, this.parseAdditive());
                        } else if (this.optional(">=")) {
                            t2 = new Binary(">=", t2, this.parseAdditive());
                        } else {
                            return t2;
                        }
                    }
                };
                _proto23.parseAdditive = function parseAdditive() {
                    var t2 = this.parseMultiplicative();
                    while(true){
                        if (this.optional("+")) {
                            t2 = new Binary("+", t2, this.parseMultiplicative());
                        } else if (this.optional("-")) {
                            t2 = new Binary("-", t2, this.parseMultiplicative());
                        } else {
                            return t2;
                        }
                    }
                };
                _proto23.parseMultiplicative = function parseMultiplicative() {
                    var t2 = this.parsePrefix();
                    while(true){
                        if (this.optional("*")) {
                            t2 = new Binary("*", t2, this.parsePrefix());
                        } else if (this.optional("%")) {
                            t2 = new Binary("%", t2, this.parsePrefix());
                        } else if (this.optional("/")) {
                            t2 = new Binary("/", t2, this.parsePrefix());
                        } else {
                            return t2;
                        }
                    }
                };
                _proto23.parsePrefix = function parsePrefix() {
                    if (this.optional("+")) {
                        return this.parsePrefix();
                    } else if (this.optional("-")) {
                        return new Binary("-", new LiteralPrimitive(0), this.parsePrefix());
                    } else if (this.optional("!")) {
                        return new PrefixNot("!", this.parsePrefix());
                    }
                    return this.parseAccessOrCallMember();
                };
                _proto23.parseAccessOrCallMember = function parseAccessOrCallMember() {
                    var t2 = this.parsePrimary();
                    while(true){
                        if (this.optional(".")) {
                            var _e7 = this.peek.text;
                            this.advance();
                            if (this.optional("(")) {
                                var _i8 = this.parseExpressionList(")");
                                this.expect(")");
                                if (t2 instanceof AccessThis) {
                                    t2 = new ast_CallScope(_e7, _i8, t2.ancestor);
                                } else {
                                    t2 = new CallMember(t2, _e7, _i8);
                                }
                            } else {
                                if (t2 instanceof AccessThis) {
                                    t2 = new ast_AccessScope(_e7, t2.ancestor);
                                } else {
                                    t2 = new AccessMember(t2, _e7);
                                }
                            }
                        } else if (this.optional("[")) {
                            var _e8 = this.parseExpression();
                            this.expect("]");
                            t2 = new AccessKeyed(t2, _e8);
                        } else if (this.optional("(")) {
                            var _e9 = this.parseExpressionList(")");
                            this.expect(")");
                            t2 = new CallFunction(t2, _e9);
                        } else {
                            return t2;
                        }
                    }
                };
                _proto23.parseStringInterpolation = function parseStringInterpolation(t2) {
                    var e2 = [];
                    while(t2 ? this.peek !== rt : this.peek !== rt && this.peek.text !== "`"){
                        if (this.optional("${")) {
                            var _t8 = this.parseExpression();
                            this.expect("}");
                            e2.push(_t8);
                        } else if (typeof this.peek.value === "string") {
                            var _t9 = this.peek.value;
                            this.advance();
                            e2.push(new LiteralString(_t9));
                        }
                    }
                    return new StringInterpolation(e2);
                };
                _proto23.parsePrimary = function parsePrimary() {
                    if (this.optional("(")) {
                        var _t10 = this.parseExpression();
                        this.expect(")");
                        return _t10;
                    } else if (this.optional("`")) {
                        var _t11 = this.parseStringInterpolation();
                        this.expect("`");
                        return _t11;
                    } else if (this.optional("null")) {
                        return new LiteralPrimitive(null);
                    } else if (this.optional("undefined")) {
                        return new LiteralPrimitive(void 0);
                    } else if (this.optional("true")) {
                        return new LiteralPrimitive(true);
                    } else if (this.optional("false")) {
                        return new LiteralPrimitive(false);
                    } else if (this.optional("[")) {
                        var _t12 = this.parseExpressionList("]");
                        this.expect("]");
                        return new LiteralArray(_t12);
                    } else if (this.peek.text === "{") {
                        return this.parseObject();
                    } else if (this.peek.key !== null && this.peek.key !== void 0) {
                        return this.parseAccessOrCallScope();
                    } else if (this.peek.value !== null && this.peek.value !== void 0) {
                        var _t13 = this.peek.value;
                        this.advance();
                        return _t13 instanceof String || typeof _t13 === "string" ? new LiteralString(_t13) : new LiteralPrimitive(_t13);
                    } else if (this.index >= this.tokens.length) {
                        throw new Error("Unexpected end of expression: " + this.input);
                    } else {
                        this.error("Unexpected token " + this.peek.text);
                    }
                };
                _proto23.parseAccessOrCallScope = function parseAccessOrCallScope() {
                    var t2 = this.peek.key;
                    this.advance();
                    if (t2 === "$this") {
                        return new AccessThis(0);
                    }
                    var e2 = 0;
                    while(t2 === "$parent"){
                        e2++;
                        if (this.optional(".")) {
                            t2 = this.peek.key;
                            this.advance();
                        } else if (this.peek === rt || this.peek.text === "(" || this.peek.text === ")" || this.peek.text === "[" || this.peek.text === "}" || this.peek.text === ",") {
                            return new AccessThis(e2);
                        } else {
                            this.error("Unexpected token " + this.peek.text);
                        }
                    }
                    if (this.optional("(")) {
                        var _i9 = this.parseExpressionList(")");
                        this.expect(")");
                        return new ast_CallScope(t2, _i9, e2);
                    }
                    return new ast_AccessScope(t2, e2);
                };
                _proto23.parseObject = function parseObject() {
                    var t2 = [];
                    var e2 = [];
                    this.expect("{");
                    if (this.peek.text !== "}") {
                        do {
                            var _i10 = this.peek;
                            var _n7 = _i10.value;
                            t2.push(typeof _n7 === "string" ? _n7 : _i10.text);
                            this.advance();
                            if (_i10.key && (this.peek.text === "," || this.peek.text === "}")) {
                                --this.index;
                                e2.push(this.parseAccessOrCallScope());
                            } else {
                                this.expect(":");
                                e2.push(this.parseExpression());
                            }
                        }while (this.optional(","))
                    }
                    this.expect("}");
                    return new LiteralObject(t2, e2);
                };
                _proto23.parseExpressionList = function parseExpressionList(t2) {
                    var e2 = [];
                    if (this.peek.text !== t2) {
                        do {
                            e2.push(this.parseExpression());
                        }while (this.optional(","))
                    }
                    return e2;
                };
                _proto23.optional = function optional(t2) {
                    if (this.peek.text === t2) {
                        this.advance();
                        return true;
                    }
                    return false;
                };
                _proto23.expect = function expect(t2) {
                    if (this.peek.text === t2) {
                        this.advance();
                    } else {
                        this.error("Missing expected " + t2);
                    }
                };
                _proto23.advance = function advance() {
                    this.index++;
                };
                _proto23.error = function error(t2) {
                    var e2 = this.index < this.tokens.length ? "at column " + (this.tokens[this.index].index + 1) + " in" : "at the end of the expression";
                    throw new Error("Parser Error: " + t2 + " " + e2 + " [" + this.input + "]");
                };
                _createClass(parser_ParserImplementation2, [
                    {
                        key: "peek",
                        get: function get() {
                            return this.index < this.tokens.length ? this.tokens[this.index] : rt;
                        }
                    }
                ]);
                return parser_ParserImplementation2;
            }();
            i.d(e, "Parser", function() {
                return parser_Parser;
            });
            i.d(e, "createOverrideContext", function() {
                return createOverrideContext2;
            });
            i.d(e, "createSimpleScope", function() {
                return createSimpleScope2;
            });
            i.d(e, "evaluate", function() {
                return evaluate2;
            });
            i.d(e, "evaluateStringInterpolation", function() {
                return evaluateStringInterpolation2;
            });
            var at = new parser_Parser();
            function evaluate2(t2, e2, i2, n2) {
                var s2 = at.parse(t2, n2);
                return s2.evaluateWith(e2, i2);
            }
            function evaluateStringInterpolation2(t2, e2, i2, n2) {
                if (n2 === void 0) {
                    n2 = {};
                }
                return evaluate2(t2, e2, i2, _extends(_extends({}, n2), {}, {
                    stringInterpolationMode: true
                }));
            }
        }
    }, function(t) {
        !function() {
            t.r = function(t2) {
                if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                    Object.defineProperty(t2, Symbol.toStringTag, {
                        value: "Module"
                    });
                }
                Object.defineProperty(t2, "__esModule", {
                    value: true
                });
            };
        }();
        !function() {
            var e = Object.prototype.hasOwnProperty;
            t.d = function(t2, i, n) {
                if (!e.call(t2, i)) {
                    Object.defineProperty(t2, i, {
                        enumerable: true,
                        get: n
                    });
                }
            };
        }();
    });
});
getDefaultExportFromCjs2(dist);
dist.Parser;
dist.createOverrideContext;
dist.createSimpleScope;
var evaluate = dist.evaluate;
dist.evaluateStringInterpolation;
class PipelineCondition {
    constructor(exp){
        this.exp = exp;
    }
    satisfies(msg, mode, context) {
        let status = msg.status;
        if (mode.conditional && msg.data && msg.data.mimeType === "application/json") {
            const err = JSON.parse(msg.data.asStringSync());
            if (err['_errorStatus'] !== undefined) {
                status = err._errorStatus;
            }
        }
        const mime = msg.data?.mimeType;
        const isJson1 = isJson(mime);
        const isText1 = isText(mime);
        const isManage = msg.getHeader('X-Restspace-Request-Mode') === 'manage';
        const callerUrl = context?.callerUrl;
        const msgValues = {
            name: msg.name,
            mime,
            isJson: isJson1,
            isText: isText1,
            isBinary: !(isJson1 || isText1),
            isManage,
            status,
            ok: status === 200 || status === 0,
            method: context.callerMethod?.toUpperCase(),
            subpath: callerUrl && (callerUrl.subPathElementCount === null ? callerUrl.servicePathElements : callerUrl.subPathElements),
            header: (hdr)=>msg.getHeader(hdr),
            body: ()=>{
                if (!msg.data) {
                    return {};
                } else if (msg.data.data instanceof ArrayBuffer) {
                    return JSON.parse(msg.data.asStringSync());
                } else {
                    throw new Error('Pipeline condition based on message body of message with stream data');
                }
            },
            query: ()=>{
                Object.fromEntries(Object.entries(msg.url.query).map(([k, v])=>[
                        k,
                        v[0]
                    ]));
            }
        };
        return !!evaluate(this.exp, msgValues);
    }
    static scan(str, start) {
        let pos = start;
        pos = skipWhitespace(str, pos);
        if (pos >= str.length) return [
            null,
            -1
        ];
        [, pos] = matchFirst(str, pos, [
            "if ("
        ]);
        if (pos < 0) return [
            null,
            -1
        ];
        const endPos = scanCloseJsBracket(str, pos, "()");
        if (endPos < 0) return [
            null,
            -1
        ];
        return [
            new PipelineCondition(str.substring(pos, endPos - 1)),
            endPos
        ];
    }
    exp;
}
class ExactBytesTransformStream extends TransformStream {
    #read = 0;
    constructor(size){
        super({
            transform: (chunk, controller)=>{
                if (this.#read + chunk.byteLength > size) {
                    throw new RangeError(`Exceeded byte size limit of '${size}'`);
                } else {
                    this.#read += chunk.byteLength;
                    controller.enqueue(chunk);
                }
            },
            flush: ()=>{
                if (this.#read < size) {
                    throw new RangeError(`Did not receive expected size of '${size}'`);
                }
            }
        });
    }
}
function write(entries, options = {}) {
    const { signal  } = options;
    const ts = new TransformStream();
    async function run() {
        const centralDirectoryFileHeaders = [];
        let totalBytesWritten = 0;
        let totalFilesWritten = 0;
        for await (const entry of entries){
            signal?.throwIfAborted();
            const result = await writeLocalFileEntry(entry, ts.writable, totalBytesWritten, signal);
            if (!options.omitCentralDirectory) {
                centralDirectoryFileHeaders.push(...result.centralDirectoryFileHeaders());
            }
            totalBytesWritten += result.bytesWritten;
            totalFilesWritten += 1;
        }
        const writer = ts.writable.getWriter();
        try {
            if (!options.omitCentralDirectory) {
                const offsetOfCentralDirectory = totalBytesWritten;
                for (const part of centralDirectoryFileHeaders){
                    signal?.throwIfAborted();
                    await writer.ready;
                    await writer.write(part);
                    totalBytesWritten += part.byteLength;
                }
                signal?.throwIfAborted();
                await writer.ready;
                const ending = new Uint8Array(56 + 20 + 22);
                const zip64EndOfCentralDirectoryRecord = new DataView(ending.buffer, 0, 56);
                zip64EndOfCentralDirectoryRecord.setUint32(0, 0x06064b50, true);
                zip64EndOfCentralDirectoryRecord.setBigUint64(4, BigInt(56 - 12), true);
                zip64EndOfCentralDirectoryRecord.setUint16(12, 45, true);
                zip64EndOfCentralDirectoryRecord.setUint16(14, 45, true);
                zip64EndOfCentralDirectoryRecord.setBigUint64(24, BigInt(totalFilesWritten), true);
                zip64EndOfCentralDirectoryRecord.setBigUint64(32, BigInt(totalFilesWritten), true);
                const sizeOfCentralDirectory = totalBytesWritten - offsetOfCentralDirectory;
                zip64EndOfCentralDirectoryRecord.setBigUint64(40, BigInt(sizeOfCentralDirectory), true);
                zip64EndOfCentralDirectoryRecord.setBigUint64(48, BigInt(offsetOfCentralDirectory), true);
                const zip64EndOfCentralDirectoryLocator = new DataView(ending.buffer, 56, 20);
                zip64EndOfCentralDirectoryLocator.setUint32(0, 0x07064b50, true);
                const offsetOfZip64EndOfCentralDirectoryRecord = totalBytesWritten;
                zip64EndOfCentralDirectoryLocator.setBigUint64(8, BigInt(offsetOfZip64EndOfCentralDirectoryRecord), true);
                zip64EndOfCentralDirectoryLocator.setUint32(16, 1, true);
                const endOfCentralDirectoryRecord = new DataView(ending.buffer, 56 + 20, 22);
                endOfCentralDirectoryRecord.setUint32(0, 0x06054b50, true);
                endOfCentralDirectoryRecord.setUint16(8, 0xffff, true);
                endOfCentralDirectoryRecord.setUint16(10, 0xffff, true);
                endOfCentralDirectoryRecord.setUint32(12, 0xffffffff, true);
                endOfCentralDirectoryRecord.setUint32(16, 0xffffffff, true);
                await writer.write(ending);
            }
            signal?.throwIfAborted();
            await writer.ready;
            await writer.close();
        } finally{
            writer.releaseLock();
        }
    }
    run().catch((err)=>{
        ts.writable.abort(err);
    });
    return ts.readable;
}
async function writeLocalFileEntry(entry, writable, lfhOffset, signal) {
    let bytesWritten = 0;
    let fileName;
    const writer = writable.getWriter();
    try {
        await writer.ready;
        const localFileHeaderStart = new Uint8Array(30);
        const headerDv = new DataView(localFileHeaderStart.buffer, localFileHeaderStart.byteOffset, localFileHeaderStart.byteLength);
        headerDv.setUint32(0, 0x04034b50, true);
        headerDv.setUint16(4, 45, true);
        if (entry.type === "file" && entry.body.compressed) {
            headerDv.setUint16(8, 8, true);
        }
        if (entry.type === "file") {
            headerDv.setUint32(14, entry.body.originalCrc, true);
        }
        headerDv.setUint32(18, 0xffffffff, true);
        headerDv.setUint32(22, 0xffffffff, true);
        fileName = new TextEncoder().encode(entry.name);
        if (fileName.byteLength >= 2 ** 16) {
            throw new Error(`Filename is too long (${fileName.byteLength} bytes)`);
        }
        headerDv.setUint16(26, fileName.byteLength, true);
        const extraField = createExtraField(entry);
        headerDv.setUint16(28, extraField?.byteLength ?? 0, true);
        bytesWritten += localFileHeaderStart.byteLength + fileName.byteLength;
        await writer.write(localFileHeaderStart);
        await writer.write(fileName);
        if (extraField) {
            bytesWritten += extraField.byteLength;
            await writer.write(extraField);
        }
    } finally{
        writer.releaseLock();
    }
    if (entry.type === "file") {
        const len = entry.body.compressed ? entry.body.compressedSize : entry.body.originalSize;
        await entry.body.stream.pipeThrough(new ExactBytesTransformStream(len), {
            signal
        }).pipeTo(writable, {
            preventClose: true,
            signal
        });
        bytesWritten += len;
    }
    const centralDirectoryFileHeaders = ()=>{
        const centralHeader = new Uint8Array(46);
        const centralHeaderDv = new DataView(centralHeader.buffer, centralHeader.byteOffset, centralHeader.byteLength);
        centralHeaderDv.setUint32(0, 0x02014b50, true);
        centralHeaderDv.setUint16(4, 45, true);
        centralHeaderDv.setUint16(6, 45, true);
        centralHeaderDv.setUint16(8, 0, true);
        if (entry.type === "file" && entry.body.compressed) {
            centralHeaderDv.setUint16(10, 8, true);
        }
        if (entry.type === "file") {
            centralHeaderDv.setUint32(16, entry.body.originalCrc, true);
        }
        centralHeaderDv.setUint32(20, 0xffffffff, true);
        centralHeaderDv.setUint32(24, 0xffffffff, true);
        centralHeaderDv.setUint16(28, fileName.byteLength, true);
        const centralHeaderExtraField = createExtraField(entry, lfhOffset);
        centralHeaderDv.setUint16(30, centralHeaderExtraField?.byteLength ?? 0, true);
        centralHeaderDv.setUint32(42, 0xffffffff, true);
        const result = [
            centralHeader,
            fileName
        ];
        if (centralHeaderExtraField) {
            result.push(centralHeaderExtraField);
        }
        return result;
    };
    return {
        bytesWritten,
        centralDirectoryFileHeaders
    };
}
function createExtraField(entry, lfhOffset) {
    const originalSize = entry.type === "file" ? entry.body.originalSize : 0;
    const compressedSize = entry.type === "file" ? entry.body.compressed ? entry.body.compressedSize : entry.body.originalSize : 0;
    const result = new Uint8Array(4 + 16 + (lfhOffset == null ? 0 : 8) + 4 + 13);
    const resultDv = new DataView(result.buffer, result.byteOffset, result.byteLength);
    let pos = 0;
    resultDv.setUint16(0, 0x1, true);
    resultDv.setBigUint64(4, BigInt(originalSize), true);
    resultDv.setBigUint64(12, BigInt(compressedSize), true);
    if (lfhOffset == null) {
        resultDv.setUint16(2, 16, true);
        pos = 20;
    } else {
        resultDv.setUint16(2, 24, true);
        resultDv.setBigUint64(20, BigInt(lfhOffset), true);
        pos = 28;
    }
    if (entry.extendedTimestamps) {
        resultDv.setUint16(pos, 0x5455, true);
        let xLen = 1;
        let flags = 0;
        if (entry.extendedTimestamps.modifyTime) {
            flags |= 0x1;
            resultDv.setUint32(pos + 4 + xLen, entry.extendedTimestamps.modifyTime.getTime() / 1000, true);
            xLen += 4;
        }
        if (entry.extendedTimestamps.accessTime) {
            flags |= 0x2;
            resultDv.setUint32(pos + 4 + xLen, entry.extendedTimestamps.accessTime.getTime() / 1000, true);
            xLen += 4;
        }
        if (entry.extendedTimestamps.createTime) {
            flags |= 0x4;
            resultDv.setUint32(pos + 4 + xLen, entry.extendedTimestamps.createTime.getTime() / 1000, true);
            xLen += 4;
        }
        resultDv.setUint16(pos + 2, xLen, true);
        resultDv.setUint8(pos + 4, flags);
        pos += 4 + xLen;
    }
    if (pos === 0) {
        return undefined;
    }
    return result.slice(0, pos);
}
function crc32(arr) {
    if (typeof arr === "string") {
        arr = new TextEncoder().encode(arr);
    }
    let crc = -1, i, j, l, temp, poly = 0xEDB88320;
    for(i = 0, l = arr.length; i < l; i += 1){
        temp = (crc ^ arr[i]) & 0xff;
        for(j = 0; j < 8; j += 1){
            if ((temp & 1) === 1) {
                temp = temp >>> 1 ^ poly;
            } else {
                temp = temp >>> 1;
            }
        }
        crc = crc >>> 8 ^ temp;
    }
    return numberToHex(crc ^ -1);
}
class Crc32Stream {
    bytes = [];
    poly = 0xEDB88320;
    crc = 0 ^ -1;
    encoder = new TextEncoder();
    #crc32 = "";
    constructor(){
        this.reset();
    }
    get crc32() {
        return this.#crc32;
    }
    reset() {
        this.#crc32 = "";
        this.crc = 0 ^ -1;
        for(let n = 0; n < 256; n += 1){
            let c = n;
            for(let k = 0; k < 8; k += 1){
                if (c & 1) {
                    c = this.poly ^ c >>> 1;
                } else {
                    c = c >>> 1;
                }
            }
            this.bytes[n] = c >>> 0;
        }
    }
    append(arr) {
        if (typeof arr === "string") {
            arr = this.encoder.encode(arr);
        }
        let crc = this.crc;
        for(let i = 0, l = arr.length; i < l; i += 1){
            crc = crc >>> 8 ^ this.bytes[(crc ^ arr[i]) & 0xff];
        }
        this.crc = crc;
        this.#crc32 = numberToHex(crc ^ -1);
        return this.#crc32;
    }
}
function numberToHex(n) {
    return (n >>> 0).toString(16).padStart(8, "0");
}
async function* messageProcessor(firstMsg, msgs) {
    let msgResult = firstMsg;
    while(!msgResult.done){
        const msg = msgResult.value;
        if (msg && msg.data) {
            const buf = await msg.data.asArrayBuffer();
            const stream = msg.data.asReadable();
            if (buf && stream) {
                let name = msg.name;
                if (name && name.includes('.')) {
                    name = name.split('.').slice(-1)[0];
                }
                name = name || msg.url.resourceName;
                const nameMime = getType(name);
                if (nameMime === null) {
                    name = addExtension(name, msg.data.mimeType);
                }
                const entry = {
                    type: "file",
                    name,
                    body: {
                        stream,
                        originalSize: buf?.byteLength,
                        originalCrc: parseInt(crc32(new Uint8Array(buf)), 16)
                    }
                };
                yield entry;
            }
        }
        msgResult = await msgs.next();
    }
}
async function zip(msgs) {
    let first = {
        value: null,
        done: false
    };
    while(!(first.value && first.value.hasData() || first.done)){
        first = await msgs.next();
    }
    if (first.done) return null;
    const stream = write(messageProcessor(first, msgs));
    const msgOut = first.value;
    if (msgOut.name && msgOut.name.includes('.')) {
        msgOut.name = msgOut.name.split('.').slice(0, -1).join('.');
    }
    const filename = msgOut.url.isDirectory ? last(msgOut.url.pathElements) : msgOut.url.resourceName;
    return msgOut.copy().setData(stream, 'application/zip').setHeader('Content-Disposition', 'attachment; filename="' + filename + '.zip"');
}
async function jsonObject(msgs) {
    let outerName = '';
    let first = {
        value: null
    };
    while(!(first.value && first.value.hasData() || first.done)){
        first = await msgs.next();
    }
    if (first.done) return null;
    const { readable , writable  } = new TransformStream();
    const writer = writable.getWriter();
    const writeString = (data)=>writer.write(new TextEncoder().encode(data));
    let length = -1;
    const writeProperty = (name, val)=>{
        writeString(`  "${name}": `);
        writeString(val);
        if (length > -2 && /^\d+$/.test(name)) {
            const itemIdx = parseInt(name) + 1;
            if (itemIdx > length) length = itemIdx;
        } else if (name === 'length') {
            length = -2;
        }
    };
    writeString("{\n");
    const writeMsg = async (msg)=>{
        if (!msg) return;
        if (msg.name === "$this") {
            if (!isJson(msg.data?.mimeType)) {
                writeString('  "data": ');
                writeString('"');
                writeString(await msg.data?.asString() || '');
                writeString('"');
            } else {
                const obj = await msg.data?.asJson();
                if (typeof obj !== 'object') {
                    writeProperty("data", JSON.stringify(obj));
                } else {
                    let first = true;
                    for(const prop in obj){
                        if (first) {
                            first = false;
                        } else {
                            writeString(',\n');
                        }
                        writeProperty(prop, JSON.stringify(obj[prop]));
                    }
                }
            }
        } else {
            let name = msg.name.replace('"', '');
            if (name.includes('.')) {
                const lastDot = name.lastIndexOf('.');
                const newOuterName = name.substring(0, lastDot);
                if (newOuterName && !outerName) {
                    outerName = newOuterName;
                } else if (newOuterName !== outerName) {
                    outerName = "_mixed_";
                }
                name = name.substring(lastDot + 1);
            }
            if (msg.data?.data === null) {
                writeProperty(name, "null");
                return;
            }
            if (isJson(msg.data?.mimeType)) {
                writeProperty(name, await msg.data?.asString() || '');
            } else {
                writeProperty(name, '"' + jsonQuote(await msg.data?.asString() || '') + '"');
            }
        }
    };
    await writeMsg(first.value);
    msgs.next().then(async (second)=>{
        let res = second;
        while(!res.done){
            if (res.value && res.value.hasData()) {
                writeString(",\n");
                await writeMsg(res.value);
            }
            const nextMsgPromise = msgs.next();
            res = await nextMsgPromise;
        }
        if (length >= 0) {
            writeString(",\n");
            writeProperty('length', length.toString());
        }
        writeString("\n}");
        writer.close();
    });
    return first.value && first.value.setData(readable, 'application/json').setName(outerName) || null;
}
const GZIP_HEADER = Uint8Array.from([
    31,
    139,
    8,
    0,
    0,
    0,
    0,
    0,
    0,
    0
]);
function decompressDeflateRaw(stream, crc, uncompressedSize) {
    return stream.pipeThrough(new TransformStream({
        start (controller) {
            controller.enqueue(GZIP_HEADER);
        },
        flush (controller) {
            const tmp = new DataView(new ArrayBuffer(8));
            tmp.setUint32(0, crc, true);
            tmp.setUint32(4, uncompressedSize, true);
            controller.enqueue(new Uint8Array(tmp.buffer));
        }
    })).pipeThrough(new DecompressionStream("gzip"));
}
class DeferredPromise {
    promise;
    resolve;
    reject;
    constructor(){
        let resolve = undefined;
        let reject = undefined;
        this.promise = new Promise((_resolve, _reject)=>{
            resolve = _resolve;
            reject = _reject;
        });
        this.resolve = resolve;
        this.reject = reject;
    }
}
class PartialReader {
    static fromStream(stream) {
        try {
            return new BYOBPartialReader(stream.getReader({
                mode: "byob"
            }));
        } catch (err) {
            if (err instanceof TypeError || err instanceof RangeError) {
                return new DefaultPartialReader(stream.getReader());
            } else {
                throw err;
            }
        }
    }
    async readAmount(size) {
        const firstPart = await this.limitedRead(size);
        if (firstPart.done) {
            return new Uint8Array(0);
        }
        if (firstPart.value.length < size) {
            const result = new Uint8Array(size);
            result.set(firstPart.value, 0);
            let bytesRead = firstPart.value.length;
            while(bytesRead < size){
                const part = await this.limitedRead(size - bytesRead);
                if (part.done) {
                    return result.subarray(0, bytesRead);
                }
                result.set(part.value, bytesRead);
                bytesRead += part.value.length;
            }
            return result;
        } else {
            return firstPart.value;
        }
    }
    async readAmountStrict(size) {
        const data = await this.readAmount(size);
        if (data.byteLength < size) {
            throw new Error("Stream completed early during exactRead() call");
        }
        return data;
    }
    async skipAmount(size) {
        let bytesLeft = size;
        while(bytesLeft > 0){
            const part = await this.limitedRead(bytesLeft);
            if (part.done) {
                break;
            }
            bytesLeft -= part.value.byteLength;
        }
    }
    streamAmount(size) {
        const deferred = new DeferredPromise();
        const result = {
            stream: null,
            consumed: false,
            onConsumed: deferred.promise
        };
        let bytesLeft = size;
        result.stream = new ReadableStream({
            pull: async (controller)=>{
                try {
                    const part = await this.limitedRead(bytesLeft);
                    if (part.done) {
                        result.consumed = true;
                        controller.close();
                        deferred.resolve();
                    } else {
                        bytesLeft -= part.value.byteLength;
                        controller.enqueue(part.value);
                        if (bytesLeft <= 0) {
                            result.consumed = true;
                            controller.close();
                            deferred.resolve();
                        }
                    }
                } catch (err) {
                    deferred.reject(err);
                    throw err;
                }
            },
            cancel: async (_reason)=>{
                try {
                    await this.skipAmount(bytesLeft);
                } catch (err) {
                    deferred.reject(err);
                    throw err;
                }
                result.consumed = true;
                deferred.resolve();
            }
        });
        return result;
    }
}
class DefaultPartialReader extends PartialReader {
    #reader;
    #leftOvers;
    constructor(reader){
        super();
        this.#reader = reader;
    }
    cancel(reason) {
        return this.#reader.cancel(reason);
    }
    async limitedRead(maxSize) {
        let value;
        if (this.#leftOvers) {
            value = this.#leftOvers;
            this.#leftOvers = undefined;
        } else {
            const result = await this.#reader.read();
            if (result.done) {
                return result;
            }
            value = result.value;
        }
        if (value.byteLength > maxSize) {
            this.#leftOvers = value.subarray(maxSize);
            value = value.subarray(0, maxSize);
        }
        return {
            done: false,
            value
        };
    }
}
class BYOBPartialReader extends PartialReader {
    #reader;
    constructor(reader){
        super();
        this.#reader = reader;
    }
    cancel(reason) {
        return this.#reader.cancel(reason);
    }
    async readAmount(size) {
        let bytesRead = 0;
        let view = new Uint8Array(size);
        while(bytesRead < size){
            const result = await this.#reader.read(view);
            if (result.done) {
                if (!result.value) {
                    throw new Error("Stream was closed while reading");
                }
                return new Uint8Array(result.value.buffer, 0, bytesRead);
            }
            bytesRead += result.value.byteLength;
            view = new Uint8Array(result.value.buffer, bytesRead);
        }
        return new Uint8Array(view.buffer);
    }
    limitedRead(maxSize) {
        return this.#reader.read(new Uint8Array(maxSize));
    }
    async skipAmount(size) {
        let bytesLeft = size;
        let trashBuffer = new Uint8Array(Math.min(bytesLeft, 2048));
        while(bytesLeft > 0){
            const part = await this.#reader.read(trashBuffer);
            if (part.done) {
                break;
            }
            bytesLeft -= part.value.byteLength;
            trashBuffer = new Uint8Array(part.value.buffer);
            if (bytesLeft < trashBuffer.byteLength) {
                trashBuffer = trashBuffer.subarray(0, bytesLeft);
            }
        }
    }
    streamAmount(size) {
        const deferred = new DeferredPromise();
        const result = {
            stream: null,
            consumed: false,
            onConsumed: deferred.promise
        };
        let bytesLeft = size;
        result.stream = new ReadableStream({
            type: "bytes",
            autoAllocateChunkSize: 2048,
            pull: async (controller)=>{
                try {
                    if (bytesLeft <= 0) {
                        result.consumed = true;
                        controller.close();
                        controller.byobRequest.respond(0);
                        deferred.resolve();
                        return;
                    }
                    const view = controller.byobRequest.view;
                    const dest = new Uint8Array(view.buffer, view.byteOffset, Math.min(view.byteLength, bytesLeft));
                    const part = await this.#reader.read(dest);
                    if (part.done) {
                        result.consumed = true;
                        controller.close();
                        controller.byobRequest.respondWithNewView(part.value);
                        deferred.resolve();
                    } else {
                        bytesLeft -= part.value.byteLength;
                        controller.byobRequest.respondWithNewView(part.value);
                    }
                } catch (err) {
                    deferred.reject(err);
                    throw err;
                }
            },
            cancel: async (_reason)=>{
                try {
                    await this.skipAmount(bytesLeft);
                } catch (err) {
                    deferred.reject(err);
                    throw err;
                }
                result.consumed = true;
                deferred.resolve();
            }
        });
        return result;
    }
}
function parseExtraField(extraField) {
    const result = {};
    for (const { tag , data  } of splitExtraFieldParts(extraField)){
        switch(tag){
            case 0x1:
                {
                    const dv = new DataView(data.buffer, data.byteOffset, data.byteLength);
                    const originalSize = Number(dv.getBigUint64(0, true));
                    const compressedSize = Number(dv.getBigUint64(8, true));
                    result.zip64 = {
                        originalSize,
                        compressedSize
                    };
                    break;
                }
            case 0x5455:
                {
                    const dv1 = new DataView(data.buffer, data.byteOffset, data.byteLength);
                    const flags = dv1.getUint8(0);
                    const timestamps = {};
                    let pos = 1;
                    if (flags & 0x1) {
                        timestamps.modifyTime = new Date(dv1.getInt32(pos, true) * 1000);
                        pos += 4;
                    }
                    if (flags & 0x2) {
                        timestamps.accessTime = new Date(dv1.getInt32(pos, true) * 1000);
                        pos += 4;
                    }
                    if (flags & 0x4) {
                        timestamps.createTime = new Date(dv1.getInt32(pos, true) * 1000);
                        pos += 4;
                    }
                    result.extendedTimestamps = timestamps;
                    break;
                }
        }
    }
    return result;
}
function* splitExtraFieldParts(extraField) {
    const dv = new DataView(extraField.buffer, extraField.byteOffset, extraField.byteLength);
    let pos = 0;
    while(extraField.length >= pos + 4){
        const tag = dv.getUint16(pos, true);
        const len = dv.getUint16(pos + 2, true);
        if (pos + 4 + len > extraField.length) {
            throw new Error("Invalid extra field");
        }
        const data = extraField.subarray(pos + 4, pos + 4 + len);
        yield {
            tag,
            data
        };
        pos += 4 + len;
    }
}
async function* read(stream, options = {}) {
    const { signal  } = options;
    const textDecoder = new TextDecoder();
    const partialReader = PartialReader.fromStream(stream);
    const cancelPartialReader = (err)=>{
        partialReader.cancel(err);
    };
    signal?.addEventListener("abort", cancelPartialReader, {
        once: true
    });
    try {
        while(true){
            signal?.throwIfAborted();
            const header = await partialReader.readAmount(30);
            if (header.length === 0) {
                break;
            }
            if (header.length !== 30) {
                throw new Error("stream ended unexpectedly");
            }
            const headerDv = new DataView(header.buffer, header.byteOffset, header.byteLength);
            const signature = headerDv.getInt32(0, true);
            if (signature === 0x02014b50) {
                break;
            }
            if (signature !== 0x04034b50) {
                throw new Error("Bad signature. The input may not be a zip file, or it may not start with a local file header, which read() requires.");
            }
            const version = headerDv.getUint16(4, true);
            if (version > 45) {
                throw new Error(`File requires to high of version to extract (${version})`);
            }
            const flags = headerDv.getUint16(6, true);
            if (flags & 0x1 || flags & 0x40) {
                throw new Error("Encrypted files are not supported");
            }
            if (flags & 0x8) {
                throw new Error("read() does not support zip files using data descriptors");
            }
            if (flags & 0x20) {
                throw new Error("Patch data is not supported");
            }
            const compressionMethod = headerDv.getUint16(8, true);
            const crc = headerDv.getUint32(14, true);
            let compressedSize = headerDv.getUint32(18, true);
            let uncompressedSize = headerDv.getUint32(22, true);
            const fileNameLength = headerDv.getUint16(26, true);
            const extraFieldLength = headerDv.getUint16(28, true);
            const fileName = textDecoder.decode(await partialReader.readAmountStrict(fileNameLength));
            let type;
            if (fileName.endsWith("/")) {
                type = "directory";
            } else {
                type = "file";
            }
            const extraFieldRaw = await partialReader.readAmountStrict(extraFieldLength);
            const parsedExtraFields = parseExtraField(extraFieldRaw);
            if (parsedExtraFields.zip64) {
                compressedSize = parsedExtraFields.zip64.compressedSize;
                uncompressedSize = parsedExtraFields.zip64.originalSize;
            }
            let bodyMethodFinished;
            const body = {
                stream () {
                    if (bodyMethodFinished) {
                        throw new Error("body already used");
                    }
                    const bodyStream = partialReader.streamAmount(compressedSize);
                    bodyMethodFinished = bodyStream.onConsumed;
                    let stream = bodyStream.stream.pipeThrough(new ExactBytesTransformStream(compressedSize), {
                        signal
                    });
                    switch(compressionMethod){
                        case 0:
                            break;
                        case 8:
                            {
                                stream = decompressDeflateRaw(stream, crc, uncompressedSize);
                                break;
                            }
                        default:
                            {
                                throw new Error(`Unknown compression method: ${compressionMethod}`);
                            }
                    }
                    return stream;
                },
                autodrain () {
                    if (bodyMethodFinished) {
                        throw new Error("body already used");
                    }
                    bodyMethodFinished = partialReader.skipAmount(compressedSize);
                }
            };
            signal?.throwIfAborted();
            if (type !== undefined) {
                if (type === "file") {
                    yield {
                        type,
                        name: fileName,
                        extendedTimestamps: parsedExtraFields.extendedTimestamps,
                        originalSize: uncompressedSize,
                        compressedSize,
                        crc,
                        body
                    };
                } else {
                    body.autodrain();
                    yield {
                        type,
                        name: fileName,
                        extendedTimestamps: parsedExtraFields.extendedTimestamps
                    };
                }
            } else {
                body.autodrain();
            }
            if (!bodyMethodFinished) {
                throw new Error("The body property of entry must be streamed or autodrained before continuing iteration");
            }
            await bodyMethodFinished;
        }
        await partialReader.cancel();
    } catch (err) {
        await partialReader.cancel(err);
        throw err;
    } finally{
        signal?.removeEventListener("abort", cancelPartialReader);
    }
    signal?.throwIfAborted();
}
function unzip(msg) {
    const queue = new AsyncQueue();
    if (!msg.data) return queue;
    const readable = msg.data.asReadable();
    if (!readable) return queue;
    (async ()=>{
        try {
            for await (const entry of read(readable)){
                const newUrl = msg.url.copy();
                newUrl.servicePath = newUrl.servicePath + entry.name;
                if (entry.type === 'file') {
                    const entryMsg = msg.copy().setName(entry.name).setData(entry.body.stream(), getType(entry.name) || '').setUrl(newUrl).removeHeader('transfer-encoding');
                    queue.enqueue(entryMsg);
                }
            }
            queue.close();
        } catch (err) {
            queue.enqueue(err).close();
        }
    })();
    return queue;
}
var PipelineAction;
(function(PipelineAction) {
    PipelineAction[PipelineAction["stop"] = 0] = "stop";
    PipelineAction[PipelineAction["next"] = 1] = "next";
    PipelineAction[PipelineAction["end"] = 2] = "end";
})(PipelineAction || (PipelineAction = {}));
class PipelineMode {
    mode = "serial";
    fail = PipelineAction.next;
    succeed = PipelineAction.next;
    conditional = false;
    tee = false;
    teeWait = false;
    constructor(parentModeOrToken){
        if (parentModeOrToken === undefined) return;
        if (parentModeOrToken instanceof PipelineMode) {
            const isParallel = parentModeOrToken.mode === "serial" && !parentModeOrToken.conditional;
            if (isParallel) {
                this.mode = "parallel";
                this.fail = PipelineAction.stop;
            }
        } else if (parentModeOrToken) {
            const parts = parentModeOrToken.split(' ');
            switch(parts[0]){
                case "parallel":
                    this.mode = "parallel";
                    break;
                case "conditional":
                    this.mode = "serial";
                    this.succeed = PipelineAction.end;
                    this.fail = PipelineAction.next;
                    this.conditional = true;
                    return;
                case "tee":
                    this.mode = "serial";
                    this.tee = true;
                    return;
                case "teeWait":
                    this.mode = "serial";
                    this.tee = true;
                    this.teeWait = true;
                    return;
                default:
                    this.mode = "serial";
                    break;
            }
            if (parts.length > 1) {
                this.fail = PipelineAction[parts[1]];
            } else if (this.mode === "parallel") {
                this.fail = PipelineAction.stop;
            }
            if (parts.length > 2) this.succeed = PipelineAction[parts[2]];
            const errors = this.getErrors();
            if (errors.length) throw new Error('Bad pipelne mode: ' + errors.join(','));
        }
    }
    getErrors() {
        const errors = [];
        if (this.fail === undefined) errors.push('unknown fail mode');
        if (this.succeed === undefined) errors.push('unknown succeed mode');
        if (this.mode === "parallel" && this.fail !== PipelineAction.stop && this.succeed !== PipelineAction.next) errors.push("parallel mode must stop on fail and do next on succeed");
        if (this.succeed !== PipelineAction.next && this.fail !== PipelineAction.next) errors.push("either succeed or fail must do next or pipeline cannot execute");
        if (this.succeed === PipelineAction.stop) errors.push("cannot stop on success or pipeline always fails");
        return errors;
    }
    allowedMidstreamChangeTo(mode) {
        return this.mode !== 'parallel' && mode.mode !== 'parallel';
    }
    static isValid(token) {
        return [
            "parallel",
            "serial",
            "conditional",
            "tee",
            "teeWait"
        ].includes(token.split(' ')[0]);
    }
    static parallel() {
        const mode = new PipelineMode();
        mode.mode = "parallel";
        return mode;
    }
    toString() {
        if (this.conditional) return "conditional";
        return `${this.mode} ${this.fail} ${this.succeed}`;
    }
    copy() {
        const newMode = new PipelineMode();
        newMode.mode = this.mode;
        newMode.fail = this.fail;
        newMode.succeed = this.succeed;
        newMode.conditional = this.conditional;
        return newMode;
    }
}
function limitConcurrency(concurrency) {
    if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency >= 0)) {
        throw new TypeError('Expected `concurrency` to be a number from 0 and up');
    }
    if (concurrency === 0) concurrency = Number.POSITIVE_INFINITY;
    const queue = new ArrayQueue();
    let activeCount = 0;
    const next = ()=>{
        activeCount--;
        if (queue.length > 0) {
            queue.dequeue()();
        }
    };
    const run = async (fn, resolve, args)=>{
        activeCount++;
        const result = (async ()=>fn(...args))();
        resolve(result);
        try {
            await result;
        } catch  {}
        next();
    };
    const enqueue = (fn, resolve, args)=>{
        queue.enqueue(run.bind(undefined, fn, resolve, args));
        (async ()=>{
            await Promise.resolve();
            if (activeCount < concurrency && queue.length > 0) {
                queue.dequeue()();
            }
        })();
    };
    const generator = (fn, ...args)=>new Promise((resolve)=>{
            enqueue(fn, resolve, args);
        });
    Object.defineProperties(generator, {
        activeCount: {
            get: ()=>activeCount
        },
        pendingCount: {
            get: ()=>queue.length
        },
        clearQueue: {
            value: ()=>{
                while(queue.length)queue.pop();
            }
        }
    });
    return generator;
}
function pipelineInitializerIntoContext(step) {
    const words = step.split(' ').map((word)=>word.trim());
    switch(words[0]){
        case "targetHost":
            {
                if (words.length < 2) return null;
                let host = words[1];
                if (!(host.startsWith("http") && host.includes("//"))) host = "http://" + host;
                if (!Url.urlRegex.test(host)) return null;
                const targetHost = new Url(host);
                return {
                    targetHost
                };
            }
        case "trace":
            {
                return {
                    trace: true,
                    traceOutputs: {}
                };
            }
        case "concurrency":
            {
                if (words.length < 2) return null;
                const limit = parseInt(words[1]);
                if (isNaN(limit)) return null;
                return {
                    concurrencyLimiter: limitConcurrency(limit)
                };
            }
        default:
            {
                return null;
            }
    }
}
var commonjsGlobal1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function createCommonjsModule4(fn, basedir, module) {
    return module = {
        path: basedir,
        exports: {},
        require: function(path, base) {
            return commonjsRequire4(path, base === void 0 || base === null ? module.path : base);
        }
    }, fn(module, module.exports), module.exports;
}
function commonjsRequire4() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var dayjs_min = createCommonjsModule4(function(module, exports) {
    !function(t, e) {
        module.exports = e();
    }(commonjsGlobal1, function() {
        var t = "millisecond", e = "second", n = "minute", r = "hour", i = "day", s = "week", u = "month", a = "quarter", o = "year", f = "date", h = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[^0-9]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, c = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, d = {
            name: "en",
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_")
        }, $ = function(t2, e2, n2) {
            var r2 = String(t2);
            return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
        }, l = {
            s: $,
            z: function(t2) {
                var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
                return (e2 <= 0 ? "+" : "-") + $(r2, 2, "0") + ":" + $(i2, 2, "0");
            },
            m: function t2(e2, n2) {
                if (e2.date() < n2.date()) return -t2(n2, e2);
                var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, u), s2 = n2 - i2 < 0, a2 = e2.clone().add(r2 + (s2 ? -1 : 1), u);
                return +(-(r2 + (n2 - i2) / (s2 ? i2 - a2 : a2 - i2)) || 0);
            },
            a: function(t2) {
                return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
            },
            p: function(h2) {
                return ({
                    M: u,
                    y: o,
                    w: s,
                    d: i,
                    D: f,
                    h: r,
                    m: n,
                    s: e,
                    ms: t,
                    Q: a
                })[h2] || String(h2 || "").toLowerCase().replace(/s$/, "");
            },
            u: function(t2) {
                return t2 === void 0;
            }
        }, y = "en", M = {};
        M[y] = d;
        var m = function(t2) {
            return t2 instanceof S;
        }, D = function(t2, e2, n2) {
            var r2;
            if (!t2) return y;
            if (typeof t2 == "string") M[t2] && (r2 = t2), e2 && (M[t2] = e2, r2 = t2);
            else {
                var i2 = t2.name;
                M[i2] = t2, r2 = i2;
            }
            return !n2 && r2 && (y = r2), r2 || !n2 && y;
        }, v = function(t2, e2) {
            if (m(t2)) return t2.clone();
            var n2 = typeof e2 == "object" ? e2 : {};
            return n2.date = t2, n2.args = arguments, new S(n2);
        }, g = l;
        g.l = D, g.i = m, g.w = function(t2, e2) {
            return v(t2, {
                locale: e2.$L,
                utc: e2.$u,
                x: e2.$x,
                $offset: e2.$offset
            });
        };
        var S = function() {
            function d2(t2) {
                this.$L = D(t2.locale, null, true), this.parse(t2);
            }
            var $2 = d2.prototype;
            return $2.parse = function(t2) {
                this.$d = function(t3) {
                    var e2 = t3.date, n2 = t3.utc;
                    if (e2 === null) return new Date(NaN);
                    if (g.u(e2)) return new Date();
                    if (e2 instanceof Date) return new Date(e2);
                    if (typeof e2 == "string" && !/Z$/i.test(e2)) {
                        var r2 = e2.match(h);
                        if (r2) {
                            var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                            return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
                        }
                    }
                    return new Date(e2);
                }(t2), this.$x = t2.x || {}, this.init();
            }, $2.init = function() {
                var t2 = this.$d;
                this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
            }, $2.$utils = function() {
                return g;
            }, $2.isValid = function() {
                return !(this.$d.toString() === "Invalid Date");
            }, $2.isSame = function(t2, e2) {
                var n2 = v(t2);
                return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
            }, $2.isAfter = function(t2, e2) {
                return v(t2) < this.startOf(e2);
            }, $2.isBefore = function(t2, e2) {
                return this.endOf(e2) < v(t2);
            }, $2.$g = function(t2, e2, n2) {
                return g.u(t2) ? this[e2] : this.set(n2, t2);
            }, $2.unix = function() {
                return Math.floor(this.valueOf() / 1e3);
            }, $2.valueOf = function() {
                return this.$d.getTime();
            }, $2.startOf = function(t2, a2) {
                var h2 = this, c2 = !!g.u(a2) || a2, d3 = g.p(t2), $3 = function(t3, e2) {
                    var n2 = g.w(h2.$u ? Date.UTC(h2.$y, e2, t3) : new Date(h2.$y, e2, t3), h2);
                    return c2 ? n2 : n2.endOf(i);
                }, l2 = function(t3, e2) {
                    return g.w(h2.toDate()[t3].apply(h2.toDate("s"), (c2 ? [
                        0,
                        0,
                        0,
                        0
                    ] : [
                        23,
                        59,
                        59,
                        999
                    ]).slice(e2)), h2);
                }, y2 = this.$W, M2 = this.$M, m2 = this.$D, D2 = "set" + (this.$u ? "UTC" : "");
                switch(d3){
                    case o:
                        return c2 ? $3(1, 0) : $3(31, 11);
                    case u:
                        return c2 ? $3(1, M2) : $3(0, M2 + 1);
                    case s:
                        var v2 = this.$locale().weekStart || 0, S2 = (y2 < v2 ? y2 + 7 : y2) - v2;
                        return $3(c2 ? m2 - S2 : m2 + (6 - S2), M2);
                    case i:
                    case f:
                        return l2(D2 + "Hours", 0);
                    case r:
                        return l2(D2 + "Minutes", 1);
                    case n:
                        return l2(D2 + "Seconds", 2);
                    case e:
                        return l2(D2 + "Milliseconds", 3);
                    default:
                        return this.clone();
                }
            }, $2.endOf = function(t2) {
                return this.startOf(t2, false);
            }, $2.$set = function(s2, a2) {
                var h2, c2 = g.p(s2), d3 = "set" + (this.$u ? "UTC" : ""), $3 = (h2 = {}, h2[i] = d3 + "Date", h2[f] = d3 + "Date", h2[u] = d3 + "Month", h2[o] = d3 + "FullYear", h2[r] = d3 + "Hours", h2[n] = d3 + "Minutes", h2[e] = d3 + "Seconds", h2[t] = d3 + "Milliseconds", h2)[c2], l2 = c2 === i ? this.$D + (a2 - this.$W) : a2;
                if (c2 === u || c2 === o) {
                    var y2 = this.clone().set(f, 1);
                    y2.$d[$3](l2), y2.init(), this.$d = y2.set(f, Math.min(this.$D, y2.daysInMonth())).$d;
                } else $3 && this.$d[$3](l2);
                return this.init(), this;
            }, $2.set = function(t2, e2) {
                return this.clone().$set(t2, e2);
            }, $2.get = function(t2) {
                return this[g.p(t2)]();
            }, $2.add = function(t2, a2) {
                var f2, h2 = this;
                t2 = Number(t2);
                var c2 = g.p(a2), d3 = function(e2) {
                    var n2 = v(h2);
                    return g.w(n2.date(n2.date() + Math.round(e2 * t2)), h2);
                };
                if (c2 === u) return this.set(u, this.$M + t2);
                if (c2 === o) return this.set(o, this.$y + t2);
                if (c2 === i) return d3(1);
                if (c2 === s) return d3(7);
                var $3 = (f2 = {}, f2[n] = 6e4, f2[r] = 36e5, f2[e] = 1e3, f2)[c2] || 1, l2 = this.$d.getTime() + t2 * $3;
                return g.w(l2, this);
            }, $2.subtract = function(t2, e2) {
                return this.add(-1 * t2, e2);
            }, $2.format = function(t2) {
                var e2 = this;
                if (!this.isValid()) return "Invalid Date";
                var n2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", r2 = g.z(this), i2 = this.$locale(), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = i2.weekdays, f2 = i2.months, h2 = function(t3, r3, i3, s3) {
                    return t3 && (t3[r3] || t3(e2, n2)) || i3[r3].substr(0, s3);
                }, d3 = function(t3) {
                    return g.s(s2 % 12 || 12, t3, "0");
                }, $3 = i2.meridiem || function(t3, e3, n3) {
                    var r3 = t3 < 12 ? "AM" : "PM";
                    return n3 ? r3.toLowerCase() : r3;
                }, l2 = {
                    YY: String(this.$y).slice(-2),
                    YYYY: this.$y,
                    M: a2 + 1,
                    MM: g.s(a2 + 1, 2, "0"),
                    MMM: h2(i2.monthsShort, a2, f2, 3),
                    MMMM: h2(f2, a2),
                    D: this.$D,
                    DD: g.s(this.$D, 2, "0"),
                    d: String(this.$W),
                    dd: h2(i2.weekdaysMin, this.$W, o2, 2),
                    ddd: h2(i2.weekdaysShort, this.$W, o2, 3),
                    dddd: o2[this.$W],
                    H: String(s2),
                    HH: g.s(s2, 2, "0"),
                    h: d3(1),
                    hh: d3(2),
                    a: $3(s2, u2, true),
                    A: $3(s2, u2, false),
                    m: String(u2),
                    mm: g.s(u2, 2, "0"),
                    s: String(this.$s),
                    ss: g.s(this.$s, 2, "0"),
                    SSS: g.s(this.$ms, 3, "0"),
                    Z: r2
                };
                return n2.replace(c, function(t3, e3) {
                    return e3 || l2[t3] || r2.replace(":", "");
                });
            }, $2.utcOffset = function() {
                return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
            }, $2.diff = function(t2, f2, h2) {
                var c2, d3 = g.p(f2), $3 = v(t2), l2 = 6e4 * ($3.utcOffset() - this.utcOffset()), y2 = this - $3, M2 = g.m(this, $3);
                return M2 = (c2 = {}, c2[o] = M2 / 12, c2[u] = M2, c2[a] = M2 / 3, c2[s] = (y2 - l2) / 6048e5, c2[i] = (y2 - l2) / 864e5, c2[r] = y2 / 36e5, c2[n] = y2 / 6e4, c2[e] = y2 / 1e3, c2)[d3] || y2, h2 ? M2 : g.a(M2);
            }, $2.daysInMonth = function() {
                return this.endOf(u).$D;
            }, $2.$locale = function() {
                return M[this.$L];
            }, $2.locale = function(t2, e2) {
                if (!t2) return this.$L;
                var n2 = this.clone(), r2 = D(t2, e2, true);
                return r2 && (n2.$L = r2), n2;
            }, $2.clone = function() {
                return g.w(this.$d, this);
            }, $2.toDate = function() {
                return new Date(this.valueOf());
            }, $2.toJSON = function() {
                return this.isValid() ? this.toISOString() : null;
            }, $2.toISOString = function() {
                return this.$d.toISOString();
            }, $2.toString = function() {
                return this.$d.toUTCString();
            }, d2;
        }(), p2 = S.prototype;
        return v.prototype = p2, [
            [
                "$ms",
                t
            ],
            [
                "$s",
                e
            ],
            [
                "$m",
                n
            ],
            [
                "$H",
                r
            ],
            [
                "$W",
                i
            ],
            [
                "$M",
                u
            ],
            [
                "$y",
                o
            ],
            [
                "$D",
                f
            ]
        ].forEach(function(t2) {
            p2[t2[1]] = function(e2) {
                return this.$g(e2, t2[0], t2[1]);
            };
        }), v.extend = function(t2, e2) {
            return t2.$i || (t2(e2, S, v), t2.$i = true), v;
        }, v.locale = D, v.isDayjs = m, v.unix = function(t2) {
            return v(1e3 * t2);
        }, v.en = M[y], v.Ls = M, v.p = {}, v;
    });
});
dayjs_min.Ls;
dayjs_min.en;
dayjs_min.extend;
dayjs_min.isDayjs;
dayjs_min.locale;
dayjs_min.p;
dayjs_min.unix;
const arrayToFunction = (arr, transformHelper)=>{
    if (arr.length === 0) return '';
    let functionName = arr[0];
    if (!functionName.endsWith('()')) return '';
    functionName = functionName.slice(0, -2);
    const args = [];
    for(let i = 1; i < arr.length; i++){
        if (Array.isArray(arr[i])) {
            const arrayFunc = arrayToFunction(arr[i], transformHelper);
            if (arrayFunc) args.push(arrayFunc);
        } else if (typeof arr[i] === 'object') {
            let objectStr = JSON.stringify(arr[i]);
            args.push(objectStr);
        } else if (typeof arr[i] === 'string') {
            const expArgs = transformHelper[`${functionName}_expArgs`];
            let param = arr[i];
            if (expArgs && expArgs.indexOf(i - 1) >= 0) {
                param = `"${arr[i].replace(/"/g, '\\"')}"`;
            }
            args.push(param);
        } else {
            args.push(arr[i].toString());
        }
    }
    return `${functionName}(${args.join(', ')})`;
};
const doEvaluate = (expression, context, helper)=>{
    try {
        return evaluate(expression, context, helper);
    } catch (err) {
        throw SyntaxError('Transform failed', {
            cause: err,
            fileName: expression
        });
    }
};
const transformation = (transformObject, data, url = new Url('/'), name = '')=>{
    const transformHelper = {
        Math: Math,
        transformMap: (list, transformObject)=>!list ? [] : Array.from(list, (item)=>transformation(transformObject, Object.assign({}, data, item), url, name)),
        expressionReduce: (list, init, expression)=>!list ? init : Array.from(list).reduce((partial, item)=>doEvaluate(expression, partial, Object.assign({}, transformHelper, data, item)), init),
        expressionReduce_expArgs: [
            2
        ],
        expressionMap: (list, expression)=>!list ? [] : Array.from(list).map((item)=>doEvaluate(expression, item, Object.assign({}, transformHelper, data))),
        expressionMap_expArgs: [
            1
        ],
        expressionFilter: (list, expression)=>!list ? [] : Array.from(list).filter((item)=>doEvaluate(expression, item, Object.assign({}, transformHelper, data))),
        expressionFilter_expArgs: [
            1
        ],
        expressionFind: (list, expression)=>!list ? null : Array.from(list).find((item)=>doEvaluate(expression, item, Object.assign({}, transformHelper, data))),
        expressionFind_expArgs: [
            1
        ],
        expressionSort: (list, expression, dir)=>!list ? null : Array.from(list).sort((a, b)=>{
                const ctx = Object.assign({}, transformHelper, data);
                const expA = doEvaluate(expression, a, ctx);
                const expB = doEvaluate(expression, b, ctx);
                const res = expA == expB ? 0 : expA < expB ? -1 : 1;
                return dir === 'desc' ? -res : res;
            }),
        expressionSort_expArgs: [
            1
        ],
        unique: (list)=>!list ? [] : [
                ...new Set(Array.from(list))
            ],
        pathCombine,
        pathPattern: (pattern, decode)=>resolvePathPatternWithUrl(pattern, url, data, name, decode),
        newDate: (...args)=>args.length === 0 ? new Date() : args.length === 1 ? typeof args[0] === 'number' ? new Date(args[0]) : dayjs_min(args[0]).toDate() : new Date(args[0], args[1], args[2], args[3], args[4], args[5], args[6]),
        formatDate: (date, format)=>format === 'forQuery' ? `datetime'${dayjs_min(date).format().slice(0, -6)}'` : dayjs_min(date).format(format),
        propsToList: (obj, keyProp)=>Object.entries(obj).map(([key, val])=>{
                val[keyProp || '$key'] = key;
                return val;
            }),
        literal: (obj)=>obj,
        merge: (val0, val1)=>{
            return Object.assign({}, val0, val1);
        },
        parseInt: (s, radix)=>parseInt(s, radix),
        parseFloat: (s)=>parseFloat(s),
        uuid: ()=>crypto.randomUUID()
    };
    if (typeof transformObject === 'string') {
        return doEvaluate(transformObject, data, transformHelper);
    } else if (Array.isArray(transformObject)) {
        if (transformObject.length === 0 || typeof transformObject[0] !== 'string' || !transformObject[0].endsWith("()")) {
            return transformObject.map((item)=>transformation(item, data, url, name));
        }
        const expr = arrayToFunction(transformObject, transformHelper);
        console.log('expr ' + expr);
        const arrResult = doEvaluate(expr, data, transformHelper);
        return arrResult;
    } else {
        let transformed = {};
        const selfObject = transformObject['$this'] || transformObject['.'];
        if (selfObject) {
            transformed = shallowCopy(transformation(selfObject, data, url, name));
        }
        for(const key in transformObject){
            if (key === '.' || key === '$this') continue;
            doTransformKey(key, 0, data, transformed, url, transformObject[key], name);
        }
        return rectifyObject(transformed);
    }
};
const rectifyObject = (obj)=>{
    let newObj = obj;
    if ('length' in obj && !Array.isArray(obj)) {
        newObj = Array.from(obj);
    }
    return newObj;
};
const doTransformKey = (key, keyStart, input, output, url, subTransform, name)=>{
    let [match, newKeyStart] = scanFirst(key, keyStart, [
        '.',
        '[',
        '{'
    ]);
    if (newKeyStart < 0) {
        const effectiveKey = key.slice(keyStart);
        output[effectiveKey] = shallowCopy(transformation(subTransform, input, url, name));
    } else if (match === '.') {
        const keyPart = key.slice(keyStart, newKeyStart - 1).trim();
        if (keyStart === 0 && !(keyPart in input)) return;
        if (!(keyPart in output)) {
            output[keyPart] = {};
        } else {
            output[keyPart] = shallowCopy(output[keyPart]);
        }
        console.log(`recursing path, new start: ${newKeyStart}, new output: ${JSON.stringify(output[keyPart])}`);
        doTransformKey(key, newKeyStart, input, output[keyPart], url, subTransform, name);
    } else if (match === '[' || match === '{') {
        const keyPart1 = key.slice(keyStart, newKeyStart - 1).trim();
        let newOutput = output;
        if (keyPart1) {
            if (!(keyPart1 in output)) {
                output[keyPart1] = match === '[' ? [] : {};
            } else {
                output[keyPart1] = shallowCopy(output[keyPart1]);
            }
            newOutput = output[keyPart1];
        }
        let indexName = upTo(key, match === "[" ? "]" : "}", newKeyStart);
        newKeyStart += indexName.length + 1;
        indexName = indexName.trim();
        const remainingKey = key.slice(newKeyStart + 1);
        const transformOrRecurse = (input, index)=>{
            if (remainingKey) {
                doTransformKey(remainingKey, 0, input, newOutput[index], url, subTransform, name);
            } else {
                newOutput[index] = shallowCopy(transformation(subTransform, input, url, name));
            }
        };
        if (match === '[' && '0' <= indexName[0] && indexName[0] <= '9') {
            transformOrRecurse(input, parseInt(indexName));
        } else if (match === '[') {
            let list = newOutput;
            if (!Array.isArray(newOutput)) {
                if (typeof newOutput === 'object') {
                    list = Object.entries(newOutput).map(([k, v])=>typeof v === 'object' ? {
                            ...v,
                            "$key": k
                        } : v);
                    for(const k in newOutput)delete newOutput[k];
                } else {
                    return;
                }
            }
            const loopItem = {};
            list.forEach((item, idx)=>{
                loopItem['value'] = item;
                loopItem['index'] = idx;
                const newInput = {
                    ...input,
                    ...item,
                    outer: input.outer || input,
                    [indexName]: loopItem
                };
                transformOrRecurse(newInput, idx);
            });
            if (!('length' in newOutput)) newOutput.length = list.length;
            if (!remainingKey) {
                for(let i = newOutput.length - 1; i >= 0; i--){
                    if (newOutput[i] === undefined) newOutput.splice(i, 1);
                }
            }
        } else if (match === '{') {
            Object.entries(newOutput).forEach(([key, value])=>{
                const newInput = {
                    ...input,
                    ...value,
                    "$key": key,
                    outer: input.outer || input,
                    [indexName]: {
                        key,
                        value
                    }
                };
                transformOrRecurse(newInput, key);
            });
            if (!remainingKey) {
                newOutput = Object.fromEntries(Object.entries(newOutput).filter(([_, v])=>v !== undefined));
            }
        }
    }
};
class PipelineTransform {
    constructor(transform){
        this.transform = transform;
    }
    async execute(msg, context) {
        const jsonIn = msg.data ? await msg.data.asJson() : {};
        let transJson = null;
        try {
            transJson = transformation(this.transform, jsonIn, context.callerUrl || msg.url, msg.name);
        } catch (err) {
            if (err instanceof SyntaxError) {
                const errx = err;
                return msg.setStatus(400, `${errx.message} at: ${errx.filename} cause: ${errx.cause}`);
            }
        }
        if (context.trace) {
            context.traceOutputs[context.path.join('.')] = transJson;
        }
        return msg.copy().setDataJson(transJson);
    }
    static isValid(item) {
        return typeof item === 'object';
    }
    transform;
}
const copyPipelineContext = (context)=>{
    return {
        ...context,
        path: [
            ...context.path
        ]
    };
};
const { Deno: Deno1  } = globalThis;
const noColor = typeof Deno1?.noColor === "boolean" ? Deno1.noColor : true;
let enabled = !noColor;
function code1(open, close) {
    return {
        open: `\x1b[${open.join(";")}m`,
        close: `\x1b[${close}m`,
        regexp: new RegExp(`\\x1b\\[${close}m`, "g")
    };
}
function run(str, code) {
    return enabled ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}` : str;
}
function bold(str) {
    return run(str, code1([
        1
    ], 22));
}
function red(str) {
    return run(str, code1([
        31
    ], 39));
}
function yellow(str) {
    return run(str, code1([
        33
    ], 39));
}
function blue(str) {
    return run(str, code1([
        34
    ], 39));
}
new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))", 
].join("|"), "g");
var DiffType;
(function(DiffType) {
    DiffType["removed"] = "removed";
    DiffType["common"] = "common";
    DiffType["added"] = "added";
})(DiffType || (DiffType = {}));
BigInt(Number.MAX_SAFE_INTEGER);
function getFileInfoType(fileInfo) {
    return fileInfo.isFile ? "file" : fileInfo.isDirectory ? "dir" : fileInfo.isSymlink ? "symlink" : undefined;
}
async function ensureDir(dir) {
    try {
        const fileInfo = await Deno.lstat(dir);
        if (!fileInfo.isDirectory) {
            throw new Error(`Ensure path exists, expected 'dir', got '${getFileInfoType(fileInfo)}'`);
        }
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            await Deno.mkdir(dir, {
                recursive: true
            });
            return;
        }
        throw err;
    }
}
const BUF_SIZE = 64 * 1024;
async function* limitBytes(itbl, limit) {
    let bytes = 0;
    for await (let chunk of itbl){
        bytes += chunk.byteLength;
        if (bytes > limit) {
            return chunk.slice(0, limit - bytes);
        } else if (bytes === limit) {
            return chunk;
        } else {
            yield chunk;
        }
    }
}
async function* toBlockChunks(stringItbl) {
    const buffer = new Uint8Array(BUF_SIZE);
    let pointer = 0;
    const encoder = new TextEncoder();
    for await (const stringChunk of stringItbl){
        const bytes = encoder.encode(stringChunk);
        let start = 0;
        let bytesRemaining = bytes.length - start;
        let bufferRemaining = BUF_SIZE - pointer;
        while(bytesRemaining >= bufferRemaining){
            buffer.set(bytes.slice(start, start + bufferRemaining), pointer);
            yield buffer;
            start += bufferRemaining;
            bytesRemaining = bytes.length - start;
            pointer = 0;
            bufferRemaining = BUF_SIZE - pointer;
        }
        if (bytesRemaining > 0) {
            buffer.set(bytes.slice(start), pointer);
            pointer += bytesRemaining;
        }
    }
    yield buffer.slice(0, pointer);
}
async function* toLines(stringItbl) {
    const iterator = stringItbl[Symbol.asyncIterator]();
    let { value: chunk , done: readerDone  } = await iterator.next();
    const re = /\r\n|\n|\r/gm;
    let startIndex = 0;
    for(;;){
        const result = re.exec(chunk);
        if (!result) {
            if (readerDone) {
                break;
            }
            const remainder = chunk.substr(startIndex);
            const nextResult = await iterator.next();
            chunk = nextResult.value;
            readerDone = nextResult.done;
            chunk = remainder + (chunk || "");
            startIndex = re.lastIndex = 0;
            continue;
        }
        yield chunk.substring(startIndex, result.index);
        startIndex = re.lastIndex;
    }
    if (startIndex < chunk.length) {
        yield chunk.substr(startIndex);
    }
}
async function* iterateReader(r, options) {
    const bufSize = options?.bufSize ?? BUF_SIZE;
    while(true){
        const b = new Uint8Array(bufSize);
        const result = await r.read(b);
        if (result === null) {
            break;
        }
        yield b.subarray(0, result);
    }
}
async function readFileStream(path, startByte = 0, endByte = -1) {
    const f = await Deno.open(path);
    if (startByte > 0) {
        await Deno.seek(f.rid, startByte, Deno.SeekMode.Start);
    }
    let itbl = iterateReader(f, {
        bufSize: BUF_SIZE
    });
    if (endByte > -1) {
        itbl = limitBytes(itbl, endByte - startByte);
    }
    const stream = new ReadableStream({
        async pull (controller) {
            try {
                const { value , done  } = await itbl.next();
                if (done) {
                    controller.close();
                    f.close();
                } else {
                    controller.enqueue(value);
                }
            } catch (err) {
                controller.error(err);
                console.log('stream error: ' + JSON.stringify(err));
                f.close();
            }
        },
        cancel () {
            f.close();
        }
    });
    return stream;
}
async function writeFileStream(path) {
    await ensureDir(dirname2(path));
    let f = await Deno.open(path, {
        create: true,
        write: true,
        truncate: true
    });
    const stream = new WritableStream({
        async write (chunk) {
            await writeAll(f, chunk);
        },
        close () {
            f.close();
        },
        abort (reason) {
            console.error('Write abort: ', reason);
            f.close();
        }
    });
    return stream;
}
function jsonSplit(msg) {
    const queue = new AsyncQueue();
    if (!msg.data) return queue;
    if (msg.getHeader('content-type') === 'application/x-ndjson') {
        const rbl = msg.data.asReadable();
        if (!rbl) return queue;
        const processLines = async (rbl)=>{
            let idx = 0;
            for await (const line of toLines(rbl)){
                queue.enqueue(msg.copy().setName(idx.toString()).setData(line, "application/json"));
                idx++;
            }
        };
        processLines(rbl);
    } else {
        msg.data.asJson().then((obj)=>{
            if (Array.isArray(obj)) {
                obj.forEach((item, i)=>queue.enqueue(msg.copy().setName(i.toString()).setDataJson(item)));
            } else if (typeof obj === 'object') {
                Object.entries(obj).forEach(([key, value])=>queue.enqueue(msg.copy().setName(key).setDataJson(value)));
            } else {
                queue.enqueue(msg);
            }
            queue.close();
        });
    }
    return queue;
}
const generatePaths = async function*(msg, requestInternal) {
    let dir = await msg.data.asJson() || [];
    if (Array.isArray(dir)) dir = dir[0];
    yield [
        msg,
        {
            ...dir
        }
    ];
    if (requestInternal) {
        const subdirs = dir.paths.filter(([p])=>p.endsWith('/'));
        for (const [subdir] of subdirs){
            const newUrl = msg.url.follow(subdir);
            newUrl.query['$list'] = [
                "recursive,details,all"
            ];
            const msgOut = await requestInternal(msg.copy().setUrl(newUrl).setData(null, ''));
            const dirList = await msgOut.data.asJson() || [];
            for (const resDir of dirList){
                resDir.paths = resDir.paths.map(([p, ...rest])=>[
                        subdir + p,
                        ...rest
                    ]);
                yield [
                    msgOut,
                    {
                        ...resDir
                    }
                ];
            }
        }
    }
};
const dirToItems = async (msg, dir, requestInternal)=>{
    const fetchAllMessages = dir.paths.filter(([path])=>!path.endsWith('/')).map(([path])=>msg.copy().setUrl(msg.url.follow(last(path.split('/')))));
    const fullList = {};
    await Promise.all(fetchAllMessages.map((msg)=>requestInternal(msg).then((msg)=>msg.data.asJson().then((data)=>fullList[slashTrimLeft(dir.path) + msg.url.resourceName] = data))));
    return fullList;
};
const __final = (s)=>{
    const words = s.split('/');
    return last(words) === '' ? words.slice(-2)[0] + '/' : last(words);
};
const extractFragment = async (msg, url)=>{
    if (url.fragment && msg.data) {
        await msg.data.extractPathIfJson(url.fragment);
    }
    return msg;
};
const mimeHandlers = {
    "application/json": extractFragment,
    "application/schema+json": extractFragment,
    "inode/directory+json": async (msg, url, requestInternal)=>{
        const listFlags = (url.query['$list'] || []).join(',');
        let isRecursive = listFlags.includes('recursive');
        const getItems = listFlags.includes('items');
        const details = listFlags.includes('details');
        let pathsOnly = !(details || getItems);
        const allFiles = listFlags.includes('all');
        const fileInfo = listFlags.includes('fileinfo') && pathsOnly;
        const noDirs = listFlags.includes('nodirs');
        const isZip = listFlags.includes('zip');
        if (isZip) {
            isRecursive = true;
            pathsOnly = true;
        }
        let results = [];
        for await (const [resMsg, resDir] of generatePaths(msg, isRecursive ? requestInternal : undefined)){
            if (!resDir) continue;
            if (!allFiles) {
                resDir.paths = resDir.paths.filter(([p])=>!__final(p).startsWith('.'));
            }
            if (noDirs) {
                resDir.paths = resDir.paths.filter(([p])=>!p.endsWith('/'));
            }
            let result = resDir;
            if (getItems) {
                result = await dirToItems(resMsg, resDir, requestInternal);
                results.push(result);
            } else if (pathsOnly) {
                results = results.concat(resDir.paths);
            } else {
                results.push(result);
            }
        }
        if (isRecursive) {
            if (getItems) {
                results = Object.assign(results[0], ...results.slice(1));
            } else if (!fileInfo) {
                results = results.flatMap((i)=>i);
            }
            if (details) {
                results.forEach((r)=>r.paths = r.paths.map(([p, ...rest])=>[
                            __final(p),
                            ...rest
                        ]));
            }
        } else {
            if (!pathsOnly) {
                results = results[0];
            } else if (!fileInfo) {
                results = results.map(([p])=>p);
            }
        }
        if (getItems) {
            let obj = results;
            const urlRemoveChars = url.servicePath === '/' ? 0 : url.servicePath.length;
            obj = Object.fromEntries(Object.entries(obj).map(([k, v])=>[
                    k.substr(urlRemoveChars),
                    v
                ]));
            return msg.setDirectoryJson(obj);
        }
        return msg.setDirectoryJson(results);
    }
};
const pipelineSchema = {
    type: "array",
    items: {
        type: [
            "string",
            "array"
        ],
        oneOf: [
            {
                title: "request",
                type: "string"
            },
            {
                title: "subpipeline",
                "$ref": "#/definitions/pipeline"
            }
        ],
        editor: "oneOfRadio"
    }
};
new __pika_web_default_export_for_treeshaking__1({
    strictSchema: false,
    allowUnionTypes: true
}).compile(Object.assign({
    definitions: {
        pipeline: pipelineSchema
    }
}, pipelineSchema));
const pipelineConcat = (pipeline0, pipeline1)=>{
    if (pipeline0 || pipeline1) {
        return (pipeline0 || []).concat(pipeline1 || []);
    } else {
        return undefined;
    }
};
const schemaIServiceConfig = {
    "$id": "http://restspace.io/services/serviceConfig",
    "definitions": {
        "pipeline": {
            "type": "array",
            "items": {
                "type": [
                    "string",
                    "array",
                    "object"
                ],
                "oneOf": [
                    {
                        "title": "request",
                        "type": "string"
                    },
                    {
                        "title": "subpipeline",
                        "$ref": "#/definitions/pipeline"
                    },
                    {
                        "title": "transform",
                        "type": "object"
                    }
                ],
                "editor": "oneOfRadio"
            }
        }
    },
    "type": "object",
    "properties": {
        "name": {
            "type": "string"
        },
        "source": {
            "type": "string",
            "description": "Url from which to request source code"
        },
        "basePath": {
            "type": "string",
            "description": "Base path prefixing all paths used by the service"
        },
        "access": {
            "type": "object",
            "properties": {
                "readRoles": {
                    "type": "string"
                },
                "writeRoles": {
                    "type": "string"
                },
                "manageRoles": {
                    "type": "string"
                },
                "createRoles": {
                    "type": "string"
                }
            },
            "required": [
                "readRoles",
                "writeRoles"
            ]
        },
        "caching": {
            "type": "object",
            "properties": {
                "cache": {
                    "type": "boolean"
                },
                "sendETag": {
                    "type": "boolean"
                },
                "maxAge": {
                    "type": "number"
                }
            }
        },
        "adapterSource": {
            "type": "string",
            "description": "Url from which to request adapter manifest"
        },
        "infraName": {
            "type": "string",
            "description": "Infrastructure adapter to use instead of an adapter source"
        },
        "adapterConfig": {
            "type": "object",
            "description": "Configuration for the adapter",
            "properties": {}
        },
        "proxyAdapterConfig": {
            "type": "object",
            "description": "Configuration for the proxy adapter",
            "properties": {}
        },
        "prePipeline": {
            "$ref": "#/definitions/pipeline"
        },
        "postPipeline": {
            "$ref": "#/definitions/pipeline"
        }
    },
    "required": [
        "name",
        "source",
        "basePath",
        "access"
    ]
};
const schemaIChordServiceConfig = {
    "$id": "https://restspace.io/chords/chordServiceConfig",
    "type": "object",
    "definitions": {
        ...schemaIServiceConfig.definitions
    },
    "properties": {
        ...schemaIServiceConfig.properties
    },
    "required": [
        "name",
        "source",
        "basePath"
    ]
};
const schemaIServiceConfigExposedProperties = [
    "name",
    "source",
    "basePath",
    "access",
    "caching",
    "adapterSource",
    "prePipeline",
    "postPipeline"
];
new TextEncoder();
new TextDecoder();
"./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
new Uint8Array([
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    -1,
    -1,
    -1,
    -1,
    -1, 
]);
globalThis.crypto;
new Int32Array([
    0x243f6a88,
    0x85a308d3,
    0x13198a2e,
    0x03707344,
    0xa4093822,
    0x299f31d0,
    0x082efa98,
    0xec4e6c89,
    0x452821e6,
    0x38d01377,
    0xbe5466cf,
    0x34e90c6c,
    0xc0ac29b7,
    0xc97c50dd,
    0x3f84d5b5,
    0xb5470917,
    0x9216d5d9,
    0x8979fb1b, 
]);
new Int32Array([
    0xd1310ba6,
    0x98dfb5ac,
    0x2ffd72db,
    0xd01adfb7,
    0xb8e1afed,
    0x6a267e96,
    0xba7c9045,
    0xf12c7f99,
    0x24a19947,
    0xb3916cf7,
    0x0801f2e2,
    0x858efc16,
    0x636920d8,
    0x71574e69,
    0xa458fea3,
    0xf4933d7e,
    0x0d95748f,
    0x728eb658,
    0x718bcd58,
    0x82154aee,
    0x7b54a41d,
    0xc25a59b5,
    0x9c30d539,
    0x2af26013,
    0xc5d1b023,
    0x286085f0,
    0xca417918,
    0xb8db38ef,
    0x8e79dcb0,
    0x603a180e,
    0x6c9e0e8b,
    0xb01e8a3e,
    0xd71577c1,
    0xbd314b27,
    0x78af2fda,
    0x55605c60,
    0xe65525f3,
    0xaa55ab94,
    0x57489862,
    0x63e81440,
    0x55ca396a,
    0x2aab10b6,
    0xb4cc5c34,
    0x1141e8ce,
    0xa15486af,
    0x7c72e993,
    0xb3ee1411,
    0x636fbc2a,
    0x2ba9c55d,
    0x741831f6,
    0xce5c3e16,
    0x9b87931e,
    0xafd6ba33,
    0x6c24cf5c,
    0x7a325381,
    0x28958677,
    0x3b8f4898,
    0x6b4bb9af,
    0xc4bfe81b,
    0x66282193,
    0x61d809cc,
    0xfb21a991,
    0x487cac60,
    0x5dec8032,
    0xef845d5d,
    0xe98575b1,
    0xdc262302,
    0xeb651b88,
    0x23893e81,
    0xd396acc5,
    0x0f6d6ff3,
    0x83f44239,
    0x2e0b4482,
    0xa4842004,
    0x69c8f04a,
    0x9e1f9b5e,
    0x21c66842,
    0xf6e96c9a,
    0x670c9c61,
    0xabd388f0,
    0x6a51a0d2,
    0xd8542f68,
    0x960fa728,
    0xab5133a3,
    0x6eef0b6c,
    0x137a3be4,
    0xba3bf050,
    0x7efb2a98,
    0xa1f1651d,
    0x39af0176,
    0x66ca593e,
    0x82430e88,
    0x8cee8619,
    0x456f9fb4,
    0x7d84a5c3,
    0x3b8b5ebe,
    0xe06f75d8,
    0x85c12073,
    0x401a449f,
    0x56c16aa6,
    0x4ed3aa62,
    0x363f7706,
    0x1bfedf72,
    0x429b023d,
    0x37d0d724,
    0xd00a1248,
    0xdb0fead3,
    0x49f1c09b,
    0x075372c9,
    0x80991b7b,
    0x25d479d8,
    0xf6e8def7,
    0xe3fe501a,
    0xb6794c3b,
    0x976ce0bd,
    0x04c006ba,
    0xc1a94fb6,
    0x409f60c4,
    0x5e5c9ec2,
    0x196a2463,
    0x68fb6faf,
    0x3e6c53b5,
    0x1339b2eb,
    0x3b52ec6f,
    0x6dfc511f,
    0x9b30952c,
    0xcc814544,
    0xaf5ebd09,
    0xbee3d004,
    0xde334afd,
    0x660f2807,
    0x192e4bb3,
    0xc0cba857,
    0x45c8740f,
    0xd20b5f39,
    0xb9d3fbdb,
    0x5579c0bd,
    0x1a60320a,
    0xd6a100c6,
    0x402c7279,
    0x679f25fe,
    0xfb1fa3cc,
    0x8ea5e9f8,
    0xdb3222f8,
    0x3c7516df,
    0xfd616b15,
    0x2f501ec8,
    0xad0552ab,
    0x323db5fa,
    0xfd238760,
    0x53317b48,
    0x3e00df82,
    0x9e5c57bb,
    0xca6f8ca0,
    0x1a87562e,
    0xdf1769db,
    0xd542a8f6,
    0x287effc3,
    0xac6732c6,
    0x8c4f5573,
    0x695b27b0,
    0xbbca58c8,
    0xe1ffa35d,
    0xb8f011a0,
    0x10fa3d98,
    0xfd2183b8,
    0x4afcb56c,
    0x2dd1d35b,
    0x9a53e479,
    0xb6f84565,
    0xd28e49bc,
    0x4bfb9790,
    0xe1ddf2da,
    0xa4cb7e33,
    0x62fb1341,
    0xcee4c6e8,
    0xef20cada,
    0x36774c01,
    0xd07e9efe,
    0x2bf11fb4,
    0x95dbda4d,
    0xae909198,
    0xeaad8e71,
    0x6b93d5a0,
    0xd08ed1d0,
    0xafc725e0,
    0x8e3c5b2f,
    0x8e7594b7,
    0x8ff6e2fb,
    0xf2122b64,
    0x8888b812,
    0x900df01c,
    0x4fad5ea0,
    0x688fc31c,
    0xd1cff191,
    0xb3a8c1ad,
    0x2f2f2218,
    0xbe0e1777,
    0xea752dfe,
    0x8b021fa1,
    0xe5a0cc0f,
    0xb56f74e8,
    0x18acf3d6,
    0xce89e299,
    0xb4a84fe0,
    0xfd13e0b7,
    0x7cc43b81,
    0xd2ada8d9,
    0x165fa266,
    0x80957705,
    0x93cc7314,
    0x211a1477,
    0xe6ad2065,
    0x77b5fa86,
    0xc75442f5,
    0xfb9d35cf,
    0xebcdaf0c,
    0x7b3e89a0,
    0xd6411bd3,
    0xae1e7e49,
    0x00250e2d,
    0x2071b35e,
    0x226800bb,
    0x57b8e0af,
    0x2464369b,
    0xf009b91e,
    0x5563911d,
    0x59dfa6aa,
    0x78c14389,
    0xd95a537f,
    0x207d5ba2,
    0x02e5b9c5,
    0x83260376,
    0x6295cfa9,
    0x11c81968,
    0x4e734a41,
    0xb3472dca,
    0x7b14a94a,
    0x1b510052,
    0x9a532915,
    0xd60f573f,
    0xbc9bc6e4,
    0x2b60a476,
    0x81e67400,
    0x08ba6fb5,
    0x571be91f,
    0xf296ec6b,
    0x2a0dd915,
    0xb6636521,
    0xe7b9f9b6,
    0xff34052e,
    0xc5855664,
    0x53b02d5d,
    0xa99f8fa1,
    0x08ba4799,
    0x6e85076a,
    0x4b7a70e9,
    0xb5b32944,
    0xdb75092e,
    0xc4192623,
    0xad6ea6b0,
    0x49a7df7d,
    0x9cee60b8,
    0x8fedb266,
    0xecaa8c71,
    0x699a17ff,
    0x5664526c,
    0xc2b19ee1,
    0x193602a5,
    0x75094c29,
    0xa0591340,
    0xe4183a3e,
    0x3f54989a,
    0x5b429d65,
    0x6b8fe4d6,
    0x99f73fd6,
    0xa1d29c07,
    0xefe830f5,
    0x4d2d38e6,
    0xf0255dc1,
    0x4cdd2086,
    0x8470eb26,
    0x6382e9c6,
    0x021ecc5e,
    0x09686b3f,
    0x3ebaefc9,
    0x3c971814,
    0x6b6a70a1,
    0x687f3584,
    0x52a0e286,
    0xb79c5305,
    0xaa500737,
    0x3e07841c,
    0x7fdeae5c,
    0x8e7d44ec,
    0x5716f2b8,
    0xb03ada37,
    0xf0500c0d,
    0xf01c1f04,
    0x0200b3ff,
    0xae0cf51a,
    0x3cb574b2,
    0x25837a58,
    0xdc0921bd,
    0xd19113f9,
    0x7ca92ff6,
    0x94324773,
    0x22f54701,
    0x3ae5e581,
    0x37c2dadc,
    0xc8b57634,
    0x9af3dda7,
    0xa9446146,
    0x0fd0030e,
    0xecc8c73e,
    0xa4751e41,
    0xe238cd99,
    0x3bea0e2f,
    0x3280bba1,
    0x183eb331,
    0x4e548b38,
    0x4f6db908,
    0x6f420d03,
    0xf60a04bf,
    0x2cb81290,
    0x24977c79,
    0x5679b072,
    0xbcaf89af,
    0xde9a771f,
    0xd9930810,
    0xb38bae12,
    0xdccf3f2e,
    0x5512721f,
    0x2e6b7124,
    0x501adde6,
    0x9f84cd87,
    0x7a584718,
    0x7408da17,
    0xbc9f9abc,
    0xe94b7d8c,
    0xec7aec3a,
    0xdb851dfa,
    0x63094366,
    0xc464c3d2,
    0xef1c1847,
    0x3215d908,
    0xdd433b37,
    0x24c2ba16,
    0x12a14d43,
    0x2a65c451,
    0x50940002,
    0x133ae4dd,
    0x71dff89e,
    0x10314e55,
    0x81ac77d6,
    0x5f11199b,
    0x043556f1,
    0xd7a3c76b,
    0x3c11183b,
    0x5924a509,
    0xf28fe6ed,
    0x97f1fbfa,
    0x9ebabf2c,
    0x1e153c6e,
    0x86e34570,
    0xeae96fb1,
    0x860e5e0a,
    0x5a3e2ab3,
    0x771fe71c,
    0x4e3d06fa,
    0x2965dcb9,
    0x99e71d0f,
    0x803e89d6,
    0x5266c825,
    0x2e4cc978,
    0x9c10b36a,
    0xc6150eba,
    0x94e2ea78,
    0xa5fc3c53,
    0x1e0a2df4,
    0xf2f74ea7,
    0x361d2b3d,
    0x1939260f,
    0x19c27960,
    0x5223a708,
    0xf71312b6,
    0xebadfe6e,
    0xeac31f66,
    0xe3bc4595,
    0xa67bc883,
    0xb17f37d1,
    0x018cff28,
    0xc332ddef,
    0xbe6c5aa5,
    0x65582185,
    0x68ab9802,
    0xeecea50f,
    0xdb2f953b,
    0x2aef7dad,
    0x5b6e2f84,
    0x1521b628,
    0x29076170,
    0xecdd4775,
    0x619f1510,
    0x13cca830,
    0xeb61bd96,
    0x0334fe1e,
    0xaa0363cf,
    0xb5735c90,
    0x4c70a239,
    0xd59e9e0b,
    0xcbaade14,
    0xeecc86bc,
    0x60622ca7,
    0x9cab5cab,
    0xb2f3846e,
    0x648b1eaf,
    0x19bdf0ca,
    0xa02369b9,
    0x655abb50,
    0x40685a32,
    0x3c2ab4b3,
    0x319ee9d5,
    0xc021b8f7,
    0x9b540b19,
    0x875fa099,
    0x95f7997e,
    0x623d7da8,
    0xf837889a,
    0x97e32d77,
    0x11ed935f,
    0x16681281,
    0x0e358829,
    0xc7e61fd6,
    0x96dedfa1,
    0x7858ba99,
    0x57f584a5,
    0x1b227263,
    0x9b83c3ff,
    0x1ac24696,
    0xcdb30aeb,
    0x532e3054,
    0x8fd948e4,
    0x6dbc3128,
    0x58ebf2ef,
    0x34c6ffea,
    0xfe28ed61,
    0xee7c3c73,
    0x5d4a14d9,
    0xe864b7e3,
    0x42105d14,
    0x203e13e0,
    0x45eee2b6,
    0xa3aaabea,
    0xdb6c4f15,
    0xfacb4fd0,
    0xc742f442,
    0xef6abbb5,
    0x654f3b1d,
    0x41cd2105,
    0xd81e799e,
    0x86854dc7,
    0xe44b476a,
    0x3d816250,
    0xcf62a1f2,
    0x5b8d2646,
    0xfc8883a0,
    0xc1c7b6a3,
    0x7f1524c3,
    0x69cb7492,
    0x47848a0b,
    0x5692b285,
    0x095bbf00,
    0xad19489d,
    0x1462b174,
    0x23820e00,
    0x58428d2a,
    0x0c55f5ea,
    0x1dadf43e,
    0x233f7061,
    0x3372f092,
    0x8d937e41,
    0xd65fecf1,
    0x6c223bdb,
    0x7cde3759,
    0xcbee7460,
    0x4085f2a7,
    0xce77326e,
    0xa6078084,
    0x19f8509e,
    0xe8efd855,
    0x61d99735,
    0xa969a7aa,
    0xc50c06c2,
    0x5a04abfc,
    0x800bcadc,
    0x9e447a2e,
    0xc3453484,
    0xfdd56705,
    0x0e1e9ec9,
    0xdb73dbd3,
    0x105588cd,
    0x675fda79,
    0xe3674340,
    0xc5c43465,
    0x713e38d8,
    0x3d28f89e,
    0xf16dff20,
    0x153e21e7,
    0x8fb03d4a,
    0xe6e39f2b,
    0xdb83adf7,
    0xe93d5a68,
    0x948140f7,
    0xf64c261c,
    0x94692934,
    0x411520f7,
    0x7602d4f7,
    0xbcf46b2e,
    0xd4a20068,
    0xd4082471,
    0x3320f46a,
    0x43b7d4b7,
    0x500061af,
    0x1e39f62e,
    0x97244546,
    0x14214f74,
    0xbf8b8840,
    0x4d95fc1d,
    0x96b591af,
    0x70f4ddd3,
    0x66a02f45,
    0xbfbc09ec,
    0x03bd9785,
    0x7fac6dd0,
    0x31cb8504,
    0x96eb27b3,
    0x55fd3941,
    0xda2547e6,
    0xabca0a9a,
    0x28507825,
    0x530429f4,
    0x0a2c86da,
    0xe9b66dfb,
    0x68dc1462,
    0xd7486900,
    0x680ec0a4,
    0x27a18dee,
    0x4f3ffea2,
    0xe887ad8c,
    0xb58ce006,
    0x7af4d6b6,
    0xaace1e7c,
    0xd3375fec,
    0xce78a399,
    0x406b2a42,
    0x20fe9e35,
    0xd9f385b9,
    0xee39d7ab,
    0x3b124e8b,
    0x1dc9faf7,
    0x4b6d1856,
    0x26a36631,
    0xeae397b2,
    0x3a6efa74,
    0xdd5b4332,
    0x6841e7f7,
    0xca7820fb,
    0xfb0af54e,
    0xd8feb397,
    0x454056ac,
    0xba489527,
    0x55533a3a,
    0x20838d87,
    0xfe6ba9b7,
    0xd096954b,
    0x55a867bc,
    0xa1159a58,
    0xcca92963,
    0x99e1db33,
    0xa62a4a56,
    0x3f3125f9,
    0x5ef47e1c,
    0x9029317c,
    0xfdf8e802,
    0x04272f70,
    0x80bb155c,
    0x05282ce3,
    0x95c11548,
    0xe4c66d22,
    0x48c1133f,
    0xc70f86dc,
    0x07f9c9ee,
    0x41041f0f,
    0x404779a4,
    0x5d886e17,
    0x325f51eb,
    0xd59bc0d1,
    0xf2bcc18f,
    0x41113564,
    0x257b7834,
    0x602a9c60,
    0xdff8e8a3,
    0x1f636c1b,
    0x0e12b4c2,
    0x02e1329e,
    0xaf664fd1,
    0xcad18115,
    0x6b2395e0,
    0x333e92e1,
    0x3b240b62,
    0xeebeb922,
    0x85b2a20e,
    0xe6ba0d99,
    0xde720c8c,
    0x2da2f728,
    0xd0127845,
    0x95b794fd,
    0x647d0862,
    0xe7ccf5f0,
    0x5449a36f,
    0x877d48fa,
    0xc39dfd27,
    0xf33e8d1e,
    0x0a476341,
    0x992eff74,
    0x3a6f6eab,
    0xf4f8fd37,
    0xa812dc60,
    0xa1ebddf8,
    0x991be14c,
    0xdb6e6b0d,
    0xc67b5510,
    0x6d672c37,
    0x2765d43b,
    0xdcd0e804,
    0xf1290dc7,
    0xcc00ffa3,
    0xb5390f92,
    0x690fed0b,
    0x667b9ffb,
    0xcedb7d9c,
    0xa091cf0b,
    0xd9155ea3,
    0xbb132f88,
    0x515bad24,
    0x7b9479bf,
    0x763bd6eb,
    0x37392eb3,
    0xcc115979,
    0x8026e297,
    0xf42e312d,
    0x6842ada7,
    0xc66a2b3b,
    0x12754ccc,
    0x782ef11c,
    0x6a124237,
    0xb79251e7,
    0x06a1bbe6,
    0x4bfb6350,
    0x1a6b1018,
    0x11caedfa,
    0x3d25bdd8,
    0xe2e1c3c9,
    0x44421659,
    0x0a121386,
    0xd90cec6e,
    0xd5abea2a,
    0x64af674e,
    0xda86a85f,
    0xbebfe988,
    0x64e4c3fe,
    0x9dbc8057,
    0xf0f7c086,
    0x60787bf8,
    0x6003604d,
    0xd1fd8346,
    0xf6381fb0,
    0x7745ae04,
    0xd736fccc,
    0x83426b33,
    0xf01eab71,
    0xb0804187,
    0x3c005e5f,
    0x77a057be,
    0xbde8ae24,
    0x55464299,
    0xbf582e61,
    0x4e58f48f,
    0xf2ddfda2,
    0xf474ef38,
    0x8789bdc2,
    0x5366f9c3,
    0xc8b38e74,
    0xb475f255,
    0x46fcd9b9,
    0x7aeb2661,
    0x8b1ddf84,
    0x846a0e79,
    0x915f95e2,
    0x466e598e,
    0x20b45770,
    0x8cd55591,
    0xc902de4c,
    0xb90bace1,
    0xbb8205d0,
    0x11a86248,
    0x7574a99e,
    0xb77f19b6,
    0xe0a9dc09,
    0x662d09a1,
    0xc4324633,
    0xe85a1f02,
    0x09f0be8c,
    0x4a99a025,
    0x1d6efe10,
    0x1ab93d1d,
    0x0ba5a4df,
    0xa186f20f,
    0x2868f169,
    0xdcb7da83,
    0x573906fe,
    0xa1e2ce9b,
    0x4fcd7f52,
    0x50115e01,
    0xa70683fa,
    0xa002b5c4,
    0x0de6d027,
    0x9af88c27,
    0x773f8641,
    0xc3604c06,
    0x61a806b5,
    0xf0177a28,
    0xc0f586e0,
    0x006058aa,
    0x30dc7d62,
    0x11e69ed7,
    0x2338ea63,
    0x53c2dd94,
    0xc2c21634,
    0xbbcbee56,
    0x90bcb6de,
    0xebfc7da1,
    0xce591d76,
    0x6f05e409,
    0x4b7c0188,
    0x39720a3d,
    0x7c927c24,
    0x86e3725f,
    0x724d9db9,
    0x1ac15bb4,
    0xd39eb8fc,
    0xed545578,
    0x08fca5b5,
    0xd83d7cd3,
    0x4dad0fc4,
    0x1e50ef5e,
    0xb161e6f8,
    0xa28514d9,
    0x6c51133c,
    0x6fd5c7e7,
    0x56e14ec4,
    0x362abfce,
    0xddc6c837,
    0xd79a3234,
    0x92638212,
    0x670efa8e,
    0x406000e0,
    0x3a39ce37,
    0xd3faf5cf,
    0xabc27737,
    0x5ac52d1b,
    0x5cb0679e,
    0x4fa33742,
    0xd3822740,
    0x99bc9bbe,
    0xd5118e9d,
    0xbf0f7315,
    0xd62d1c7e,
    0xc700c47b,
    0xb78c1b6b,
    0x21a19045,
    0xb26eb1be,
    0x6a366eb4,
    0x5748ab2f,
    0xbc946e79,
    0xc6a376d2,
    0x6549c2c8,
    0x530ff8ee,
    0x468dde7d,
    0xd5730a1d,
    0x4cd04dc6,
    0x2939bbdb,
    0xa9ba4650,
    0xac9526e8,
    0xbe5ee304,
    0xa1fad5f0,
    0x6a2d519a,
    0x63ef8ce2,
    0x9a86ee22,
    0xc089c2b8,
    0x43242ef6,
    0xa51e03aa,
    0x9cf2d0a4,
    0x83c061ba,
    0x9be96a4d,
    0x8fe51550,
    0xba645bd6,
    0x2826a2f9,
    0xa73a3ae1,
    0x4ba99586,
    0xef5562e9,
    0xc72fefd3,
    0xf752f7da,
    0x3f046f69,
    0x77fa0a59,
    0x80e4a915,
    0x87b08601,
    0x9b09e6ad,
    0x3b3ee593,
    0xe990fd5a,
    0x9e34d797,
    0x2cf0b7d9,
    0x022b8b51,
    0x96d5ac3a,
    0x017da67d,
    0xd1cf3ed6,
    0x7c7d2d28,
    0x1f9f25cf,
    0xadf2b89b,
    0x5ad6b472,
    0x5a88f54c,
    0xe029ac71,
    0xe019a5e6,
    0x47b0acfd,
    0xed93fa9b,
    0xe8d3c48d,
    0x283b57cc,
    0xf8d56629,
    0x79132e28,
    0x785f0191,
    0xed756055,
    0xf7960e44,
    0xe3d35e8c,
    0x15056dd4,
    0x88f46dba,
    0x03a16125,
    0x0564f0bd,
    0xc3eb9e15,
    0x3c9057a2,
    0x97271aec,
    0xa93a072a,
    0x1b3f6d9b,
    0x1e6321f5,
    0xf59c66fb,
    0x26dcf319,
    0x7533d928,
    0xb155fdf5,
    0x03563482,
    0x8aba3cbb,
    0x28517711,
    0xc20ad9f8,
    0xabcc5167,
    0xccad925f,
    0x4de81751,
    0x3830dc8e,
    0x379d5862,
    0x9320f991,
    0xea7a90c2,
    0xfb3e7bce,
    0x5121ce64,
    0x774fbe32,
    0xa8b6e37e,
    0xc3293d46,
    0x48de5369,
    0x6413e680,
    0xa2ae0810,
    0xdd6db224,
    0x69852dfd,
    0x09072166,
    0xb39a460a,
    0x6445c0dd,
    0x586cdecf,
    0x1c20c8ae,
    0x5bbef7dd,
    0x1b588d40,
    0xccd2017f,
    0x6bb4e3bb,
    0xdda26a7e,
    0x3a59ff45,
    0x3e350a44,
    0xbcb4cdd5,
    0x72eacea8,
    0xfa6484bb,
    0x8d6612ae,
    0xbf3c6f47,
    0xd29be463,
    0x542f5d9e,
    0xaec2771b,
    0xf64e6370,
    0x740e0d8d,
    0xe75b1357,
    0xf8721671,
    0xaf537d5d,
    0x4040cb08,
    0x4eb4e2cc,
    0x34d2466a,
    0x0115af84,
    0xe1b00428,
    0x95983a1d,
    0x06b89fb4,
    0xce6ea048,
    0x6f3f3b82,
    0x3520ab82,
    0x011a1d4b,
    0x277227f8,
    0x611560b1,
    0xe7933fdc,
    0xbb3a792b,
    0x344525bd,
    0xa08839e1,
    0x51ce794b,
    0x2f32c9b7,
    0xa01fbac9,
    0xe01cc87e,
    0xbcc7d1f6,
    0xcf0111c3,
    0xa1e8aac7,
    0x1a908749,
    0xd44fbd9a,
    0xd0dadecb,
    0xd50ada38,
    0x0339c32a,
    0xc6913667,
    0x8df9317c,
    0xe0b12b4f,
    0xf79e59b7,
    0x43f5bb3a,
    0xf2d519ff,
    0x27d9459c,
    0xbf97222c,
    0x15e6fc2a,
    0x0f91fc71,
    0x9b941525,
    0xfae59361,
    0xceb69ceb,
    0xc2a86459,
    0x12baa8d1,
    0xb6c1075e,
    0xe3056a0c,
    0x10d25065,
    0xcb03a442,
    0xe0ec6e0e,
    0x1698db3b,
    0x4c98a0be,
    0x3278e964,
    0x9f1f9532,
    0xe0d392df,
    0xd3a0342b,
    0x8971f21e,
    0x1b0a7441,
    0x4ba3348c,
    0xc5be7120,
    0xc37632d8,
    0xdf359f8d,
    0x9b992f2e,
    0xe60b6f47,
    0x0fe3f11d,
    0xe54cda54,
    0x1edad891,
    0xce6279cf,
    0xcd3e7e6f,
    0x1618b166,
    0xfd2c1d05,
    0x848fd2c5,
    0xf6fb2299,
    0xf523f357,
    0xa6327623,
    0x93a83531,
    0x56cccd02,
    0xacf08162,
    0x5a75ebb5,
    0x6e163697,
    0x88d273cc,
    0xde966292,
    0x81b949d0,
    0x4c50901b,
    0x71c65614,
    0xe6c6c7bd,
    0x327a140a,
    0x45e1d006,
    0xc3f27b9a,
    0xc9aa53fd,
    0x62a80f00,
    0xbb25bfe2,
    0x35bdd2f6,
    0x71126905,
    0xb2040222,
    0xb6cbcf7c,
    0xcd769c2b,
    0x53113ec0,
    0x1640e3d3,
    0x38abbd60,
    0x2547adf0,
    0xba38209c,
    0xf746ce76,
    0x77afa1c5,
    0x20756060,
    0x85cbfe4e,
    0x8ae88dd8,
    0x7aaaf9b0,
    0x4cf9aa7e,
    0x1948c25c,
    0x02fb8a8c,
    0x01c36ae4,
    0xd6ebe1f9,
    0x90d4f869,
    0xa65cdea0,
    0x3f09252d,
    0xc208e69f,
    0xb74e6132,
    0xce77e25b,
    0x578fdfe3,
    0x3ac372e6, 
]);
new Int32Array([
    0x4f727068,
    0x65616e42,
    0x65686f6c,
    0x64657253,
    0x63727944,
    0x6f756274, 
]);
const importMeta = {
    url: "https://deno.land/x/bcrypt@v0.2.4/src/main.ts",
    main: false
};
async function hash(plaintext, salt = undefined) {
    let worker = new Worker(new URL("worker.ts", importMeta.url).toString(), {
        type: "module",
        deno: true
    });
    worker.postMessage({
        action: "hash",
        payload: {
            plaintext,
            salt
        }
    });
    return new Promise((resolve)=>{
        worker.onmessage = (event)=>{
            resolve(event.data);
            worker.terminate();
        };
    });
}
async function compare(plaintext, hash) {
    let worker = new Worker(new URL("worker.ts", importMeta.url).toString(), {
        type: "module",
        deno: true
    });
    worker.postMessage({
        action: "compare",
        payload: {
            plaintext,
            hash
        }
    });
    return new Promise((resolve)=>{
        worker.onmessage = (event)=>{
            resolve(event.data);
            worker.terminate();
        };
    });
}
var ArrayProto = Array.prototype;
var ObjProto = Object.prototype;
var escapeMap = {
    "&": "&amp;",
    '"': "&quot;",
    "'": "&#39;",
    "<": "&lt;",
    ">": "&gt;"
};
var escapeRegex = /[&"'<>]/g;
function hasOwnProp(obj, k) {
    return ObjProto.hasOwnProperty.call(obj, k);
}
function lookupEscape(ch) {
    return escapeMap[ch];
}
function _prettifyError(path, withInternals, err) {
    if (!err.Update) {
        err = new TemplateError(err);
    }
    err.Update(path);
    if (!withInternals) {
        const old = err;
        err = new Error(old.message);
        err.name = old.name;
    }
    return err;
}
function TemplateError(message, lineno, colno) {
    var err;
    var cause;
    if (message instanceof Error) {
        cause = message;
        message = `${cause.name}: ${cause.message}`;
    }
    if (Object.setPrototypeOf) {
        err = new Error(message);
        Object.setPrototypeOf(err, TemplateError.prototype);
    } else {
        err = this;
        Object.defineProperty(err, "message", {
            enumerable: false,
            writable: true,
            value: message
        });
    }
    Object.defineProperty(err, "name", {
        value: "Template render error"
    });
    if (Error.captureStackTrace) {
        Error.captureStackTrace(err, this.constructor);
    }
    let getStack;
    if (cause) {
        const stackDescriptor = Object.getOwnPropertyDescriptor(cause, "stack");
        getStack = stackDescriptor && (stackDescriptor.get || (()=>stackDescriptor.value));
        if (!getStack) {
            getStack = ()=>cause.stack;
        }
    } else {
        const stack = new Error(message).stack;
        getStack = ()=>stack;
    }
    Object.defineProperty(err, "stack", {
        get: ()=>getStack.call(err)
    });
    Object.defineProperty(err, "cause", {
        value: cause
    });
    err.lineno = lineno;
    err.colno = colno;
    err.firstUpdate = true;
    err.Update = function Update(path) {
        let msg = "(" + (path || "unknown path") + ")";
        if (this.firstUpdate) {
            if (this.lineno && this.colno) {
                msg += ` [Line ${this.lineno}, Column ${this.colno}]`;
            } else if (this.lineno) {
                msg += ` [Line ${this.lineno}]`;
            }
        }
        msg += "\n ";
        if (this.firstUpdate) {
            msg += " ";
        }
        this.message = msg + (this.message || "");
        this.firstUpdate = false;
        return this;
    };
    return err;
}
if (Object.setPrototypeOf) {
    Object.setPrototypeOf(TemplateError.prototype, Error.prototype);
} else {
    TemplateError.prototype = Object.create(Error.prototype, {
        constructor: {
            value: TemplateError
        }
    });
}
function escape(val) {
    return val.replace(escapeRegex, lookupEscape);
}
function isFunction(obj) {
    return ObjProto.toString.call(obj) === "[object Function]";
}
function isArray(obj) {
    return ObjProto.toString.call(obj) === "[object Array]";
}
function isString(obj) {
    return ObjProto.toString.call(obj) === "[object String]";
}
function isObject1(obj) {
    return ObjProto.toString.call(obj) === "[object Object]";
}
function _prepareAttributeParts(attr) {
    if (!attr) {
        return [];
    }
    if (typeof attr === "string") {
        return attr.split(".");
    }
    return [
        attr
    ];
}
function getAttrGetter(attribute) {
    const parts = _prepareAttributeParts(attribute);
    return function attrGetter(item) {
        let _item = item;
        for(let i = 0; i < parts.length; i++){
            const part = parts[i];
            if (hasOwnProp(_item, part)) {
                _item = _item[part];
            } else {
                return undefined;
            }
        }
        return _item;
    };
}
function groupBy(obj, val, throwOnUndefined) {
    const result = {};
    const iterator = isFunction(val) ? val : getAttrGetter(val);
    for(let i = 0; i < obj.length; i++){
        const value = obj[i];
        const key = iterator(value, i);
        if (key === undefined && throwOnUndefined === true) {
            throw new TypeError(`groupby: attribute "${val}" resolved to undefined`);
        }
        (result[key] || (result[key] = [])).push(value);
    }
    return result;
}
function toArray(obj) {
    return Array.prototype.slice.call(obj);
}
function without(array) {
    const result = [];
    if (!array) {
        return result;
    }
    const length = array.length;
    const contains = toArray(arguments).slice(1);
    let index = -1;
    while(++index < length){
        if (indexOf(contains, array[index]) === -1) {
            result.push(array[index]);
        }
    }
    return result;
}
function repeat(char_, n) {
    var str = "";
    for(let i = 0; i < n; i++){
        str += char_;
    }
    return str;
}
function each(obj, func, context) {
    if (obj == null) {
        return;
    }
    if (ArrayProto.forEach && obj.forEach === ArrayProto.forEach) {
        obj.forEach(func, context);
    } else if (obj.length === +obj.length) {
        for(let i = 0, l = obj.length; i < l; i++){
            func.call(context, obj[i], i, obj);
        }
    }
}
function map(obj, func) {
    var results = [];
    if (obj == null) {
        return results;
    }
    if (ArrayProto.map && obj.map === ArrayProto.map) {
        return obj.map(func);
    }
    for(let i = 0; i < obj.length; i++){
        results[results.length] = func(obj[i], i);
    }
    if (obj.length === +obj.length) {
        results.length = obj.length;
    }
    return results;
}
function asyncIter(arr, iter, cb) {
    let i = -1;
    function next() {
        i++;
        if (i < arr.length) {
            iter(arr[i], i, next, cb);
        } else {
            cb();
        }
    }
    next();
}
function asyncFor(obj, iter, cb) {
    const keys = keys_(obj || {});
    const len = keys.length;
    let i = -1;
    function next() {
        i++;
        const k = keys[i];
        if (i < len) {
            iter(k, obj[k], i, len, next);
        } else {
            cb();
        }
    }
    next();
}
function indexOf(arr, searchElement, fromIndex) {
    return Array.prototype.indexOf.call(arr || [], searchElement, fromIndex);
}
function keys_(obj) {
    const arr = [];
    for(let k in obj){
        if (hasOwnProp(obj, k)) {
            arr.push(k);
        }
    }
    return arr;
}
function _entries(obj) {
    return keys_(obj).map((k)=>[
            k,
            obj[k]
        ]);
}
function _values(obj) {
    return keys_(obj).map((k)=>obj[k]);
}
function extend(obj1, obj2) {
    obj1 = obj1 || {};
    keys_(obj2).forEach((k)=>{
        obj1[k] = obj2[k];
    });
    return obj1;
}
function inOperator(key, val) {
    if (isArray(val) || isString(val)) {
        return val.indexOf(key) !== -1;
    } else if (isObject1(val)) {
        return key in val;
    }
    throw new Error('Cannot use "in" operator to search for "' + key + '" in unexpected types.');
}
const mod4 = {
    keys: keys_,
    _assign: extend,
    hasOwnProp: hasOwnProp,
    _prettifyError: _prettifyError,
    TemplateError: TemplateError,
    escape: escape,
    isFunction: isFunction,
    isArray: isArray,
    isString: isString,
    isObject: isObject1,
    getAttrGetter: getAttrGetter,
    groupBy: groupBy,
    toArray: toArray,
    without: without,
    repeat: repeat,
    each: each,
    map: map,
    asyncIter: asyncIter,
    asyncFor: asyncFor,
    indexOf: indexOf,
    _entries: _entries,
    _values: _values,
    extend: extend,
    inOperator: inOperator
};
function __default1(tasks, callback = function() {}, forceAsync) {
    const nextTick = forceAsync ? queueMicrotask : executeSync;
    if (!Array.isArray(tasks)) {
        return callback(new Error("First argument to waterfall must be an array of functions"));
    }
    if (!tasks.length) {
        return callback();
    }
    function wrapIterator(iterator) {
        return function(err, ...results) {
            if (err) {
                callback(err, ...results);
                callback = ()=>{};
                return;
            }
            const next = iterator.next();
            if (next) {
                results.push(wrapIterator(next));
            } else {
                results.push(callback);
            }
            nextTick(()=>iterator(...results));
        };
    }
    wrapIterator(makeIterator(tasks))();
}
function executeSync(fn, ...args) {
    if (typeof fn === "function") {
        fn(...args);
    }
}
function makeIterator(tasks) {
    function makeCallback(index) {
        const fn = function() {
            if (tasks.length) {
                tasks[index].apply(null, arguments);
            }
            return fn.next();
        };
        fn.next = ()=>index < tasks.length - 1 ? makeCallback(index + 1) : null;
        return fn;
    }
    return makeCallback(0);
}
let whitespaceChars = " \n\t\r\u00A0";
let delimChars = "()[]{}%*-+~/#,:|.<>=!";
let intChars = "0123456789";
let BLOCK_START = "{%";
let BLOCK_END = "%}";
let VARIABLE_START = "{{";
let VARIABLE_END = "}}";
let COMMENT_START = "{#";
let COMMENT_END = "#}";
let TOKEN_STRING = "string";
let TOKEN_WHITESPACE = "whitespace";
let TOKEN_DATA = "data";
let TOKEN_BLOCK_START = "block-start";
let TOKEN_BLOCK_END = "block-end";
let TOKEN_VARIABLE_START = "variable-start";
let TOKEN_VARIABLE_END = "variable-end";
let TOKEN_COMMENT = "comment";
let TOKEN_LEFT_PAREN = "left-paren";
let TOKEN_RIGHT_PAREN = "right-paren";
let TOKEN_LEFT_BRACKET = "left-bracket";
let TOKEN_RIGHT_BRACKET = "right-bracket";
let TOKEN_LEFT_CURLY = "left-curly";
let TOKEN_RIGHT_CURLY = "right-curly";
let TOKEN_OPERATOR = "operator";
let TOKEN_COMMA = "comma";
let TOKEN_COLON = "colon";
let TOKEN_TILDE = "tilde";
let TOKEN_PIPE = "pipe";
let TOKEN_INT = "int";
let TOKEN_FLOAT = "float";
let TOKEN_BOOLEAN = "boolean";
let TOKEN_NONE = "none";
let TOKEN_SYMBOL = "symbol";
let TOKEN_SPECIAL = "special";
let TOKEN_REGEX = "regex";
function token(type, value, lineno, colno) {
    return {
        type: type,
        value: value,
        lineno: lineno,
        colno: colno
    };
}
class Tokenizer {
    constructor(str, opts){
        this.str = str;
        this.index = 0;
        this.len = str.length;
        this.lineno = 0;
        this.colno = 0;
        this.in_code = false;
        opts = opts || {};
        let tags = opts.tags || {};
        this.tags = {
            BLOCK_START: tags.blockStart || BLOCK_START,
            BLOCK_END: tags.blockEnd || BLOCK_END,
            VARIABLE_START: tags.variableStart || VARIABLE_START,
            VARIABLE_END: tags.variableEnd || VARIABLE_END,
            COMMENT_START: tags.commentStart || COMMENT_START,
            COMMENT_END: tags.commentEnd || COMMENT_END
        };
        this.trimBlocks = !!opts.trimBlocks;
        this.lstripBlocks = !!opts.lstripBlocks;
    }
    nextToken() {
        let lineno = this.lineno;
        let colno = this.colno;
        let tok;
        if (this.in_code) {
            let cur = this.current();
            if (this.isFinished()) {
                return null;
            } else if (cur === '"' || cur === "'") {
                return token(TOKEN_STRING, this._parseString(cur), lineno, colno);
            } else if (tok = this._extract(whitespaceChars)) {
                return token(TOKEN_WHITESPACE, tok, lineno, colno);
            } else if ((tok = this._extractString(this.tags.BLOCK_END)) || (tok = this._extractString("-" + this.tags.BLOCK_END))) {
                this.in_code = false;
                if (this.trimBlocks) {
                    cur = this.current();
                    if (cur === "\n") {
                        this.forward();
                    } else if (cur === "\r") {
                        this.forward();
                        cur = this.current();
                        if (cur === "\n") {
                            this.forward();
                        } else {
                            this.back();
                        }
                    }
                }
                return token(TOKEN_BLOCK_END, tok, lineno, colno);
            } else if ((tok = this._extractString(this.tags.VARIABLE_END)) || (tok = this._extractString("-" + this.tags.VARIABLE_END))) {
                this.in_code = false;
                return token(TOKEN_VARIABLE_END, tok, lineno, colno);
            } else if (cur === "r" && this.str.charAt(this.index + 1) === "/") {
                this.forwardN(2);
                let regexBody = "";
                while(!this.isFinished()){
                    if (this.current() === "/" && this.previous() !== "\\") {
                        this.forward();
                        break;
                    } else {
                        regexBody += this.current();
                        this.forward();
                    }
                }
                let POSSIBLE_FLAGS = [
                    "g",
                    "i",
                    "m",
                    "y"
                ];
                let regexFlags = "";
                while(!this.isFinished()){
                    let isCurrentAFlag = POSSIBLE_FLAGS.indexOf(this.current()) !== -1;
                    if (isCurrentAFlag) {
                        regexFlags += this.current();
                        this.forward();
                    } else {
                        break;
                    }
                }
                return token(TOKEN_REGEX, {
                    body: regexBody,
                    flags: regexFlags
                }, lineno, colno);
            } else if (delimChars.indexOf(cur) !== -1) {
                this.forward();
                let complexOps = [
                    "==",
                    "===",
                    "!=",
                    "!==",
                    "<=",
                    ">=",
                    "//",
                    "**"
                ];
                let curComplex = cur + this.current();
                let type;
                if (indexOf(complexOps, curComplex) !== -1) {
                    this.forward();
                    cur = curComplex;
                    if (indexOf(complexOps, curComplex + this.current()) !== -1) {
                        cur = curComplex + this.current();
                        this.forward();
                    }
                }
                switch(cur){
                    case "(":
                        type = TOKEN_LEFT_PAREN;
                        break;
                    case ")":
                        type = TOKEN_RIGHT_PAREN;
                        break;
                    case "[":
                        type = TOKEN_LEFT_BRACKET;
                        break;
                    case "]":
                        type = TOKEN_RIGHT_BRACKET;
                        break;
                    case "{":
                        type = TOKEN_LEFT_CURLY;
                        break;
                    case "}":
                        type = TOKEN_RIGHT_CURLY;
                        break;
                    case ",":
                        type = TOKEN_COMMA;
                        break;
                    case ":":
                        type = TOKEN_COLON;
                        break;
                    case "~":
                        type = TOKEN_TILDE;
                        break;
                    case "|":
                        type = TOKEN_PIPE;
                        break;
                    default:
                        type = TOKEN_OPERATOR;
                }
                return token(type, cur, lineno, colno);
            } else {
                tok = this._extractUntil(whitespaceChars + delimChars);
                if (tok.match(/^[-+]?[0-9]+$/)) {
                    if (this.current() === ".") {
                        this.forward();
                        let dec = this._extract(intChars);
                        return token(TOKEN_FLOAT, tok + "." + dec, lineno, colno);
                    } else {
                        return token(TOKEN_INT, tok, lineno, colno);
                    }
                } else if (tok.match(/^(true|false)$/)) {
                    return token(TOKEN_BOOLEAN, tok, lineno, colno);
                } else if (tok === "none") {
                    return token(TOKEN_NONE, tok, lineno, colno);
                } else if (tok === "null") {
                    return token(TOKEN_NONE, tok, lineno, colno);
                } else if (tok) {
                    return token(TOKEN_SYMBOL, tok, lineno, colno);
                } else {
                    throw new Error("Unexpected value while parsing: " + tok);
                }
            }
        } else {
            let beginChars = this.tags.BLOCK_START.charAt(0) + this.tags.VARIABLE_START.charAt(0) + this.tags.COMMENT_START.charAt(0) + this.tags.COMMENT_END.charAt(0);
            if (this.isFinished()) {
                return null;
            } else if ((tok = this._extractString(this.tags.BLOCK_START + "-")) || (tok = this._extractString(this.tags.BLOCK_START))) {
                this.in_code = true;
                return token(TOKEN_BLOCK_START, tok, lineno, colno);
            } else if ((tok = this._extractString(this.tags.VARIABLE_START + "-")) || (tok = this._extractString(this.tags.VARIABLE_START))) {
                this.in_code = true;
                return token(TOKEN_VARIABLE_START, tok, lineno, colno);
            } else {
                tok = "";
                let data;
                let inComment = false;
                if (this._matches(this.tags.COMMENT_START)) {
                    inComment = true;
                    tok = this._extractString(this.tags.COMMENT_START);
                }
                while((data = this._extractUntil(beginChars)) !== null){
                    tok += data;
                    if ((this._matches(this.tags.BLOCK_START) || this._matches(this.tags.VARIABLE_START) || this._matches(this.tags.COMMENT_START)) && !inComment) {
                        if (this.lstripBlocks && this._matches(this.tags.BLOCK_START) && this.colno > 0 && this.colno <= tok.length) {
                            let lastLine = tok.slice(-this.colno);
                            if (/^\s+$/.test(lastLine)) {
                                tok = tok.slice(0, -this.colno);
                                if (!tok.length) {
                                    return this.nextToken();
                                }
                            }
                        }
                        break;
                    } else if (this._matches(this.tags.COMMENT_END)) {
                        if (!inComment) {
                            throw new Error("unexpected end of comment");
                        }
                        tok += this._extractString(this.tags.COMMENT_END);
                        break;
                    } else {
                        tok += this.current();
                        this.forward();
                    }
                }
                if (data === null && inComment) {
                    throw new Error("expected end of comment, got end of file");
                }
                return token(inComment ? TOKEN_COMMENT : TOKEN_DATA, tok, lineno, colno);
            }
        }
    }
    _parseString(delimiter) {
        this.forward();
        let str = "";
        while(!this.isFinished() && this.current() !== delimiter){
            let cur = this.current();
            if (cur === "\\") {
                this.forward();
                switch(this.current()){
                    case "n":
                        str += "\n";
                        break;
                    case "t":
                        str += "\t";
                        break;
                    case "r":
                        str += "\r";
                        break;
                    default:
                        str += this.current();
                }
                this.forward();
            } else {
                str += cur;
                this.forward();
            }
        }
        this.forward();
        return str;
    }
    _matches(str) {
        if (this.index + str.length > this.len) {
            return null;
        }
        let m = this.str.slice(this.index, this.index + str.length);
        return m === str;
    }
    _extractString(str) {
        if (this._matches(str)) {
            this.forwardN(str.length);
            return str;
        }
        return null;
    }
    _extractUntil(charString) {
        return this._extractMatching(true, charString || "");
    }
    _extract(charString) {
        return this._extractMatching(false, charString);
    }
    _extractMatching(breakOnMatch, charString) {
        if (this.isFinished()) {
            return null;
        }
        let first = charString.indexOf(this.current());
        if (breakOnMatch && first === -1 || !breakOnMatch && first !== -1) {
            let t = this.current();
            this.forward();
            let idx = charString.indexOf(this.current());
            while((breakOnMatch && idx === -1 || !breakOnMatch && idx !== -1) && !this.isFinished()){
                t += this.current();
                this.forward();
                idx = charString.indexOf(this.current());
            }
            return t;
        }
        return "";
    }
    _extractRegex(regex) {
        let matches = this.currentStr().match(regex);
        if (!matches) {
            return null;
        }
        this.forwardN(matches[0].length);
        return matches;
    }
    isFinished() {
        return this.index >= this.len;
    }
    forwardN(n) {
        for(let i = 0; i < n; i++){
            this.forward();
        }
    }
    forward() {
        this.index++;
        if (this.previous() === "\n") {
            this.lineno++;
            this.colno = 0;
        } else {
            this.colno++;
        }
    }
    backN(n) {
        for(let i = 0; i < n; i++){
            this.back();
        }
    }
    back() {
        this.index--;
        if (this.current() === "\n") {
            this.lineno--;
            let idx = this.src.lastIndexOf("\n", this.index - 1);
            if (idx === -1) {
                this.colno = this.index;
            } else {
                this.colno = this.index - idx;
            }
        } else {
            this.colno--;
        }
    }
    current() {
        if (!this.isFinished()) {
            return this.str.charAt(this.index);
        }
        return "";
    }
    currentStr() {
        if (!this.isFinished()) {
            return this.str.substr(this.index);
        }
        return "";
    }
    previous() {
        return this.str.charAt(this.index - 1);
    }
}
const __default2 = {
    lex (src, opts) {
        return new Tokenizer(src, opts);
    },
    TOKEN_STRING: TOKEN_STRING,
    TOKEN_WHITESPACE: TOKEN_WHITESPACE,
    TOKEN_DATA: TOKEN_DATA,
    TOKEN_BLOCK_START: TOKEN_BLOCK_START,
    TOKEN_BLOCK_END: TOKEN_BLOCK_END,
    TOKEN_VARIABLE_START: TOKEN_VARIABLE_START,
    TOKEN_VARIABLE_END: TOKEN_VARIABLE_END,
    TOKEN_COMMENT: TOKEN_COMMENT,
    TOKEN_LEFT_PAREN: TOKEN_LEFT_PAREN,
    TOKEN_RIGHT_PAREN: TOKEN_RIGHT_PAREN,
    TOKEN_LEFT_BRACKET: TOKEN_LEFT_BRACKET,
    TOKEN_RIGHT_BRACKET: TOKEN_RIGHT_BRACKET,
    TOKEN_LEFT_CURLY: TOKEN_LEFT_CURLY,
    TOKEN_RIGHT_CURLY: TOKEN_RIGHT_CURLY,
    TOKEN_OPERATOR: TOKEN_OPERATOR,
    TOKEN_COMMA: TOKEN_COMMA,
    TOKEN_COLON: TOKEN_COLON,
    TOKEN_TILDE: TOKEN_TILDE,
    TOKEN_PIPE: TOKEN_PIPE,
    TOKEN_INT: TOKEN_INT,
    TOKEN_FLOAT: TOKEN_FLOAT,
    TOKEN_BOOLEAN: TOKEN_BOOLEAN,
    TOKEN_NONE: TOKEN_NONE,
    TOKEN_SYMBOL: TOKEN_SYMBOL,
    TOKEN_SPECIAL: TOKEN_SPECIAL,
    TOKEN_REGEX: TOKEN_REGEX
};
const osType2 = (()=>{
    if (globalThis.Deno != null) {
        return Deno.build.os;
    }
    const navigator = globalThis.navigator;
    if (navigator?.appVersion?.includes?.("Win") ?? false) {
        return "windows";
    }
    return "linux";
})();
const isWindows2 = osType2 === "windows";
const CHAR_FORWARD_SLASH2 = 47;
function assertPath2(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator2(code) {
    return code === 47;
}
function isPathSeparator2(code) {
    return isPosixPathSeparator2(code) || code === 92;
}
function isWindowsDeviceRoot2(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString2(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH2;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format2(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS2 = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace2(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS2[c] ?? c;
    });
}
class DenoStdInternalError2 extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert2(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError2(msg);
    }
}
const sep6 = "\\";
const delimiter6 = ";";
function resolve7(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno.cwd();
        } else {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno.env.get(`=${resolvedDevice}`) || Deno.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath2(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator2(code)) {
                isAbsolute = true;
                if (isPathSeparator2(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator2(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator2(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator2(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot2(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator2(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator2(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString2(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator2);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize8(path) {
    assertPath2(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator2(code)) {
            isAbsolute = true;
            if (isPathSeparator2(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator2(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator2(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator2(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot2(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator2(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator2(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString2(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator2);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator2(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute6(path) {
    assertPath2(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator2(code)) {
        return true;
    } else if (isWindowsDeviceRoot2(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator2(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join8(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath2(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert2(firstPart != null);
    if (isPathSeparator2(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator2(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator2(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator2(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize8(joined);
}
function relative6(from, to) {
    assertPath2(from);
    assertPath2(to);
    if (from === to) return "";
    const fromOrig = resolve7(from);
    const toOrig = resolve7(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath6(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve7(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot2(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname6(path) {
    assertPath2(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator2(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator2(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator2(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator2(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator2(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot2(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator2(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator2(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator2(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path.slice(0, end);
}
function basename6(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath2(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot2(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= start; --i){
            const code = path.charCodeAt(i);
            if (isPathSeparator2(code)) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= start; --i){
            if (isPathSeparator2(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname6(path) {
    assertPath2(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot2(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator2(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format7(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format2("\\", pathObject);
}
function parse6(path) {
    assertPath2(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator2(code)) {
            rootEnd = 1;
            if (isPathSeparator2(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator2(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator2(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator2(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot2(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator2(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator2(code)) {
        ret.root = ret.dir = path;
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator2(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl6(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl6(path) {
    if (!isAbsolute6(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace2(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod5 = {
    sep: sep6,
    delimiter: delimiter6,
    resolve: resolve7,
    normalize: normalize8,
    isAbsolute: isAbsolute6,
    join: join8,
    relative: relative6,
    toNamespacedPath: toNamespacedPath6,
    dirname: dirname6,
    basename: basename6,
    extname: extname6,
    format: format7,
    parse: parse6,
    fromFileUrl: fromFileUrl6,
    toFileUrl: toFileUrl6
};
const sep7 = "/";
const delimiter7 = ":";
function resolve8(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno.cwd();
        }
        assertPath2(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH2;
    }
    resolvedPath = normalizeString2(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator2);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize9(path) {
    assertPath2(path);
    if (path.length === 0) return ".";
    const isAbsolute = path.charCodeAt(0) === 47;
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeString2(path, !isAbsolute, "/", isPosixPathSeparator2);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute7(path) {
    assertPath2(path);
    return path.length > 0 && path.charCodeAt(0) === 47;
}
function join9(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath2(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize9(joined);
}
function relative7(from, to) {
    assertPath2(from);
    assertPath2(to);
    if (from === to) return "";
    from = resolve8(from);
    to = resolve8(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath7(path) {
    return path;
}
function dirname7(path) {
    assertPath2(path);
    if (path.length === 0) return ".";
    const hasRoot = path.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i = path.length - 1; i >= 1; --i){
        if (path.charCodeAt(i) === 47) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path.slice(0, end);
}
function basename7(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath2(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= 0; --i){
            const code = path.charCodeAt(i);
            if (code === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= 0; --i){
            if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname7(path) {
    assertPath2(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format8(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format2("/", pathObject);
}
function parse7(path) {
    assertPath2(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = path.charCodeAt(0) === 47;
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl7(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl7(path) {
    if (!isAbsolute7(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace2(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod6 = {
    sep: sep7,
    delimiter: delimiter7,
    resolve: resolve8,
    normalize: normalize9,
    isAbsolute: isAbsolute7,
    join: join9,
    relative: relative7,
    toNamespacedPath: toNamespacedPath7,
    dirname: dirname7,
    basename: basename7,
    extname: extname7,
    format: format8,
    parse: parse7,
    fromFileUrl: fromFileUrl7,
    toFileUrl: toFileUrl7
};
const SEP = isWindows2 ? "\\" : "/";
const SEP_PATTERN = isWindows2 ? /[\\/]+/ : /\/+/;
function common(paths, sep = SEP) {
    const [first = "", ...remaining] = paths;
    if (first === "" || remaining.length === 0) {
        return first.substring(0, first.lastIndexOf(sep) + 1);
    }
    const parts = first.split(sep);
    let endOfPrefix = parts.length;
    for (const path of remaining){
        const compare = path.split(sep);
        for(let i = 0; i < endOfPrefix; i++){
            if (compare[i] !== parts[i]) {
                endOfPrefix = i;
            }
        }
        if (endOfPrefix === 0) {
            return "";
        }
    }
    const prefix = parts.slice(0, endOfPrefix).join(sep);
    return prefix.endsWith(sep) ? prefix : `${prefix}${sep}`;
}
const path4 = isWindows2 ? mod5 : mod6;
const { join: join10 , normalize: normalize10  } = path4;
const regExpEscapeChars = [
    "!",
    "$",
    "(",
    ")",
    "*",
    "+",
    ".",
    "=",
    "?",
    "[",
    "\\",
    "^",
    "{",
    "|"
];
const rangeEscapeChars = [
    "-",
    "\\",
    "]"
];
function globToRegExp(glob, { extended =true , globstar: globstarOption = true , os =osType2 , caseInsensitive =false  } = {}) {
    if (glob == "") {
        return /(?!)/;
    }
    const sep = os == "windows" ? "(?:\\\\|/)+" : "/+";
    const sepMaybe = os == "windows" ? "(?:\\\\|/)*" : "/*";
    const seps = os == "windows" ? [
        "\\",
        "/"
    ] : [
        "/"
    ];
    const globstar = os == "windows" ? "(?:[^\\\\/]*(?:\\\\|/|$)+)*" : "(?:[^/]*(?:/|$)+)*";
    const wildcard = os == "windows" ? "[^\\\\/]*" : "[^/]*";
    const escapePrefix = os == "windows" ? "`" : "\\";
    let newLength = glob.length;
    for(; newLength > 1 && seps.includes(glob[newLength - 1]); newLength--);
    glob = glob.slice(0, newLength);
    let regExpString = "";
    for(let j = 0; j < glob.length;){
        let segment = "";
        const groupStack = [];
        let inRange = false;
        let inEscape = false;
        let endsWithSep = false;
        let i = j;
        for(; i < glob.length && !seps.includes(glob[i]); i++){
            if (inEscape) {
                inEscape = false;
                const escapeChars = inRange ? rangeEscapeChars : regExpEscapeChars;
                segment += escapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
                continue;
            }
            if (glob[i] == escapePrefix) {
                inEscape = true;
                continue;
            }
            if (glob[i] == "[") {
                if (!inRange) {
                    inRange = true;
                    segment += "[";
                    if (glob[i + 1] == "!") {
                        i++;
                        segment += "^";
                    } else if (glob[i + 1] == "^") {
                        i++;
                        segment += "\\^";
                    }
                    continue;
                } else if (glob[i + 1] == ":") {
                    let k = i + 1;
                    let value = "";
                    while(glob[k + 1] != null && glob[k + 1] != ":"){
                        value += glob[k + 1];
                        k++;
                    }
                    if (glob[k + 1] == ":" && glob[k + 2] == "]") {
                        i = k + 2;
                        if (value == "alnum") segment += "\\dA-Za-z";
                        else if (value == "alpha") segment += "A-Za-z";
                        else if (value == "ascii") segment += "\x00-\x7F";
                        else if (value == "blank") segment += "\t ";
                        else if (value == "cntrl") segment += "\x00-\x1F\x7F";
                        else if (value == "digit") segment += "\\d";
                        else if (value == "graph") segment += "\x21-\x7E";
                        else if (value == "lower") segment += "a-z";
                        else if (value == "print") segment += "\x20-\x7E";
                        else if (value == "punct") {
                            segment += "!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_‘{|}~";
                        } else if (value == "space") segment += "\\s\v";
                        else if (value == "upper") segment += "A-Z";
                        else if (value == "word") segment += "\\w";
                        else if (value == "xdigit") segment += "\\dA-Fa-f";
                        continue;
                    }
                }
            }
            if (glob[i] == "]" && inRange) {
                inRange = false;
                segment += "]";
                continue;
            }
            if (inRange) {
                if (glob[i] == "\\") {
                    segment += `\\\\`;
                } else {
                    segment += glob[i];
                }
                continue;
            }
            if (glob[i] == ")" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
                segment += ")";
                const type = groupStack.pop();
                if (type == "!") {
                    segment += wildcard;
                } else if (type != "@") {
                    segment += type;
                }
                continue;
            }
            if (glob[i] == "|" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
                segment += "|";
                continue;
            }
            if (glob[i] == "+" && extended && glob[i + 1] == "(") {
                i++;
                groupStack.push("+");
                segment += "(?:";
                continue;
            }
            if (glob[i] == "@" && extended && glob[i + 1] == "(") {
                i++;
                groupStack.push("@");
                segment += "(?:";
                continue;
            }
            if (glob[i] == "?") {
                if (extended && glob[i + 1] == "(") {
                    i++;
                    groupStack.push("?");
                    segment += "(?:";
                } else {
                    segment += ".";
                }
                continue;
            }
            if (glob[i] == "!" && extended && glob[i + 1] == "(") {
                i++;
                groupStack.push("!");
                segment += "(?!";
                continue;
            }
            if (glob[i] == "{") {
                groupStack.push("BRACE");
                segment += "(?:";
                continue;
            }
            if (glob[i] == "}" && groupStack[groupStack.length - 1] == "BRACE") {
                groupStack.pop();
                segment += ")";
                continue;
            }
            if (glob[i] == "," && groupStack[groupStack.length - 1] == "BRACE") {
                segment += "|";
                continue;
            }
            if (glob[i] == "*") {
                if (extended && glob[i + 1] == "(") {
                    i++;
                    groupStack.push("*");
                    segment += "(?:";
                } else {
                    const prevChar = glob[i - 1];
                    let numStars = 1;
                    while(glob[i + 1] == "*"){
                        i++;
                        numStars++;
                    }
                    const nextChar = glob[i + 1];
                    if (globstarOption && numStars == 2 && [
                        ...seps,
                        undefined
                    ].includes(prevChar) && [
                        ...seps,
                        undefined
                    ].includes(nextChar)) {
                        segment += globstar;
                        endsWithSep = true;
                    } else {
                        segment += wildcard;
                    }
                }
                continue;
            }
            segment += regExpEscapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
        }
        if (groupStack.length > 0 || inRange || inEscape) {
            segment = "";
            for (const c of glob.slice(j, i)){
                segment += regExpEscapeChars.includes(c) ? `\\${c}` : c;
                endsWithSep = false;
            }
        }
        regExpString += segment;
        if (!endsWithSep) {
            regExpString += i < glob.length ? sep : sepMaybe;
            endsWithSep = true;
        }
        while(seps.includes(glob[i]))i++;
        if (!(i > j)) {
            throw new Error("Assertion failure: i > j (potential infinite loop)");
        }
        j = i;
    }
    regExpString = `^${regExpString}$`;
    return new RegExp(regExpString, caseInsensitive ? "i" : "");
}
function isGlob(str) {
    const chars = {
        "{": "}",
        "(": ")",
        "[": "]"
    };
    const regex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
    if (str === "") {
        return false;
    }
    let match;
    while(match = regex.exec(str)){
        if (match[2]) return true;
        let idx = match.index + match[0].length;
        const open = match[1];
        const close = open ? chars[open] : null;
        if (open && close) {
            const n = str.indexOf(close, idx);
            if (n !== -1) {
                idx = n + 1;
            }
        }
        str = str.slice(idx);
    }
    return false;
}
function normalizeGlob(glob, { globstar =false  } = {}) {
    if (glob.match(/\0/g)) {
        throw new Error(`Glob contains invalid characters: "${glob}"`);
    }
    if (!globstar) {
        return normalize10(glob);
    }
    const s = SEP_PATTERN.source;
    const badParentPattern = new RegExp(`(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`, "g");
    return normalize10(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
}
function joinGlobs(globs, { extended =false , globstar =false  } = {}) {
    if (!globstar || globs.length == 0) {
        return join10(...globs);
    }
    if (globs.length === 0) return ".";
    let joined;
    for (const glob of globs){
        const path = glob;
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `${SEP}${path}`;
        }
    }
    if (!joined) return ".";
    return normalizeGlob(joined, {
        extended,
        globstar
    });
}
const path5 = isWindows2 ? mod5 : mod6;
const { basename: basename8 , delimiter: delimiter8 , dirname: dirname8 , extname: extname8 , format: format9 , fromFileUrl: fromFileUrl8 , isAbsolute: isAbsolute8 , join: join11 , normalize: normalize11 , parse: parse8 , relative: relative8 , resolve: resolve9 , sep: sep8 , toFileUrl: toFileUrl8 , toNamespacedPath: toNamespacedPath8 ,  } = path5;
const mod7 = {
    SEP: SEP,
    SEP_PATTERN: SEP_PATTERN,
    win32: mod5,
    posix: mod6,
    basename: basename8,
    delimiter: delimiter8,
    dirname: dirname8,
    extname: extname8,
    format: format9,
    fromFileUrl: fromFileUrl8,
    isAbsolute: isAbsolute8,
    join: join11,
    normalize: normalize11,
    parse: parse8,
    relative: relative8,
    resolve: resolve9,
    sep: sep8,
    toFileUrl: toFileUrl8,
    toNamespacedPath: toNamespacedPath8,
    common,
    globToRegExp,
    isGlob,
    normalizeGlob,
    joinGlobs
};
class EventEmitter1 {
    events = new Map();
    maxListeners;
    #defaultMaxListeners = 10;
    get defaultMaxListeners() {
        return this.#defaultMaxListeners;
    }
    set defaultMaxListeners(n) {
        if (Number.isInteger(n) || n < 0) {
            const error = new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative integer. Received ' + n + '.');
            throw error;
        }
        this.#defaultMaxListeners = n;
    }
    addListener(eventName, listener) {
        return this.on(eventName, listener);
    }
    emit(eventName, ...args) {
        const listeners = this.events.get(eventName);
        if (listeners === undefined) {
            if (eventName === 'error') {
                const error = args[0];
                if (error instanceof Error) throw error;
                throw new Error('Unhandled error.');
            }
            return false;
        }
        const copyListeners = [
            ...listeners
        ];
        for (const listener of copyListeners){
            listener.apply(this, args);
        }
        return true;
    }
    setMaxListeners(n) {
        if (!Number.isInteger(n) || n < 0) {
            throw new RangeError('The value of "n" is out of range. It must be a non-negative integer. Received ' + n + '.');
        }
        this.maxListeners = n;
        return this;
    }
    getMaxListeners() {
        if (this.maxListeners === undefined) {
            return this.defaultMaxListeners;
        }
        return this.maxListeners;
    }
    listenerCount(eventName) {
        const events = this.events.get(eventName);
        return events === undefined ? 0 : events.length;
    }
    eventNames() {
        return Reflect.ownKeys(this.events);
    }
    listeners(eventName) {
        const listeners = this.events.get(eventName);
        return listeners === undefined ? [] : listeners;
    }
    off(eventName, listener) {
        return this.removeListener(eventName, listener);
    }
    on(eventName, listener, prepend) {
        if (this.events.has(eventName) === false) {
            this.events.set(eventName, []);
        }
        const events = this.events.get(eventName);
        if (prepend) {
            events.unshift(listener);
        } else {
            events.push(listener);
        }
        if (eventName !== "newListener" && this.events.has("newListener")) {
            this.emit('newListener', eventName, listener);
        }
        const maxListener = this.getMaxListeners();
        const eventLength = events.length;
        if (maxListener > 0 && eventLength > maxListener && !events.warned) {
            events.warned = true;
            const warning = new Error(`Possible EventEmitter memory leak detected.
         ${this.listenerCount(eventName)} ${eventName.toString()} listeners.
         Use emitter.setMaxListeners() to increase limit`);
            warning.name = "MaxListenersExceededWarning";
            console.warn(warning);
        }
        return this;
    }
    removeAllListeners(eventName) {
        const events = this.events;
        if (!events.has('removeListener')) {
            if (arguments.length === 0) {
                this.events = new Map();
            } else if (events.has(eventName)) {
                events.delete(eventName);
            }
            return this;
        }
        if (arguments.length === 0) {
            for (const key of events.keys()){
                if (key === 'removeListener') continue;
                this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this.events = new Map();
            return this;
        }
        const listeners = events.get(eventName);
        if (listeners !== undefined) {
            listeners.map((listener)=>{
                this.removeListener(eventName, listener);
            });
        }
        return this;
    }
    removeListener(eventName, listener) {
        const events = this.events;
        if (events.size === 0) return this;
        const list = events.get(eventName);
        if (list === undefined) return this;
        const index = list.findIndex((item)=>item === listener || item.listener === listener);
        if (index === -1) return this;
        list.splice(index, 1);
        if (list.length === 0) this.events.delete(eventName);
        if (events.has('removeListener')) {
            this.emit('removeListener', eventName, listener);
        }
        return this;
    }
    once(eventName, listener) {
        this.on(eventName, this.onceWrap(eventName, listener));
        return this;
    }
    onceWrap(eventName, listener) {
        const wrapper = function(...args) {
            this.context.removeListener(this.eventName, this.wrapedListener);
            this.listener.apply(this.context, args);
        };
        const wrapperContext = {
            eventName: eventName,
            listener: listener,
            wrapedListener: wrapper,
            context: this
        };
        const wrapped = wrapper.bind(wrapperContext);
        wrapperContext.wrapedListener = wrapped;
        wrapped.listener = listener;
        return wrapped;
    }
    prependListener(eventName, listener) {
        return this.on(eventName, listener, true);
    }
    prependOnceListener(eventName, listener) {
        this.prependListener(eventName, this.onceWrap(eventName, listener));
        return this;
    }
    rawListeners(eventName) {
        const events = this.events;
        if (events === undefined) return [];
        const listeners = events.get(eventName);
        if (listeners === undefined) return [];
        return [
            ...listeners
        ];
    }
}
function existsSync(p) {
    try {
        Deno.statSync(p);
        return true;
    } catch  {
        return false;
    }
}
function parentWrap(parent, prop) {
    if (typeof parent !== "function" || typeof prop !== "function") {
        return prop;
    }
    return function wrap() {
        const tmp = this.parent;
        this.parent = parent;
        const res = prop.apply(this, arguments);
        this.parent = tmp;
        return res;
    };
}
function extendClass(cls, name, props) {
    props = props || {};
    keys_(props).forEach((k)=>{
        props[k] = parentWrap(cls.prototype[k], props[k]);
    });
    class subclass extends cls {
        get typename() {
            return name;
        }
    }
    extend(subclass.prototype, props);
    return subclass;
}
class Obj {
    constructor(...args){
        this.init(...args);
    }
    init() {}
    get typename() {
        return this.constructor.name;
    }
    static extend(name, props) {
        if (typeof name === "object") {
            props = name;
            name = "anonymous";
        }
        return extendClass(this, name, props);
    }
}
class EmitterObj extends EventEmitter1 {
    constructor(...args){
        super();
        this.init(...args);
    }
    init() {}
    get typename() {
        return this.constructor.name;
    }
    static extend(name, props) {
        if (typeof name === "object") {
            props = name;
            name = "anonymous";
        }
        return extendClass(this, name, props);
    }
}
function traverseAndCheck(obj, type, results) {
    if (obj instanceof type) {
        results.push(obj);
    }
    if (obj instanceof Node) {
        obj.findAll(type, results);
    }
}
class Node extends Obj {
    init(lineno, colno, ...args) {
        this.lineno = lineno;
        this.colno = colno;
        this.fields.forEach((field, i)=>{
            var val = arguments[i + 2];
            if (val === undefined) {
                val = null;
            }
            this[field] = val;
        });
    }
    findAll(type, results) {
        results = results || [];
        if (this instanceof NodeList) {
            this.children.forEach((child)=>traverseAndCheck(child, type, results));
        } else {
            this.fields.forEach((field)=>traverseAndCheck(this[field], type, results));
        }
        return results;
    }
    iterFields(func) {
        this.fields.forEach((field)=>{
            func(this[field], field);
        });
    }
}
class Value extends Node {
    get typename() {
        return "Value";
    }
    get fields() {
        return [
            "value"
        ];
    }
}
class NodeList extends Node {
    get typename() {
        return "NodeList";
    }
    get fields() {
        return [
            "children"
        ];
    }
    init(lineno, colno, nodes) {
        super.init(lineno, colno, nodes || []);
    }
    addChild(node) {
        this.children.push(node);
    }
}
const Root = NodeList.extend("Root");
const Literal = Value.extend("Literal");
const Symbol1 = Value.extend("Symbol");
const Group = NodeList.extend("Group");
const ArrayNode = NodeList.extend("Array");
const Pair = Node.extend("Pair", {
    fields: [
        "key",
        "value"
    ]
});
const Dict = NodeList.extend("Dict");
const LookupVal = Node.extend("LookupVal", {
    fields: [
        "target",
        "val"
    ]
});
const If = Node.extend("If", {
    fields: [
        "cond",
        "body",
        "else_"
    ]
});
const IfAsync = If.extend("IfAsync");
const InlineIf = Node.extend("InlineIf", {
    fields: [
        "cond",
        "body",
        "else_"
    ]
});
const For = Node.extend("For", {
    fields: [
        "arr",
        "name",
        "body",
        "else_"
    ]
});
const AsyncEach = For.extend("AsyncEach");
const AsyncAll = For.extend("AsyncAll");
const Macro = Node.extend("Macro", {
    fields: [
        "name",
        "args",
        "body"
    ]
});
const Caller = Macro.extend("Caller");
const Import = Node.extend("Import", {
    fields: [
        "template",
        "target",
        "withContext"
    ]
});
class FromImport extends Node {
    get typename() {
        return "FromImport";
    }
    get fields() {
        return [
            "template",
            "names",
            "withContext"
        ];
    }
    init(lineno, colno, template, names, withContext) {
        super.init(lineno, colno, template, names || new NodeList(), withContext);
    }
}
const FunCall = Node.extend("FunCall", {
    fields: [
        "name",
        "args"
    ]
});
const Filter = FunCall.extend("Filter");
const FilterAsync = Filter.extend("FilterAsync", {
    fields: [
        "name",
        "args",
        "symbol"
    ]
});
const KeywordArgs = Dict.extend("KeywordArgs");
const Block = Node.extend("Block", {
    fields: [
        "name",
        "body"
    ]
});
const Super = Node.extend("Super", {
    fields: [
        "blockName",
        "symbol"
    ]
});
const TemplateRef = Node.extend("TemplateRef", {
    fields: [
        "template"
    ]
});
const Extends = TemplateRef.extend("Extends");
const Include = Node.extend("Include", {
    fields: [
        "template",
        "ignoreMissing"
    ]
});
const Set1 = Node.extend("Set", {
    fields: [
        "targets",
        "value"
    ]
});
const Switch = Node.extend("Switch", {
    fields: [
        "expr",
        "cases",
        "default"
    ]
});
const Case = Node.extend("Case", {
    fields: [
        "cond",
        "body"
    ]
});
const Output = NodeList.extend("Output");
const Capture = Node.extend("Capture", {
    fields: [
        "body"
    ]
});
const TemplateData = Literal.extend("TemplateData");
const UnaryOp = Node.extend("UnaryOp", {
    fields: [
        "target"
    ]
});
const BinOp = Node.extend("BinOp", {
    fields: [
        "left",
        "right"
    ]
});
const In = BinOp.extend("In");
const Is = BinOp.extend("Is");
const Or = BinOp.extend("Or");
const And = BinOp.extend("And");
const Not = UnaryOp.extend("Not");
const Add = BinOp.extend("Add");
const Concat = BinOp.extend("Concat");
const Sub = BinOp.extend("Sub");
const Mul = BinOp.extend("Mul");
const Div = BinOp.extend("Div");
const FloorDiv = BinOp.extend("FloorDiv");
const Mod = BinOp.extend("Mod");
const Pow = BinOp.extend("Pow");
const Neg = UnaryOp.extend("Neg");
const Pos = UnaryOp.extend("Pos");
const Compare = Node.extend("Compare", {
    fields: [
        "expr",
        "ops"
    ]
});
const CompareOperand = Node.extend("CompareOperand", {
    fields: [
        "expr",
        "type"
    ]
});
const CallExtension = Node.extend("CallExtension", {
    init (ext, prop, args, contentArgs) {
        this.parent();
        this.extName = ext.__name || ext;
        this.prop = prop;
        this.args = args || new NodeList();
        this.contentArgs = contentArgs || [];
        this.autoescape = ext.autoescape;
    },
    fields: [
        "extName",
        "prop",
        "args",
        "contentArgs"
    ]
});
const CallExtensionAsync = CallExtension.extend("CallExtensionAsync");
function print(str, indent, inline) {
    var lines = str.split("\n");
    lines.forEach((line, i)=>{
        if (line && (inline && i > 0 || !inline)) {
            process.stdout.write(" ".repeat(indent));
        }
        const nl = i === lines.length - 1 ? "" : "\n";
        process.stdout.write(`${line}${nl}`);
    });
}
function printNodes(node, indent) {
    indent = indent || 0;
    print(node.typename + ": ", indent);
    if (node instanceof NodeList) {
        print("\n");
        node.children.forEach((n)=>{
            printNodes(n, indent + 2);
        });
    } else if (node instanceof CallExtension) {
        print(`${node.extName}.${node.prop}\n`);
        if (node.args) {
            printNodes(node.args, indent + 2);
        }
        if (node.contentArgs) {
            node.contentArgs.forEach((n)=>{
                printNodes(n, indent + 2);
            });
        }
    } else {
        let nodes = [];
        let props = null;
        node.iterFields((val, fieldName)=>{
            if (val instanceof Node) {
                nodes.push([
                    fieldName,
                    val
                ]);
            } else {
                props = props || {};
                props[fieldName] = val;
            }
        });
        if (props) {
            print(JSON.stringify(props, null, 2) + "\n", null, true);
        } else {
            print("\n");
        }
        nodes.forEach(([fieldName, n])=>{
            print(`[${fieldName}] =>`, indent + 2);
            printNodes(n, indent + 4);
        });
    }
}
const __default3 = {
    Node: Node,
    Root: Root,
    NodeList: NodeList,
    Value: Value,
    Literal: Literal,
    Symbol: Symbol1,
    Group: Group,
    Array: ArrayNode,
    Pair: Pair,
    Dict: Dict,
    Output: Output,
    Capture: Capture,
    TemplateData: TemplateData,
    If: If,
    IfAsync: IfAsync,
    InlineIf: InlineIf,
    For: For,
    AsyncEach: AsyncEach,
    AsyncAll: AsyncAll,
    Macro: Macro,
    Caller: Caller,
    Import: Import,
    FromImport: FromImport,
    FunCall: FunCall,
    Filter: Filter,
    FilterAsync: FilterAsync,
    KeywordArgs: KeywordArgs,
    Block: Block,
    Super: Super,
    Extends: Extends,
    Include: Include,
    Set: Set1,
    Switch: Switch,
    Case: Case,
    LookupVal: LookupVal,
    BinOp: BinOp,
    In: In,
    Is: Is,
    Or: Or,
    And: And,
    Not: Not,
    Add: Add,
    Concat: Concat,
    Sub: Sub,
    Mul: Mul,
    Div: Div,
    FloorDiv: FloorDiv,
    Mod: Mod,
    Pow: Pow,
    Neg: Neg,
    Pos: Pos,
    Compare: Compare,
    CompareOperand: CompareOperand,
    CallExtension: CallExtension,
    CallExtensionAsync: CallExtensionAsync,
    printNodes: printNodes
};
class Parser extends Obj {
    init(tokens) {
        this.tokens = tokens;
        this.peeked = null;
        this.breakOnBlocks = null;
        this.dropLeadingWhitespace = false;
        this.extensions = [];
    }
    nextToken(withWhitespace) {
        var tok;
        if (this.peeked) {
            if (!withWhitespace && this.peeked.type === __default2.TOKEN_WHITESPACE) {
                this.peeked = null;
            } else {
                tok = this.peeked;
                this.peeked = null;
                return tok;
            }
        }
        tok = this.tokens.nextToken();
        if (!withWhitespace) {
            while(tok && tok.type === __default2.TOKEN_WHITESPACE){
                tok = this.tokens.nextToken();
            }
        }
        return tok;
    }
    peekToken() {
        this.peeked = this.peeked || this.nextToken();
        return this.peeked;
    }
    pushToken(tok) {
        if (this.peeked) {
            throw new Error("pushToken: can only push one token on between reads");
        }
        this.peeked = tok;
    }
    error(msg, lineno, colno) {
        if (lineno === undefined || colno === undefined) {
            const tok = this.peekToken() || {};
            lineno = tok.lineno;
            colno = tok.colno;
        }
        if (lineno !== undefined) {
            lineno += 1;
        }
        if (colno !== undefined) {
            colno += 1;
        }
        return new TemplateError(msg, lineno, colno);
    }
    fail(msg, lineno, colno) {
        throw this.error(msg, lineno, colno);
    }
    skip(type) {
        var tok = this.nextToken();
        if (!tok || tok.type !== type) {
            this.pushToken(tok);
            return false;
        }
        return true;
    }
    expect(type) {
        var tok = this.nextToken();
        if (tok.type !== type) {
            this.fail("expected " + type + ", got " + tok.type, tok.lineno, tok.colno);
        }
        return tok;
    }
    skipValue(type, val) {
        var tok = this.nextToken();
        if (!tok || tok.type !== type || tok.value !== val) {
            this.pushToken(tok);
            return false;
        }
        return true;
    }
    skipSymbol(val) {
        return this.skipValue(__default2.TOKEN_SYMBOL, val);
    }
    advanceAfterBlockEnd(name) {
        var tok;
        if (!name) {
            tok = this.peekToken();
            if (!tok) {
                this.fail("unexpected end of file");
            }
            if (tok.type !== __default2.TOKEN_SYMBOL) {
                this.fail("advanceAfterBlockEnd: expected symbol token or " + "explicit name to be passed");
            }
            name = this.nextToken().value;
        }
        tok = this.nextToken();
        if (tok && tok.type === __default2.TOKEN_BLOCK_END) {
            if (tok.value.charAt(0) === "-") {
                this.dropLeadingWhitespace = true;
            }
        } else {
            this.fail("expected block end in " + name + " statement");
        }
        return tok;
    }
    advanceAfterVariableEnd() {
        var tok = this.nextToken();
        if (tok && tok.type === __default2.TOKEN_VARIABLE_END) {
            this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.VARIABLE_END.length - 1) === "-";
        } else {
            this.pushToken(tok);
            this.fail("expected variable end");
        }
    }
    parseFor() {
        var forTok = this.peekToken();
        var node;
        var endBlock;
        if (this.skipSymbol("for")) {
            node = new __default3.For(forTok.lineno, forTok.colno);
            endBlock = "endfor";
        } else if (this.skipSymbol("asyncEach")) {
            node = new __default3.AsyncEach(forTok.lineno, forTok.colno);
            endBlock = "endeach";
        } else if (this.skipSymbol("asyncAll")) {
            node = new __default3.AsyncAll(forTok.lineno, forTok.colno);
            endBlock = "endall";
        } else {
            this.fail("parseFor: expected for{Async}", forTok.lineno, forTok.colno);
        }
        node.name = this.parsePrimary();
        if (!(node.name instanceof __default3.Symbol)) {
            this.fail("parseFor: variable name expected for loop");
        }
        const type = this.peekToken().type;
        if (type === __default2.TOKEN_COMMA) {
            const key = node.name;
            node.name = new __default3.Array(key.lineno, key.colno);
            node.name.addChild(key);
            while(this.skip(__default2.TOKEN_COMMA)){
                const prim = this.parsePrimary();
                node.name.addChild(prim);
            }
        }
        if (!this.skipSymbol("in")) {
            this.fail('parseFor: expected "in" keyword for loop', forTok.lineno, forTok.colno);
        }
        node.arr = this.parseExpression();
        this.advanceAfterBlockEnd(forTok.value);
        node.body = this.parseUntilBlocks(endBlock, "else");
        if (this.skipSymbol("else")) {
            this.advanceAfterBlockEnd("else");
            node.else_ = this.parseUntilBlocks(endBlock);
        }
        this.advanceAfterBlockEnd();
        return node;
    }
    parseMacro() {
        const macroTok = this.peekToken();
        if (!this.skipSymbol("macro")) {
            this.fail("expected macro");
        }
        const name = this.parsePrimary(true);
        const args = this.parseSignature();
        const node = new __default3.Macro(macroTok.lineno, macroTok.colno, name, args);
        this.advanceAfterBlockEnd(macroTok.value);
        node.body = this.parseUntilBlocks("endmacro");
        this.advanceAfterBlockEnd();
        return node;
    }
    parseCall() {
        var callTok = this.peekToken();
        if (!this.skipSymbol("call")) {
            this.fail("expected call");
        }
        const callerArgs = this.parseSignature(true) || new __default3.NodeList();
        const macroCall = this.parsePrimary();
        this.advanceAfterBlockEnd(callTok.value);
        const body = this.parseUntilBlocks("endcall");
        this.advanceAfterBlockEnd();
        const callerName = new __default3.Symbol(callTok.lineno, callTok.colno, "caller");
        const callerNode = new __default3.Caller(callTok.lineno, callTok.colno, callerName, callerArgs, body);
        const args = macroCall.args.children;
        if (!(args[args.length - 1] instanceof __default3.KeywordArgs)) {
            args.push(new __default3.KeywordArgs());
        }
        const kwargs = args[args.length - 1];
        kwargs.addChild(new __default3.Pair(callTok.lineno, callTok.colno, callerName, callerNode));
        return new __default3.Output(callTok.lineno, callTok.colno, [
            macroCall
        ]);
    }
    parseWithContext() {
        var tok = this.peekToken();
        var withContext = null;
        if (this.skipSymbol("with")) {
            withContext = true;
        } else if (this.skipSymbol("without")) {
            withContext = false;
        }
        if (withContext !== null) {
            if (!this.skipSymbol("context")) {
                this.fail("parseFrom: expected context after with/without", tok.lineno, tok.colno);
            }
        }
        return withContext;
    }
    parseImport() {
        var importTok = this.peekToken();
        if (!this.skipSymbol("import")) {
            this.fail("parseImport: expected import", importTok.lineno, importTok.colno);
        }
        const template = this.parseExpression();
        if (!this.skipSymbol("as")) {
            this.fail('parseImport: expected "as" keyword', importTok.lineno, importTok.colno);
        }
        const target = this.parseExpression();
        const withContext = this.parseWithContext();
        const node = new __default3.Import(importTok.lineno, importTok.colno, template, target, withContext);
        this.advanceAfterBlockEnd(importTok.value);
        return node;
    }
    parseFrom() {
        const fromTok = this.peekToken();
        if (!this.skipSymbol("from")) {
            this.fail("parseFrom: expected from");
        }
        const template = this.parseExpression();
        if (!this.skipSymbol("import")) {
            this.fail("parseFrom: expected import", fromTok.lineno, fromTok.colno);
        }
        const names = new __default3.NodeList();
        let withContext;
        while(1){
            const nextTok = this.peekToken();
            if (nextTok.type === __default2.TOKEN_BLOCK_END) {
                if (!names.children.length) {
                    this.fail("parseFrom: Expected at least one import name", fromTok.lineno, fromTok.colno);
                }
                if (nextTok.value.charAt(0) === "-") {
                    this.dropLeadingWhitespace = true;
                }
                this.nextToken();
                break;
            }
            if (names.children.length > 0 && !this.skip(__default2.TOKEN_COMMA)) {
                this.fail("parseFrom: expected comma", fromTok.lineno, fromTok.colno);
            }
            const name = this.parsePrimary();
            if (name.value.charAt(0) === "_") {
                this.fail("parseFrom: names starting with an underscore cannot be imported", name.lineno, name.colno);
            }
            if (this.skipSymbol("as")) {
                const alias = this.parsePrimary();
                names.addChild(new __default3.Pair(name.lineno, name.colno, name, alias));
            } else {
                names.addChild(name);
            }
            withContext = this.parseWithContext();
        }
        return new __default3.FromImport(fromTok.lineno, fromTok.colno, template, names, withContext);
    }
    parseBlock() {
        const tag = this.peekToken();
        if (!this.skipSymbol("block")) {
            this.fail("parseBlock: expected block", tag.lineno, tag.colno);
        }
        const node = new __default3.Block(tag.lineno, tag.colno);
        node.name = this.parsePrimary();
        if (!(node.name instanceof __default3.Symbol)) {
            this.fail("parseBlock: variable name expected", tag.lineno, tag.colno);
        }
        this.advanceAfterBlockEnd(tag.value);
        node.body = this.parseUntilBlocks("endblock");
        this.skipSymbol("endblock");
        this.skipSymbol(node.name.value);
        const tok = this.peekToken();
        if (!tok) {
            this.fail("parseBlock: expected endblock, got end of file");
        }
        this.advanceAfterBlockEnd(tok.value);
        return node;
    }
    parseExtends() {
        const tagName = "extends";
        const tag = this.peekToken();
        if (!this.skipSymbol(tagName)) {
            this.fail("parseTemplateRef: expected " + tagName);
        }
        const node = new __default3.Extends(tag.lineno, tag.colno);
        node.template = this.parseExpression();
        this.advanceAfterBlockEnd(tag.value);
        return node;
    }
    parseInclude() {
        const tagName = "include";
        const tag = this.peekToken();
        if (!this.skipSymbol(tagName)) {
            this.fail("parseInclude: expected " + tagName);
        }
        const node = new __default3.Include(tag.lineno, tag.colno);
        node.template = this.parseExpression();
        if (this.skipSymbol("ignore") && this.skipSymbol("missing")) {
            node.ignoreMissing = true;
        }
        this.advanceAfterBlockEnd(tag.value);
        return node;
    }
    parseIf() {
        const tag = this.peekToken();
        let node;
        if (this.skipSymbol("if") || this.skipSymbol("elif") || this.skipSymbol("elseif")) {
            node = new __default3.If(tag.lineno, tag.colno);
        } else if (this.skipSymbol("ifAsync")) {
            node = new __default3.IfAsync(tag.lineno, tag.colno);
        } else {
            this.fail("parseIf: expected if, elif, or elseif", tag.lineno, tag.colno);
        }
        node.cond = this.parseExpression();
        this.advanceAfterBlockEnd(tag.value);
        node.body = this.parseUntilBlocks("elif", "elseif", "else", "endif");
        const tok = this.peekToken();
        switch(tok && tok.value){
            case "elseif":
            case "elif":
                node.else_ = this.parseIf();
                break;
            case "else":
                this.advanceAfterBlockEnd();
                node.else_ = this.parseUntilBlocks("endif");
                this.advanceAfterBlockEnd();
                break;
            case "endif":
                node.else_ = null;
                this.advanceAfterBlockEnd();
                break;
            default:
                this.fail("parseIf: expected elif, else, or endif, got end of file");
        }
        return node;
    }
    parseSet() {
        const tag = this.peekToken();
        if (!this.skipSymbol("set")) {
            this.fail("parseSet: expected set", tag.lineno, tag.colno);
        }
        const node = new __default3.Set(tag.lineno, tag.colno, []);
        let target;
        while(target = this.parsePrimary()){
            node.targets.push(target);
            if (!this.skip(__default2.TOKEN_COMMA)) {
                break;
            }
        }
        if (!this.skipValue(__default2.TOKEN_OPERATOR, "=")) {
            if (!this.skip(__default2.TOKEN_BLOCK_END)) {
                this.fail("parseSet: expected = or block end in set tag", tag.lineno, tag.colno);
            } else {
                node.body = new __default3.Capture(tag.lineno, tag.colno, this.parseUntilBlocks("endset"));
                node.value = null;
                this.advanceAfterBlockEnd();
            }
        } else {
            node.value = this.parseExpression();
            this.advanceAfterBlockEnd(tag.value);
        }
        return node;
    }
    parseSwitch() {
        const switchStart = "switch";
        const switchEnd = "endswitch";
        const caseStart = "case";
        const caseDefault = "default";
        const tag = this.peekToken();
        if (!this.skipSymbol(switchStart) && !this.skipSymbol(caseStart) && !this.skipSymbol(caseDefault)) {
            this.fail('parseSwitch: expected "switch," "case" or "default"', tag.lineno, tag.colno);
        }
        const expr = this.parseExpression();
        this.advanceAfterBlockEnd(switchStart);
        this.parseUntilBlocks(caseStart, caseDefault, switchEnd);
        let tok = this.peekToken();
        const cases = [];
        let defaultCase;
        do {
            this.skipSymbol(caseStart);
            const cond = this.parseExpression();
            this.advanceAfterBlockEnd(switchStart);
            const body = this.parseUntilBlocks(caseStart, caseDefault, switchEnd);
            cases.push(new __default3.Case(tok.line, tok.col, cond, body));
            tok = this.peekToken();
        }while (tok && tok.value === caseStart)
        switch(tok.value){
            case caseDefault:
                this.advanceAfterBlockEnd();
                defaultCase = this.parseUntilBlocks(switchEnd);
                this.advanceAfterBlockEnd();
                break;
            case switchEnd:
                this.advanceAfterBlockEnd();
                break;
            default:
                this.fail('parseSwitch: expected "case," "default" or "endswitch," got EOF.');
        }
        return new __default3.Switch(tag.lineno, tag.colno, expr, cases, defaultCase);
    }
    parseStatement() {
        var tok = this.peekToken();
        var node;
        if (tok.type !== __default2.TOKEN_SYMBOL) {
            this.fail("tag name expected", tok.lineno, tok.colno);
        }
        if (this.breakOnBlocks && indexOf(this.breakOnBlocks, tok.value) !== -1) {
            return null;
        }
        switch(tok.value){
            case "raw":
                return this.parseRaw();
            case "verbatim":
                return this.parseRaw("verbatim");
            case "if":
            case "ifAsync":
                return this.parseIf();
            case "for":
            case "asyncEach":
            case "asyncAll":
                return this.parseFor();
            case "block":
                return this.parseBlock();
            case "extends":
                return this.parseExtends();
            case "include":
                return this.parseInclude();
            case "set":
                return this.parseSet();
            case "macro":
                return this.parseMacro();
            case "call":
                return this.parseCall();
            case "import":
                return this.parseImport();
            case "from":
                return this.parseFrom();
            case "filter":
                return this.parseFilterStatement();
            case "switch":
                return this.parseSwitch();
            default:
                if (this.extensions.length) {
                    for(let i = 0; i < this.extensions.length; i++){
                        const ext = this.extensions[i];
                        if (indexOf(ext.tags || [], tok.value) !== -1) {
                            return ext.parse(this, __default3, __default2);
                        }
                    }
                }
                this.fail("unknown block tag: " + tok.value, tok.lineno, tok.colno);
        }
        return node;
    }
    parseRaw(tagName) {
        tagName = tagName || "raw";
        const endTagName = "end" + tagName;
        const rawBlockRegex = new RegExp("([\\s\\S]*?){%\\s*(" + tagName + "|" + endTagName + ")\\s*(?=%})%}");
        let rawLevel = 1;
        let str = "";
        let matches = null;
        const begun = this.advanceAfterBlockEnd();
        while((matches = this.tokens._extractRegex(rawBlockRegex)) && rawLevel > 0){
            const all = matches[0];
            const pre = matches[1];
            const blockName = matches[2];
            if (blockName === tagName) {
                rawLevel += 1;
            } else if (blockName === endTagName) {
                rawLevel -= 1;
            }
            if (rawLevel === 0) {
                str += pre;
                this.tokens.backN(all.length - pre.length);
            } else {
                str += all;
            }
        }
        return new __default3.Output(begun.lineno, begun.colno, [
            new __default3.TemplateData(begun.lineno, begun.colno, str)
        ]);
    }
    parsePostfix(node) {
        let lookup;
        let tok = this.peekToken();
        while(tok){
            if (tok.type === __default2.TOKEN_LEFT_PAREN) {
                node = new __default3.FunCall(tok.lineno, tok.colno, node, this.parseSignature());
            } else if (tok.type === __default2.TOKEN_LEFT_BRACKET) {
                lookup = this.parseAggregate();
                if (lookup.children.length > 1) {
                    this.fail("invalid index");
                }
                node = new __default3.LookupVal(tok.lineno, tok.colno, node, lookup.children[0]);
            } else if (tok.type === __default2.TOKEN_OPERATOR && tok.value === ".") {
                this.nextToken();
                const val = this.nextToken();
                if (val.type !== __default2.TOKEN_SYMBOL) {
                    this.fail("expected name as lookup value, got " + val.value, val.lineno, val.colno);
                }
                lookup = new __default3.Literal(val.lineno, val.colno, val.value);
                node = new __default3.LookupVal(tok.lineno, tok.colno, node, lookup);
            } else {
                break;
            }
            tok = this.peekToken();
        }
        return node;
    }
    parseExpression() {
        var node = this.parseInlineIf();
        return node;
    }
    parseInlineIf() {
        let node = this.parseOr();
        if (this.skipSymbol("if")) {
            const condNode = this.parseOr();
            const bodyNode = node;
            node = new __default3.InlineIf(node.lineno, node.colno);
            node.body = bodyNode;
            node.cond = condNode;
            if (this.skipSymbol("else")) {
                node.else_ = this.parseOr();
            } else {
                node.else_ = null;
            }
        }
        return node;
    }
    parseOr() {
        let node = this.parseAnd();
        while(this.skipSymbol("or")){
            const node2 = this.parseAnd();
            node = new __default3.Or(node.lineno, node.colno, node, node2);
        }
        return node;
    }
    parseAnd() {
        let node = this.parseNot();
        while(this.skipSymbol("and")){
            const node2 = this.parseNot();
            node = new __default3.And(node.lineno, node.colno, node, node2);
        }
        return node;
    }
    parseNot() {
        const tok = this.peekToken();
        if (this.skipSymbol("not")) {
            return new __default3.Not(tok.lineno, tok.colno, this.parseNot());
        }
        return this.parseIn();
    }
    parseIn() {
        let node = this.parseIs();
        while(1){
            const tok = this.nextToken();
            if (!tok) {
                break;
            }
            const invert = tok.type === __default2.TOKEN_SYMBOL && tok.value === "not";
            if (!invert) {
                this.pushToken(tok);
            }
            if (this.skipSymbol("in")) {
                const node2 = this.parseIs();
                node = new __default3.In(node.lineno, node.colno, node, node2);
                if (invert) {
                    node = new __default3.Not(node.lineno, node.colno, node);
                }
            } else {
                if (invert) {
                    this.pushToken(tok);
                }
                break;
            }
        }
        return node;
    }
    parseIs() {
        let node = this.parseCompare();
        if (this.skipSymbol("is")) {
            const not = this.skipSymbol("not");
            const node2 = this.parseCompare();
            node = new __default3.Is(node.lineno, node.colno, node, node2);
            if (not) {
                node = new __default3.Not(node.lineno, node.colno, node);
            }
        }
        return node;
    }
    parseCompare() {
        const compareOps = [
            "==",
            "===",
            "!=",
            "!==",
            "<",
            ">",
            "<=",
            ">="
        ];
        const expr = this.parseConcat();
        const ops = [];
        while(1){
            const tok = this.nextToken();
            if (!tok) {
                break;
            } else if (compareOps.indexOf(tok.value) !== -1) {
                ops.push(new __default3.CompareOperand(tok.lineno, tok.colno, this.parseConcat(), tok.value));
            } else {
                this.pushToken(tok);
                break;
            }
        }
        if (ops.length) {
            return new __default3.Compare(ops[0].lineno, ops[0].colno, expr, ops);
        } else {
            return expr;
        }
    }
    parseConcat() {
        let node = this.parseAdd();
        while(this.skipValue(__default2.TOKEN_TILDE, "~")){
            const node2 = this.parseAdd();
            node = new __default3.Concat(node.lineno, node.colno, node, node2);
        }
        return node;
    }
    parseAdd() {
        let node = this.parseSub();
        while(this.skipValue(__default2.TOKEN_OPERATOR, "+")){
            const node2 = this.parseSub();
            node = new __default3.Add(node.lineno, node.colno, node, node2);
        }
        return node;
    }
    parseSub() {
        let node = this.parseMul();
        while(this.skipValue(__default2.TOKEN_OPERATOR, "-")){
            const node2 = this.parseMul();
            node = new __default3.Sub(node.lineno, node.colno, node, node2);
        }
        return node;
    }
    parseMul() {
        let node = this.parseDiv();
        while(this.skipValue(__default2.TOKEN_OPERATOR, "*")){
            const node2 = this.parseDiv();
            node = new __default3.Mul(node.lineno, node.colno, node, node2);
        }
        return node;
    }
    parseDiv() {
        let node = this.parseFloorDiv();
        while(this.skipValue(__default2.TOKEN_OPERATOR, "/")){
            const node2 = this.parseFloorDiv();
            node = new __default3.Div(node.lineno, node.colno, node, node2);
        }
        return node;
    }
    parseFloorDiv() {
        let node = this.parseMod();
        while(this.skipValue(__default2.TOKEN_OPERATOR, "//")){
            const node2 = this.parseMod();
            node = new __default3.FloorDiv(node.lineno, node.colno, node, node2);
        }
        return node;
    }
    parseMod() {
        let node = this.parsePow();
        while(this.skipValue(__default2.TOKEN_OPERATOR, "%")){
            const node2 = this.parsePow();
            node = new __default3.Mod(node.lineno, node.colno, node, node2);
        }
        return node;
    }
    parsePow() {
        let node = this.parseUnary();
        while(this.skipValue(__default2.TOKEN_OPERATOR, "**")){
            const node2 = this.parseUnary();
            node = new __default3.Pow(node.lineno, node.colno, node, node2);
        }
        return node;
    }
    parseUnary(noFilters) {
        const tok = this.peekToken();
        let node;
        if (this.skipValue(__default2.TOKEN_OPERATOR, "-")) {
            node = new __default3.Neg(tok.lineno, tok.colno, this.parseUnary(true));
        } else if (this.skipValue(__default2.TOKEN_OPERATOR, "+")) {
            node = new __default3.Pos(tok.lineno, tok.colno, this.parseUnary(true));
        } else {
            node = this.parsePrimary();
        }
        if (!noFilters) {
            node = this.parseFilter(node);
        }
        return node;
    }
    parsePrimary(noPostfix) {
        const tok = this.nextToken();
        let val;
        let node = null;
        if (!tok) {
            this.fail("expected expression, got end of file");
        } else if (tok.type === __default2.TOKEN_STRING) {
            val = tok.value;
        } else if (tok.type === __default2.TOKEN_INT) {
            val = parseInt(tok.value, 10);
        } else if (tok.type === __default2.TOKEN_FLOAT) {
            val = parseFloat(tok.value);
        } else if (tok.type === __default2.TOKEN_BOOLEAN) {
            if (tok.value === "true") {
                val = true;
            } else if (tok.value === "false") {
                val = false;
            } else {
                this.fail("invalid boolean: " + tok.value, tok.lineno, tok.colno);
            }
        } else if (tok.type === __default2.TOKEN_NONE) {
            val = null;
        } else if (tok.type === __default2.TOKEN_REGEX) {
            val = new RegExp(tok.value.body, tok.value.flags);
        }
        if (val !== undefined) {
            node = new __default3.Literal(tok.lineno, tok.colno, val);
        } else if (tok.type === __default2.TOKEN_SYMBOL) {
            node = new __default3.Symbol(tok.lineno, tok.colno, tok.value);
        } else {
            this.pushToken(tok);
            node = this.parseAggregate();
        }
        if (!noPostfix) {
            node = this.parsePostfix(node);
        }
        if (node) {
            return node;
        } else {
            throw this.error(`unexpected token: ${tok.value}`, tok.lineno, tok.colno);
        }
    }
    parseFilterName() {
        const tok = this.expect(__default2.TOKEN_SYMBOL);
        let name = tok.value;
        while(this.skipValue(__default2.TOKEN_OPERATOR, ".")){
            name += "." + this.expect(__default2.TOKEN_SYMBOL).value;
        }
        return new __default3.Symbol(tok.lineno, tok.colno, name);
    }
    parseFilterArgs(node) {
        if (this.peekToken().type === __default2.TOKEN_LEFT_PAREN) {
            const call = this.parsePostfix(node);
            return call.args.children;
        }
        return [];
    }
    parseFilter(node) {
        while(this.skip(__default2.TOKEN_PIPE)){
            const name = this.parseFilterName();
            node = new __default3.Filter(name.lineno, name.colno, name, new __default3.NodeList(name.lineno, name.colno, [
                node
            ].concat(this.parseFilterArgs(node))));
        }
        return node;
    }
    parseFilterStatement() {
        var filterTok = this.peekToken();
        if (!this.skipSymbol("filter")) {
            this.fail("parseFilterStatement: expected filter");
        }
        const name = this.parseFilterName();
        const args = this.parseFilterArgs(name);
        this.advanceAfterBlockEnd(filterTok.value);
        const body = new __default3.Capture(name.lineno, name.colno, this.parseUntilBlocks("endfilter"));
        this.advanceAfterBlockEnd();
        const node = new __default3.Filter(name.lineno, name.colno, name, new __default3.NodeList(name.lineno, name.colno, [
            body
        ].concat(args)));
        return new __default3.Output(name.lineno, name.colno, [
            node
        ]);
    }
    parseAggregate() {
        var tok = this.nextToken();
        var node;
        switch(tok.type){
            case __default2.TOKEN_LEFT_PAREN:
                node = new __default3.Group(tok.lineno, tok.colno);
                break;
            case __default2.TOKEN_LEFT_BRACKET:
                node = new __default3.Array(tok.lineno, tok.colno);
                break;
            case __default2.TOKEN_LEFT_CURLY:
                node = new __default3.Dict(tok.lineno, tok.colno);
                break;
            default:
                return null;
        }
        while(1){
            const type = this.peekToken().type;
            if (type === __default2.TOKEN_RIGHT_PAREN || type === __default2.TOKEN_RIGHT_BRACKET || type === __default2.TOKEN_RIGHT_CURLY) {
                this.nextToken();
                break;
            }
            if (node.children.length > 0) {
                if (!this.skip(__default2.TOKEN_COMMA)) {
                    this.fail("parseAggregate: expected comma after expression", tok.lineno, tok.colno);
                }
            }
            if (node instanceof __default3.Dict) {
                const key = this.parsePrimary();
                if (!this.skip(__default2.TOKEN_COLON)) {
                    this.fail("parseAggregate: expected colon after dict key", tok.lineno, tok.colno);
                }
                const value = this.parseExpression();
                node.addChild(new __default3.Pair(key.lineno, key.colno, key, value));
            } else {
                const expr = this.parseExpression();
                node.addChild(expr);
            }
        }
        return node;
    }
    parseSignature(tolerant, noParens) {
        let tok = this.peekToken();
        if (!noParens && tok.type !== __default2.TOKEN_LEFT_PAREN) {
            if (tolerant) {
                return null;
            } else {
                this.fail("expected arguments", tok.lineno, tok.colno);
            }
        }
        if (tok.type === __default2.TOKEN_LEFT_PAREN) {
            tok = this.nextToken();
        }
        const args = new __default3.NodeList(tok.lineno, tok.colno);
        const kwargs = new __default3.KeywordArgs(tok.lineno, tok.colno);
        let checkComma = false;
        while(1){
            tok = this.peekToken();
            if (!noParens && tok.type === __default2.TOKEN_RIGHT_PAREN) {
                this.nextToken();
                break;
            } else if (noParens && tok.type === __default2.TOKEN_BLOCK_END) {
                break;
            }
            if (checkComma && !this.skip(__default2.TOKEN_COMMA)) {
                this.fail("parseSignature: expected comma after expression", tok.lineno, tok.colno);
            } else {
                const arg = this.parseExpression();
                if (this.skipValue(__default2.TOKEN_OPERATOR, "=")) {
                    kwargs.addChild(new __default3.Pair(arg.lineno, arg.colno, arg, this.parseExpression()));
                } else {
                    args.addChild(arg);
                }
            }
            checkComma = true;
        }
        if (kwargs.children.length) {
            args.addChild(kwargs);
        }
        return args;
    }
    parseUntilBlocks(...blockNames) {
        const prev = this.breakOnBlocks;
        this.breakOnBlocks = blockNames;
        const ret = this.parse();
        this.breakOnBlocks = prev;
        return ret;
    }
    parseNodes() {
        let tok;
        const buf = [];
        while(tok = this.nextToken()){
            if (tok.type === __default2.TOKEN_DATA) {
                let data = tok.value;
                const nextToken = this.peekToken();
                const nextVal = nextToken && nextToken.value;
                if (this.dropLeadingWhitespace) {
                    data = data.replace(/^\s*/, "");
                    this.dropLeadingWhitespace = false;
                }
                if (nextToken && (nextToken.type === __default2.TOKEN_BLOCK_START && nextVal.charAt(nextVal.length - 1) === "-" || nextToken.type === __default2.TOKEN_VARIABLE_START && nextVal.charAt(this.tokens.tags.VARIABLE_START.length) === "-" || nextToken.type === __default2.TOKEN_COMMENT && nextVal.charAt(this.tokens.tags.COMMENT_START.length) === "-")) {
                    data = data.replace(/\s*$/, "");
                }
                buf.push(new __default3.Output(tok.lineno, tok.colno, [
                    new __default3.TemplateData(tok.lineno, tok.colno, data), 
                ]));
            } else if (tok.type === __default2.TOKEN_BLOCK_START) {
                this.dropLeadingWhitespace = false;
                const n = this.parseStatement();
                if (!n) {
                    break;
                }
                buf.push(n);
            } else if (tok.type === __default2.TOKEN_VARIABLE_START) {
                const e = this.parseExpression();
                this.dropLeadingWhitespace = false;
                this.advanceAfterVariableEnd();
                buf.push(new __default3.Output(tok.lineno, tok.colno, [
                    e
                ]));
            } else if (tok.type === __default2.TOKEN_COMMENT) {
                this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.COMMENT_END.length - 1) === "-";
            } else {
                this.fail("Unexpected token at top-level: " + tok.type, tok.lineno, tok.colno);
            }
        }
        return buf;
    }
    parse() {
        return new __default3.NodeList(0, 0, this.parseNodes());
    }
    parseAsRoot() {
        return new __default3.Root(0, 0, this.parseNodes());
    }
}
const __default4 = {
    parse (src, extensions, opts) {
        var p = new Parser(__default2.lex(src, opts));
        if (extensions !== undefined) {
            p.extensions = extensions;
        }
        return p.parseAsRoot();
    },
    Parser: Parser
};
var sym = 0;
function gensym() {
    return "hole_" + sym++;
}
function mapCOW(arr, func) {
    var res = null;
    for(let i = 0; i < arr.length; i++){
        const item = func(arr[i]);
        if (item !== arr[i]) {
            if (!res) {
                res = arr.slice();
            }
            res[i] = item;
        }
    }
    return res || arr;
}
function walk(ast, func, depthFirst) {
    if (!(ast instanceof __default3.Node)) {
        return ast;
    }
    if (!depthFirst) {
        const astT = func(ast);
        if (astT && astT !== ast) {
            return astT;
        }
    }
    if (ast instanceof __default3.NodeList) {
        const children = mapCOW(ast.children, (node)=>walk(node, func, depthFirst));
        if (children !== ast.children) {
            ast = new __default3[ast.typename](ast.lineno, ast.colno, children);
        }
    } else if (ast instanceof __default3.CallExtension) {
        const args = walk(ast.args, func, depthFirst);
        const contentArgs = mapCOW(ast.contentArgs, (node)=>walk(node, func, depthFirst));
        if (args !== ast.args || contentArgs !== ast.contentArgs) {
            ast = new __default3[ast.typename](ast.extName, ast.prop, args, contentArgs);
        }
    } else {
        const props = ast.fields.map((field)=>ast[field]);
        const propsT = mapCOW(props, (prop)=>walk(prop, func, depthFirst));
        if (propsT !== props) {
            ast = new __default3[ast.typename](ast.lineno, ast.colno);
            propsT.forEach((prop, i)=>{
                ast[ast.fields[i]] = prop;
            });
        }
    }
    return depthFirst ? func(ast) || ast : ast;
}
function depthWalk(ast, func) {
    return walk(ast, func, true);
}
function _liftFilters(node, asyncFilters, prop) {
    var children = [];
    var walked = depthWalk(prop ? node[prop] : node, (descNode)=>{
        let symbol;
        if (descNode instanceof __default3.Block) {
            return descNode;
        } else if (descNode instanceof __default3.Filter && indexOf(asyncFilters, descNode.name.value) !== -1 || descNode instanceof __default3.CallExtensionAsync) {
            symbol = new __default3.Symbol(descNode.lineno, descNode.colno, gensym());
            children.push(new __default3.FilterAsync(descNode.lineno, descNode.colno, descNode.name, descNode.args, symbol));
        }
        return symbol;
    });
    if (prop) {
        node[prop] = walked;
    } else {
        node = walked;
    }
    if (children.length) {
        children.push(node);
        return new __default3.NodeList(node.lineno, node.colno, children);
    } else {
        return node;
    }
}
function liftFilters(ast, asyncFilters) {
    return depthWalk(ast, (node)=>{
        if (node instanceof __default3.Output) {
            return _liftFilters(node, asyncFilters);
        } else if (node instanceof __default3.Set) {
            return _liftFilters(node, asyncFilters, "value");
        } else if (node instanceof __default3.For) {
            return _liftFilters(node, asyncFilters, "arr");
        } else if (node instanceof __default3.If) {
            return _liftFilters(node, asyncFilters, "cond");
        } else if (node instanceof __default3.CallExtension) {
            return _liftFilters(node, asyncFilters, "args");
        } else {
            return undefined;
        }
    });
}
function liftSuper(ast) {
    return walk(ast, (blockNode)=>{
        if (!(blockNode instanceof __default3.Block)) {
            return;
        }
        let hasSuper = false;
        const symbol = gensym();
        blockNode.body = walk(blockNode.body, (node)=>{
            if (node instanceof __default3.FunCall && node.name.value === "super") {
                hasSuper = true;
                return new __default3.Symbol(node.lineno, node.colno, symbol);
            }
        });
        if (hasSuper) {
            blockNode.body.children.unshift(new __default3.Super(0, 0, blockNode.name, new __default3.Symbol(0, 0, symbol)));
        }
    });
}
function convertStatements(ast) {
    return depthWalk(ast, (node)=>{
        if (!(node instanceof __default3.If) && !(node instanceof __default3.For)) {
            return undefined;
        }
        let async = false;
        walk(node, (child)=>{
            if (child instanceof __default3.FilterAsync || child instanceof __default3.IfAsync || child instanceof __default3.AsyncEach || child instanceof __default3.AsyncAll || child instanceof __default3.CallExtensionAsync) {
                async = true;
                return child;
            }
            return undefined;
        });
        if (async) {
            if (node instanceof __default3.If) {
                return new __default3.IfAsync(node.lineno, node.colno, node.cond, node.body, node.else_);
            } else if (node instanceof __default3.For && !(node instanceof __default3.AsyncAll)) {
                return new __default3.AsyncEach(node.lineno, node.colno, node.arr, node.name, node.body, node.else_);
            }
        }
        return undefined;
    });
}
function cps(ast, asyncFilters) {
    return convertStatements(liftSuper(liftFilters(ast, asyncFilters)));
}
function transform(ast, asyncFilters) {
    return cps(ast, asyncFilters || []);
}
const __default5 = {
    transform: transform
};
var arrayFrom = Array.from;
var supportsIterators = typeof Symbol === "function" && Symbol.iterator && typeof arrayFrom === "function";
class Frame {
    constructor(parent, isolateWrites){
        this.variables = Object.create(null);
        this.parent = parent;
        this.topLevel = false;
        this.isolateWrites = isolateWrites;
    }
    set(name, val, resolveUp) {
        var parts = name.split(".");
        var obj = this.variables;
        var frame = this;
        if (resolveUp) {
            if (frame = this.resolve(parts[0], true)) {
                frame.set(name, val);
                return;
            }
        }
        for(let i = 0; i < parts.length - 1; i++){
            const id = parts[i];
            if (!obj[id]) {
                obj[id] = {};
            }
            obj = obj[id];
        }
        obj[parts[parts.length - 1]] = val;
    }
    get(name) {
        var val = this.variables[name];
        if (val !== undefined) {
            return val;
        }
        return null;
    }
    lookup(name) {
        var p = this.parent;
        var val = this.variables[name];
        if (val !== undefined) {
            return val;
        }
        return p && p.lookup(name);
    }
    resolve(name, forWrite) {
        var p = forWrite && this.isolateWrites ? undefined : this.parent;
        var val = this.variables[name];
        if (val !== undefined) {
            return this;
        }
        return p && p.resolve(name);
    }
    push(isolateWrites) {
        return new Frame(this, isolateWrites);
    }
    pop() {
        return this.parent;
    }
}
function makeMacro(argNames, kwargNames, func) {
    return function macro(...macroArgs) {
        var argCount = numArgs(macroArgs);
        var args;
        var kwargs = getKeywordArgs(macroArgs);
        if (argCount > argNames.length) {
            args = macroArgs.slice(0, argNames.length);
            macroArgs.slice(args.length, argCount).forEach((val, i)=>{
                if (i < kwargNames.length) {
                    kwargs[kwargNames[i]] = val;
                }
            });
            args.push(kwargs);
        } else if (argCount < argNames.length) {
            args = macroArgs.slice(0, argCount);
            for(let i = argCount; i < argNames.length; i++){
                const arg = argNames[i];
                args.push(kwargs[arg]);
                delete kwargs[arg];
            }
            args.push(kwargs);
        } else {
            args = macroArgs;
        }
        return func.apply(this, args);
    };
}
function makeKeywordArgs(obj) {
    obj.__keywords = true;
    return obj;
}
function isKeywordArgs(obj) {
    return obj && Object.prototype.hasOwnProperty.call(obj, "__keywords");
}
function getKeywordArgs(args) {
    var len = args.length;
    if (len) {
        const lastArg = args[len - 1];
        if (isKeywordArgs(lastArg)) {
            return lastArg;
        }
    }
    return {};
}
function numArgs(args) {
    var len = args.length;
    if (len === 0) {
        return 0;
    }
    const lastArg = args[len - 1];
    if (isKeywordArgs(lastArg)) {
        return len - 1;
    } else {
        return len;
    }
}
function SafeString(val) {
    if (typeof val !== "string") {
        return val;
    }
    this.val = val;
    this.length = val.length;
}
SafeString.prototype = Object.create(String.prototype, {
    length: {
        writable: true,
        configurable: true,
        value: 0
    }
});
SafeString.prototype.valueOf = function valueOf() {
    return this.val;
};
SafeString.prototype.toString = function toString() {
    return this.val;
};
function copySafeness(dest, target) {
    if (dest instanceof SafeString) {
        return new SafeString(target);
    }
    return target.toString();
}
function markSafe(val) {
    var type = typeof val;
    if (type === "string") {
        return new SafeString(val);
    } else if (type !== "function") {
        return val;
    } else {
        return function wrapSafe(args) {
            var ret = val.apply(this, arguments);
            if (typeof ret === "string") {
                return new SafeString(ret);
            }
            return ret;
        };
    }
}
function suppressValue(val, autoescape) {
    val = val !== undefined && val !== null ? val : "";
    if (autoescape && !(val instanceof SafeString)) {
        val = mod4.escape(val.toString());
    }
    return val;
}
function ensureDefined(val, lineno, colno) {
    if (val === null || val === undefined) {
        throw new mod4.TemplateError("attempted to output null or undefined value", lineno + 1, colno + 1);
    }
    return val;
}
function memberLookup(obj, val) {
    if (obj === undefined || obj === null) {
        return undefined;
    }
    if (typeof obj[val] === "function") {
        return (...args)=>obj[val].apply(obj, args);
    }
    return obj[val];
}
function callWrap(obj, name, context, args) {
    if (!obj) {
        throw new Error("Unable to call `" + name + "`, which is undefined or falsey");
    } else if (typeof obj !== "function") {
        throw new Error("Unable to call `" + name + "`, which is not a function");
    }
    return obj.apply(context, args);
}
function contextOrFrameLookup(context, frame, name) {
    var val = frame.lookup(name);
    return val !== undefined ? val : context.lookup(name);
}
function handleError(error, lineno, colno) {
    if (error.lineno) {
        return error;
    } else {
        return new mod4.TemplateError(error, lineno, colno);
    }
}
function asyncEach(arr, dimen, iter, cb) {
    if (mod4.isArray(arr)) {
        const len = arr.length;
        mod4.asyncIter(arr, function iterCallback(item, i, next) {
            switch(dimen){
                case 1:
                    iter(item, i, len, next);
                    break;
                case 2:
                    iter(item[0], item[1], i, len, next);
                    break;
                case 3:
                    iter(item[0], item[1], item[2], i, len, next);
                    break;
                default:
                    item.push(i, len, next);
                    iter.apply(this, item);
            }
        }, cb);
    } else {
        mod4.asyncFor(arr, function iterCallback(key, val, i, len, next) {
            iter(key, val, i, len, next);
        }, cb);
    }
}
function asyncAll(arr, dimen, func, cb) {
    var finished = 0;
    var len;
    var outputArr;
    function done(i, output) {
        finished++;
        outputArr[i] = output;
        if (finished === len) {
            cb(null, outputArr.join(""));
        }
    }
    if (mod4.isArray(arr)) {
        len = arr.length;
        outputArr = new Array(len);
        if (len === 0) {
            cb(null, "");
        } else {
            for(let i = 0; i < arr.length; i++){
                const item = arr[i];
                switch(dimen){
                    case 1:
                        func(item, i, len, done);
                        break;
                    case 2:
                        func(item[0], item[1], i, len, done);
                        break;
                    case 3:
                        func(item[0], item[1], item[2], i, len, done);
                        break;
                    default:
                        item.push(i, len, done);
                        func.apply(this, item);
                }
            }
        }
    } else {
        const keys = mod4.keys(arr || {});
        len = keys.length;
        outputArr = new Array(len);
        if (len === 0) {
            cb(null, "");
        } else {
            for(let i1 = 0; i1 < keys.length; i1++){
                const k = keys[i1];
                func(k, arr[k], i1, len, done);
            }
        }
    }
}
function fromIterator(arr) {
    if (typeof arr !== "object" || arr === null || mod4.isArray(arr)) {
        return arr;
    } else if (supportsIterators && Symbol.iterator in arr) {
        return arrayFrom(arr);
    } else {
        return arr;
    }
}
const { inOperator: inOperator1 , isArray: isArray1 , keys  } = mod4;
const mod8 = {
    asyncAll: asyncAll,
    asyncEach: asyncEach,
    callWrap: callWrap,
    contextOrFrameLookup: contextOrFrameLookup,
    copySafeness: copySafeness,
    ensureDefined: ensureDefined,
    Frame: Frame,
    fromIterator: fromIterator,
    handleError: handleError,
    inOperator: inOperator1,
    isArray: isArray1,
    keys: keys,
    makeKeywordArgs: makeKeywordArgs,
    makeMacro: makeMacro,
    markSafe: markSafe,
    memberLookup: memberLookup,
    numArgs: numArgs,
    SafeString: SafeString,
    suppressValue: suppressValue
};
const compareOps = {
    "==": "==",
    "===": "===",
    "!=": "!=",
    "!==": "!==",
    "<": "<",
    ">": ">",
    "<=": "<=",
    ">=": ">="
};
class Compiler extends Obj {
    init(templateName, throwOnUndefined) {
        this.templateName = templateName;
        this.codebuf = [];
        this.lastId = 0;
        this.buffer = null;
        this.bufferStack = [];
        this._scopeClosers = "";
        this.inBlock = false;
        this.throwOnUndefined = throwOnUndefined;
    }
    fail(msg, lineno, colno) {
        if (lineno !== undefined) {
            lineno += 1;
        }
        if (colno !== undefined) {
            colno += 1;
        }
        throw new TemplateError(msg, lineno, colno);
    }
    _pushBuffer() {
        const id = this._tmpid();
        this.bufferStack.push(this.buffer);
        this.buffer = id;
        this._emit(`var ${this.buffer} = "";`);
        return id;
    }
    _popBuffer() {
        this.buffer = this.bufferStack.pop();
    }
    _emit(code) {
        this.codebuf.push(code);
    }
    _emitLine(code) {
        this._emit(code + "\n");
    }
    _emitLines(...lines) {
        lines.forEach((line)=>this._emitLine(line));
    }
    _emitFuncBegin(node, name) {
        this.buffer = "output";
        this._scopeClosers = "";
        this._emitLine(`function ${name}(env, context, frame, runtime, cb) {`);
        this._emitLine(`var lineno = ${node.lineno};`);
        this._emitLine(`var colno = ${node.colno};`);
        this._emitLine(`var ${this.buffer} = "";`);
        this._emitLine("try {");
    }
    _emitFuncEnd(noReturn) {
        if (!noReturn) {
            this._emitLine("cb(null, " + this.buffer + ");");
        }
        this._closeScopeLevels();
        this._emitLine("} catch (e) {");
        this._emitLine("  cb(runtime.handleError(e, lineno, colno));");
        this._emitLine("}");
        this._emitLine("}");
        this.buffer = null;
    }
    _addScopeLevel() {
        this._scopeClosers += "})";
    }
    _closeScopeLevels() {
        this._emitLine(this._scopeClosers + ";");
        this._scopeClosers = "";
    }
    _withScopedSyntax(func) {
        var _scopeClosers = this._scopeClosers;
        this._scopeClosers = "";
        func.call(this);
        this._closeScopeLevels();
        this._scopeClosers = _scopeClosers;
    }
    _makeCallback(res) {
        var err = this._tmpid();
        return "function(" + err + (res ? "," + res : "") + ") {\n" + "if(" + err + ") { cb(" + err + "); return; }";
    }
    _tmpid() {
        this.lastId++;
        return "t_" + this.lastId;
    }
    _templateName() {
        return this.templateName == null ? "undefined" : JSON.stringify(this.templateName);
    }
    _compileChildren(node, frame) {
        node.children.forEach((child)=>{
            this.compile(child, frame);
        });
    }
    _compileAggregate(node, frame, startChar, endChar) {
        if (startChar) {
            this._emit(startChar);
        }
        node.children.forEach((child, i)=>{
            if (i > 0) {
                this._emit(",");
            }
            this.compile(child, frame);
        });
        if (endChar) {
            this._emit(endChar);
        }
    }
    _compileExpression(node, frame) {
        this.assertType(node, __default3.Literal, __default3.Symbol, __default3.Group, __default3.Array, __default3.Dict, __default3.FunCall, __default3.Caller, __default3.Filter, __default3.LookupVal, __default3.Compare, __default3.InlineIf, __default3.In, __default3.Is, __default3.And, __default3.Or, __default3.Not, __default3.Add, __default3.Concat, __default3.Sub, __default3.Mul, __default3.Div, __default3.FloorDiv, __default3.Mod, __default3.Pow, __default3.Neg, __default3.Pos, __default3.Compare, __default3.NodeList);
        this.compile(node, frame);
    }
    assertType(node, ...types) {
        if (!types.some((t)=>node instanceof t)) {
            this.fail(`assertType: invalid type: ${node.typename}`, node.lineno, node.colno);
        }
    }
    compileCallExtension(node, frame, async) {
        var args = node.args;
        var contentArgs = node.contentArgs;
        var autoescape = typeof node.autoescape === "boolean" ? node.autoescape : true;
        if (!async) {
            this._emit(`${this.buffer} += runtime.suppressValue(`);
        }
        this._emit(`env.getExtension("${node.extName}")["${node.prop}"](`);
        this._emit("context");
        if (args || contentArgs) {
            this._emit(",");
        }
        if (args) {
            if (!(args instanceof __default3.NodeList)) {
                this.fail("compileCallExtension: arguments must be a NodeList, " + "use `parser.parseSignature`");
            }
            args.children.forEach((arg, i)=>{
                this._compileExpression(arg, frame);
                if (i !== args.children.length - 1 || contentArgs.length) {
                    this._emit(",");
                }
            });
        }
        if (contentArgs.length) {
            contentArgs.forEach((arg, i)=>{
                if (i > 0) {
                    this._emit(",");
                }
                if (arg) {
                    this._emitLine("function(cb) {");
                    this._emitLine("if(!cb) { cb = function(err) { if(err) { throw err; }}}");
                    const id = this._pushBuffer();
                    this._withScopedSyntax(()=>{
                        this.compile(arg, frame);
                        this._emitLine(`cb(null, ${id});`);
                    });
                    this._popBuffer();
                    this._emitLine(`return ${id};`);
                    this._emitLine("}");
                } else {
                    this._emit("null");
                }
            });
        }
        if (async) {
            const res = this._tmpid();
            this._emitLine(", " + this._makeCallback(res));
            this._emitLine(`${this.buffer} += runtime.suppressValue(${res}, ${autoescape} && env.opts.autoescape);`);
            this._addScopeLevel();
        } else {
            this._emit(")");
            this._emit(`, ${autoescape} && env.opts.autoescape);\n`);
        }
    }
    compileCallExtensionAsync(node, frame) {
        this.compileCallExtension(node, frame, true);
    }
    compileNodeList(node, frame) {
        this._compileChildren(node, frame);
    }
    compileLiteral(node) {
        if (typeof node.value === "string") {
            let val = node.value.replace(/\\/g, "\\\\");
            val = val.replace(/"/g, '\\"');
            val = val.replace(/\n/g, "\\n");
            val = val.replace(/\r/g, "\\r");
            val = val.replace(/\t/g, "\\t");
            val = val.replace(/\u2028/g, "\\u2028");
            this._emit(`"${val}"`);
        } else if (node.value === null) {
            this._emit("null");
        } else {
            this._emit(node.value.toString());
        }
    }
    compileSymbol(node, frame) {
        var name = node.value;
        var v = frame.lookup(name);
        if (v) {
            this._emit(v);
        } else {
            this._emit("runtime.contextOrFrameLookup(" + 'context, frame, "' + name + '")');
        }
    }
    compileGroup(node, frame) {
        this._compileAggregate(node, frame, "(", ")");
    }
    compileArray(node, frame) {
        this._compileAggregate(node, frame, "[", "]");
    }
    compileDict(node, frame) {
        this._compileAggregate(node, frame, "{", "}");
    }
    compilePair(node, frame) {
        var key = node.key;
        var val = node.value;
        if (key instanceof __default3.Symbol) {
            key = new __default3.Literal(key.lineno, key.colno, key.value);
        } else if (!(key instanceof __default3.Literal && typeof key.value === "string")) {
            this.fail("compilePair: Dict keys must be strings or names", key.lineno, key.colno);
        }
        this.compile(key, frame);
        this._emit(": ");
        this._compileExpression(val, frame);
    }
    compileInlineIf(node, frame) {
        this._emit("(");
        this.compile(node.cond, frame);
        this._emit("?");
        this.compile(node.body, frame);
        this._emit(":");
        if (node.else_ !== null) {
            this.compile(node.else_, frame);
        } else {
            this._emit('""');
        }
        this._emit(")");
    }
    compileIn(node, frame) {
        this._emit("runtime.inOperator(");
        this.compile(node.left, frame);
        this._emit(",");
        this.compile(node.right, frame);
        this._emit(")");
    }
    compileIs(node, frame) {
        var right = node.right.name ? node.right.name.value : node.right.value;
        this._emit('env.getTest("' + right + '").call(context, ');
        this.compile(node.left, frame);
        if (node.right.args) {
            this._emit(",");
            this.compile(node.right.args, frame);
        }
        this._emit(") === true");
    }
    _binOpEmitter(node, frame, str) {
        this.compile(node.left, frame);
        this._emit(str);
        this.compile(node.right, frame);
    }
    compileOr(node, frame) {
        return this._binOpEmitter(node, frame, " || ");
    }
    compileAnd(node, frame) {
        return this._binOpEmitter(node, frame, " && ");
    }
    compileAdd(node, frame) {
        return this._binOpEmitter(node, frame, " + ");
    }
    compileConcat(node, frame) {
        return this._binOpEmitter(node, frame, ' + "" + ');
    }
    compileSub(node, frame) {
        return this._binOpEmitter(node, frame, " - ");
    }
    compileMul(node, frame) {
        return this._binOpEmitter(node, frame, " * ");
    }
    compileDiv(node, frame) {
        return this._binOpEmitter(node, frame, " / ");
    }
    compileMod(node, frame) {
        return this._binOpEmitter(node, frame, " % ");
    }
    compileNot(node, frame) {
        this._emit("!");
        this.compile(node.target, frame);
    }
    compileFloorDiv(node, frame) {
        this._emit("Math.floor(");
        this.compile(node.left, frame);
        this._emit(" / ");
        this.compile(node.right, frame);
        this._emit(")");
    }
    compilePow(node, frame) {
        this._emit("Math.pow(");
        this.compile(node.left, frame);
        this._emit(", ");
        this.compile(node.right, frame);
        this._emit(")");
    }
    compileNeg(node, frame) {
        this._emit("-");
        this.compile(node.target, frame);
    }
    compilePos(node, frame) {
        this._emit("+");
        this.compile(node.target, frame);
    }
    compileCompare(node, frame) {
        this.compile(node.expr, frame);
        node.ops.forEach((op)=>{
            this._emit(` ${compareOps[op.type]} `);
            this.compile(op.expr, frame);
        });
    }
    compileLookupVal(node, frame) {
        this._emit("runtime.memberLookup((");
        this._compileExpression(node.target, frame);
        this._emit("),");
        this._compileExpression(node.val, frame);
        this._emit(")");
    }
    _getNodeName(node) {
        switch(node.typename){
            case "Symbol":
                return node.value;
            case "FunCall":
                return "the return value of (" + this._getNodeName(node.name) + ")";
            case "LookupVal":
                return this._getNodeName(node.target) + '["' + this._getNodeName(node.val) + '"]';
            case "Literal":
                return node.value.toString();
            default:
                return "--expression--";
        }
    }
    compileFunCall(node, frame) {
        this._emit("(lineno = " + node.lineno + ", colno = " + node.colno + ", ");
        this._emit("runtime.callWrap(");
        this._compileExpression(node.name, frame);
        this._emit(', "' + this._getNodeName(node.name).replace(/"/g, '\\"') + '", context, ');
        this._compileAggregate(node.args, frame, "[", "])");
        this._emit(")");
    }
    compileFilter(node, frame) {
        var name = node.name;
        this.assertType(name, __default3.Symbol);
        this._emit('env.getFilter("' + name.value + '").call(context, ');
        this._compileAggregate(node.args, frame);
        this._emit(")");
    }
    compileFilterAsync(node, frame) {
        var name = node.name;
        var symbol = node.symbol.value;
        this.assertType(name, __default3.Symbol);
        frame.set(symbol, symbol);
        this._emit('env.getFilter("' + name.value + '").call(context, ');
        this._compileAggregate(node.args, frame);
        this._emitLine(", " + this._makeCallback(symbol));
        this._addScopeLevel();
    }
    compileKeywordArgs(node, frame) {
        this._emit("runtime.makeKeywordArgs(");
        this.compileDict(node, frame);
        this._emit(")");
    }
    compileSet(node, frame) {
        var ids = [];
        node.targets.forEach((target)=>{
            var name = target.value;
            var id = frame.lookup(name);
            if (id === null || id === undefined) {
                id = this._tmpid();
                this._emitLine("var " + id + ";");
            }
            ids.push(id);
        });
        if (node.value) {
            this._emit(ids.join(" = ") + " = ");
            this._compileExpression(node.value, frame);
            this._emitLine(";");
        } else {
            this._emit(ids.join(" = ") + " = ");
            this.compile(node.body, frame);
            this._emitLine(";");
        }
        node.targets.forEach((target, i)=>{
            var id = ids[i];
            var name = target.value;
            this._emitLine(`frame.set("${name}", ${id}, true);`);
            this._emitLine("if(frame.topLevel) {");
            this._emitLine(`context.setVariable("${name}", ${id});`);
            this._emitLine("}");
            if (name.charAt(0) !== "_") {
                this._emitLine("if(frame.topLevel) {");
                this._emitLine(`context.addExport("${name}", ${id});`);
                this._emitLine("}");
            }
        });
    }
    compileSwitch(node, frame) {
        this._emit("switch (");
        this.compile(node.expr, frame);
        this._emit(") {");
        node.cases.forEach((c, i)=>{
            this._emit("case ");
            this.compile(c.cond, frame);
            this._emit(": ");
            this.compile(c.body, frame);
            if (c.body.children.length) {
                this._emitLine("break;");
            }
        });
        if (node.default) {
            this._emit("default:");
            this.compile(node.default, frame);
        }
        this._emit("}");
    }
    compileIf(node, frame, async) {
        this._emit("if(");
        this._compileExpression(node.cond, frame);
        this._emitLine(") {");
        this._withScopedSyntax(()=>{
            this.compile(node.body, frame);
            if (async) {
                this._emit("cb()");
            }
        });
        if (node.else_) {
            this._emitLine("}\nelse {");
            this._withScopedSyntax(()=>{
                this.compile(node.else_, frame);
                if (async) {
                    this._emit("cb()");
                }
            });
        } else if (async) {
            this._emitLine("}\nelse {");
            this._emit("cb()");
        }
        this._emitLine("}");
    }
    compileIfAsync(node, frame) {
        this._emit("(function(cb) {");
        this.compileIf(node, frame, true);
        this._emit("})(" + this._makeCallback());
        this._addScopeLevel();
    }
    _emitLoopBindings(node, arr, i, len) {
        const bindings = [
            {
                name: "index",
                val: `${i} + 1`
            },
            {
                name: "index0",
                val: i
            },
            {
                name: "revindex",
                val: `${len} - ${i}`
            },
            {
                name: "revindex0",
                val: `${len} - ${i} - 1`
            },
            {
                name: "first",
                val: `${i} === 0`
            },
            {
                name: "last",
                val: `${i} === ${len} - 1`
            },
            {
                name: "length",
                val: len
            }, 
        ];
        bindings.forEach((b)=>{
            this._emitLine(`frame.set("loop.${b.name}", ${b.val});`);
        });
    }
    compileFor(node, frame) {
        const i = this._tmpid();
        const len = this._tmpid();
        const arr = this._tmpid();
        frame = frame.push();
        this._emitLine("frame = frame.push();");
        this._emit(`var ${arr} = `);
        this._compileExpression(node.arr, frame);
        this._emitLine(";");
        this._emit(`if(${arr}) {`);
        this._emitLine(arr + " = runtime.fromIterator(" + arr + ");");
        if (node.name instanceof __default3.Array) {
            this._emitLine(`var ${i};`);
            this._emitLine(`if(runtime.isArray(${arr})) {`);
            this._emitLine(`var ${len} = ${arr}.length;`);
            this._emitLine(`for(${i}=0; ${i} < ${arr}.length; ${i}++) {`);
            node.name.children.forEach((child, u)=>{
                var tid = this._tmpid();
                this._emitLine(`var ${tid} = ${arr}[${i}][${u}];`);
                this._emitLine(`frame.set("${child}", ${arr}[${i}][${u}]);`);
                frame.set(node.name.children[u].value, tid);
            });
            this._emitLoopBindings(node, arr, i, len);
            this._withScopedSyntax(()=>{
                this.compile(node.body, frame);
            });
            this._emitLine("}");
            this._emitLine("} else {");
            const [key, val] = node.name.children;
            const k = this._tmpid();
            const v = this._tmpid();
            frame.set(key.value, k);
            frame.set(val.value, v);
            this._emitLine(`${i} = -1;`);
            this._emitLine(`var ${len} = runtime.keys(${arr}).length;`);
            this._emitLine(`for(var ${k} in ${arr}) {`);
            this._emitLine(`${i}++;`);
            this._emitLine(`var ${v} = ${arr}[${k}];`);
            this._emitLine(`frame.set("${key.value}", ${k});`);
            this._emitLine(`frame.set("${val.value}", ${v});`);
            this._emitLoopBindings(node, arr, i, len);
            this._withScopedSyntax(()=>{
                this.compile(node.body, frame);
            });
            this._emitLine("}");
            this._emitLine("}");
        } else {
            const v1 = this._tmpid();
            frame.set(node.name.value, v1);
            this._emitLine(`var ${len} = ${arr}.length;`);
            this._emitLine(`for(var ${i}=0; ${i} < ${arr}.length; ${i}++) {`);
            this._emitLine(`var ${v1} = ${arr}[${i}];`);
            this._emitLine(`frame.set("${node.name.value}", ${v1});`);
            this._emitLoopBindings(node, arr, i, len);
            this._withScopedSyntax(()=>{
                this.compile(node.body, frame);
            });
            this._emitLine("}");
        }
        this._emitLine("}");
        if (node.else_) {
            this._emitLine("if (!" + len + ") {");
            this.compile(node.else_, frame);
            this._emitLine("}");
        }
        this._emitLine("frame = frame.pop();");
    }
    _compileAsyncLoop(node, frame, parallel) {
        var i = this._tmpid();
        var len = this._tmpid();
        var arr = this._tmpid();
        var asyncMethod = parallel ? "asyncAll" : "asyncEach";
        frame = frame.push();
        this._emitLine("frame = frame.push();");
        this._emit("var " + arr + " = runtime.fromIterator(");
        this._compileExpression(node.arr, frame);
        this._emitLine(");");
        if (node.name instanceof __default3.Array) {
            const arrayLen = node.name.children.length;
            this._emit(`runtime.${asyncMethod}(${arr}, ${arrayLen}, function(`);
            node.name.children.forEach((name)=>{
                this._emit(`${name.value},`);
            });
            this._emit(i + "," + len + ",next) {");
            node.name.children.forEach((name)=>{
                const id = name.value;
                frame.set(id, id);
                this._emitLine(`frame.set("${id}", ${id});`);
            });
        } else {
            const id = node.name.value;
            this._emitLine(`runtime.${asyncMethod}(${arr}, 1, function(${id}, ${i}, ${len},next) {`);
            this._emitLine('frame.set("' + id + '", ' + id + ");");
            frame.set(id, id);
        }
        this._emitLoopBindings(node, arr, i, len);
        this._withScopedSyntax(()=>{
            let buf;
            if (parallel) {
                buf = this._pushBuffer();
            }
            this.compile(node.body, frame);
            this._emitLine("next(" + i + (buf ? "," + buf : "") + ");");
            if (parallel) {
                this._popBuffer();
            }
        });
        const output = this._tmpid();
        this._emitLine("}, " + this._makeCallback(output));
        this._addScopeLevel();
        if (parallel) {
            this._emitLine(this.buffer + " += " + output + ";");
        }
        if (node.else_) {
            this._emitLine("if (!" + arr + ".length) {");
            this.compile(node.else_, frame);
            this._emitLine("}");
        }
        this._emitLine("frame = frame.pop();");
    }
    compileAsyncEach(node, frame) {
        this._compileAsyncLoop(node, frame);
    }
    compileAsyncAll(node, frame) {
        this._compileAsyncLoop(node, frame, true);
    }
    _compileMacro(node, frame) {
        var args = [];
        var kwargs = null;
        var funcId = "macro_" + this._tmpid();
        var keepFrame = frame !== undefined;
        node.args.children.forEach((arg, i)=>{
            if (i === node.args.children.length - 1 && arg instanceof __default3.Dict) {
                kwargs = arg;
            } else {
                this.assertType(arg, __default3.Symbol);
                args.push(arg);
            }
        });
        const realNames = [
            ...args.map((n)=>`l_${n.value}`),
            "kwargs"
        ];
        const argNames = args.map((n)=>`"${n.value}"`);
        const kwargNames = (kwargs && kwargs.children || []).map((n)=>`"${n.key.value}"`);
        let currFrame;
        if (keepFrame) {
            currFrame = frame.push(true);
        } else {
            currFrame = new Frame();
        }
        this._emitLines(`var ${funcId} = runtime.makeMacro(`, `[${argNames.join(", ")}], `, `[${kwargNames.join(", ")}], `, `function (${realNames.join(", ")}) {`, "var callerFrame = frame;", "frame = " + (keepFrame ? "frame.push(true);" : "new runtime.Frame();"), "kwargs = kwargs || {};", 'if (Object.prototype.hasOwnProperty.call(kwargs, "caller")) {', 'frame.set("caller", kwargs.caller); }');
        args.forEach((arg)=>{
            this._emitLine(`frame.set("${arg.value}", l_${arg.value});`);
            currFrame.set(arg.value, `l_${arg.value}`);
        });
        if (kwargs) {
            kwargs.children.forEach((pair)=>{
                const name = pair.key.value;
                this._emit(`frame.set("${name}", `);
                this._emit(`Object.prototype.hasOwnProperty.call(kwargs, "${name}")`);
                this._emit(` ? kwargs["${name}"] : `);
                this._compileExpression(pair.value, currFrame);
                this._emit(");");
            });
        }
        const bufferId = this._pushBuffer();
        this._withScopedSyntax(()=>{
            this.compile(node.body, currFrame);
        });
        this._emitLine("frame = " + (keepFrame ? "frame.pop();" : "callerFrame;"));
        this._emitLine(`return new runtime.SafeString(${bufferId});`);
        this._emitLine("});");
        this._popBuffer();
        return funcId;
    }
    compileMacro(node, frame) {
        var funcId = this._compileMacro(node);
        var name = node.name.value;
        frame.set(name, funcId);
        if (frame.parent) {
            this._emitLine(`frame.set("${name}", ${funcId});`);
        } else {
            if (node.name.value.charAt(0) !== "_") {
                this._emitLine(`context.addExport("${name}");`);
            }
            this._emitLine(`context.setVariable("${name}", ${funcId});`);
        }
    }
    compileCaller(node, frame) {
        this._emit("(function (){");
        const funcId = this._compileMacro(node, frame);
        this._emit(`return ${funcId};})()`);
    }
    _compileGetTemplate(node, frame, eagerCompile, ignoreMissing) {
        const parentTemplateId = this._tmpid();
        const parentName = this._templateName();
        const cb = this._makeCallback(parentTemplateId);
        const eagerCompileArg = eagerCompile ? "true" : "false";
        const ignoreMissingArg = ignoreMissing ? "true" : "false";
        this._emit("env.getTemplate(");
        this._compileExpression(node.template, frame);
        this._emitLine(`, ${eagerCompileArg}, ${parentName}, ${ignoreMissingArg}, ${cb}`);
        return parentTemplateId;
    }
    compileImport(node, frame) {
        const target = node.target.value;
        const id = this._compileGetTemplate(node, frame, false, false);
        this._addScopeLevel();
        this._emitLine(id + ".getExported(" + (node.withContext ? "context.getVariables(), frame, " : "") + this._makeCallback(id));
        this._addScopeLevel();
        frame.set(target, id);
        if (frame.parent) {
            this._emitLine(`frame.set("${target}", ${id});`);
        } else {
            this._emitLine(`context.setVariable("${target}", ${id});`);
        }
    }
    compileFromImport(node, frame) {
        const importedId = this._compileGetTemplate(node, frame, false, false);
        this._addScopeLevel();
        this._emitLine(importedId + ".getExported(" + (node.withContext ? "context.getVariables(), frame, " : "") + this._makeCallback(importedId));
        this._addScopeLevel();
        node.names.children.forEach((nameNode)=>{
            var name;
            var alias;
            var id = this._tmpid();
            if (nameNode instanceof __default3.Pair) {
                name = nameNode.key.value;
                alias = nameNode.value.value;
            } else {
                name = nameNode.value;
                alias = name;
            }
            this._emitLine(`if(Object.prototype.hasOwnProperty.call(${importedId}, "${name}")) {`);
            this._emitLine(`var ${id} = ${importedId}.${name};`);
            this._emitLine("} else {");
            this._emitLine(`cb(new Error("cannot import '${name}'")); return;`);
            this._emitLine("}");
            frame.set(alias, id);
            if (frame.parent) {
                this._emitLine(`frame.set("${alias}", ${id});`);
            } else {
                this._emitLine(`context.setVariable("${alias}", ${id});`);
            }
        });
    }
    compileBlock(node) {
        var id = this._tmpid();
        if (!this.inBlock) {
            this._emit('(parentTemplate ? function(e, c, f, r, cb) { cb(""); } : ');
        }
        this._emit(`context.getBlock("${node.name.value}")`);
        if (!this.inBlock) {
            this._emit(")");
        }
        this._emitLine("(env, context, frame, runtime, " + this._makeCallback(id));
        this._emitLine(`${this.buffer} += ${id};`);
        this._addScopeLevel();
    }
    compileSuper(node, frame) {
        var name = node.blockName.value;
        var id = node.symbol.value;
        const cb = this._makeCallback(id);
        this._emitLine(`context.getSuper(env, "${name}", b_${name}, frame, runtime, ${cb}`);
        this._emitLine(`${id} = runtime.markSafe(${id});`);
        this._addScopeLevel();
        frame.set(id, id);
    }
    compileExtends(node, frame) {
        var k = this._tmpid();
        const parentTemplateId = this._compileGetTemplate(node, frame, true, false);
        this._emitLine(`parentTemplate = ${parentTemplateId}`);
        this._emitLine(`for(var ${k} in parentTemplate.blocks) {`);
        this._emitLine(`context.addBlock(${k}, parentTemplate.blocks[${k}]);`);
        this._emitLine("}");
        this._addScopeLevel();
    }
    compileInclude(node, frame) {
        this._emitLine("var tasks = [];");
        this._emitLine("tasks.push(");
        this._emitLine("function(callback) {");
        const id = this._compileGetTemplate(node, frame, false, node.ignoreMissing);
        this._emitLine(`callback(null,${id});});`);
        this._emitLine("});");
        const id2 = this._tmpid();
        this._emitLine("tasks.push(");
        this._emitLine("function(template, callback){");
        this._emitLine("template.render(context.getVariables(), frame, " + this._makeCallback(id2));
        this._emitLine("callback(null," + id2 + ");});");
        this._emitLine("});");
        this._emitLine("tasks.push(");
        this._emitLine("function(result, callback){");
        this._emitLine(`${this.buffer} += result;`);
        this._emitLine("callback(null);");
        this._emitLine("});");
        this._emitLine("env.waterfall(tasks, function(){");
        this._addScopeLevel();
    }
    compileTemplateData(node, frame) {
        this.compileLiteral(node, frame);
    }
    compileCapture(node, frame) {
        var buffer = this.buffer;
        this.buffer = "output";
        this._emitLine("(function() {");
        this._emitLine('var output = "";');
        this._withScopedSyntax(()=>{
            this.compile(node.body, frame);
        });
        this._emitLine("return output;");
        this._emitLine("})()");
        this.buffer = buffer;
    }
    compileOutput(node, frame) {
        const children = node.children;
        children.forEach((child)=>{
            if (child instanceof __default3.TemplateData) {
                if (child.value) {
                    this._emit(`${this.buffer} += `);
                    this.compileLiteral(child, frame);
                    this._emitLine(";");
                }
            } else {
                this._emit(`${this.buffer} += runtime.suppressValue(`);
                if (this.throwOnUndefined) {
                    this._emit("runtime.ensureDefined(");
                }
                this.compile(child, frame);
                if (this.throwOnUndefined) {
                    this._emit(`,${node.lineno},${node.colno})`);
                }
                this._emit(", env.opts.autoescape);\n");
            }
        });
    }
    compileRoot(node, frame) {
        if (frame) {
            this.fail("compileRoot: root node can't have frame");
        }
        frame = new Frame();
        this._emitFuncBegin(node, "root");
        this._emitLine("var parentTemplate = null;");
        this._compileChildren(node, frame);
        this._emitLine("if(parentTemplate) {");
        this._emitLine("parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);");
        this._emitLine("} else {");
        this._emitLine(`cb(null, ${this.buffer});`);
        this._emitLine("}");
        this._emitFuncEnd(true);
        this.inBlock = true;
        const blockNames = [];
        const blocks = node.findAll(__default3.Block);
        blocks.forEach((block, i)=>{
            const name = block.name.value;
            if (blockNames.indexOf(name) !== -1) {
                throw new Error(`Block "${name}" defined more than once.`);
            }
            blockNames.push(name);
            this._emitFuncBegin(block, `b_${name}`);
            const tmpFrame = new Frame();
            this._emitLine("var frame = frame.push(true);");
            this.compile(block.body, tmpFrame);
            this._emitFuncEnd();
        });
        this._emitLine("return {");
        blocks.forEach((block, i)=>{
            const blockName = `b_${block.name.value}`;
            this._emitLine(`${blockName}: ${blockName},`);
        });
        this._emitLine("root: root\n};");
    }
    compile(node, frame) {
        var _compile = this["compile" + node.typename];
        if (_compile) {
            _compile.call(this, node, frame);
        } else {
            this.fail(`compile: Cannot compile node: ${node.typename}`, node.lineno, node.colno);
        }
    }
    getCode() {
        return this.codebuf.join("");
    }
}
const __default6 = {
    compile: function compile(src, asyncFilters, extensions, name, opts = {}) {
        const c = new Compiler(name, opts.throwOnUndefined);
        const preprocessors = (extensions || []).map((ext)=>ext.preprocess).filter((f)=>!!f);
        const processedSrc = preprocessors.reduce((s, processor)=>processor(s), src);
        c.compile(__default5.transform(__default4.parse(processedSrc, extensions, opts), asyncFilters, name));
        return c.getCode();
    },
    Compiler: Compiler
};
var exports = {};
function normalize12(value, defaultValue) {
    if (value === null || value === undefined || value === false) {
        return defaultValue;
    }
    return value;
}
exports.abs = Math.abs;
function isNaN1(num) {
    return num !== num;
}
function batch(arr, linecount, fillWith) {
    var i;
    var res = [];
    var tmp = [];
    for(i = 0; i < arr.length; i++){
        if (i % linecount === 0 && tmp.length) {
            res.push(tmp);
            tmp = [];
        }
        tmp.push(arr[i]);
    }
    if (tmp.length) {
        if (fillWith) {
            for(i = tmp.length; i < linecount; i++){
                tmp.push(fillWith);
            }
        }
        res.push(tmp);
    }
    return res;
}
exports.batch = batch;
function capitalize(str) {
    str = normalize12(str, "");
    const ret = str.toLowerCase();
    return copySafeness(str, ret.charAt(0).toUpperCase() + ret.slice(1));
}
exports.capitalize = capitalize;
function center(str, width) {
    str = normalize12(str, "");
    width = width || 80;
    if (str.length >= width) {
        return str;
    }
    const spaces = width - str.length;
    const pre = repeat(" ", spaces / 2 - spaces % 2);
    const post = repeat(" ", spaces / 2);
    return copySafeness(str, pre + str + post);
}
exports.center = center;
function default_(val, def, bool) {
    if (bool) {
        return val || def;
    } else {
        return val !== undefined ? val : def;
    }
}
exports["default"] = default_;
function dictsort(val, caseSensitive, by) {
    if (!isObject1(val)) {
        throw new TemplateError("dictsort filter: val must be an object");
    }
    let array = [];
    for(let k in val){
        array.push([
            k,
            val[k]
        ]);
    }
    let si;
    if (by === undefined || by === "key") {
        si = 0;
    } else if (by === "value") {
        si = 1;
    } else {
        throw new TemplateError("dictsort filter: You can only sort by either key or value");
    }
    array.sort((t1, t2)=>{
        var a = t1[si];
        var b = t2[si];
        if (!caseSensitive) {
            if (isString(a)) {
                a = a.toUpperCase();
            }
            if (isString(b)) {
                b = b.toUpperCase();
            }
        }
        return a > b ? 1 : a === b ? 0 : -1;
    });
    return array;
}
exports.dictsort = dictsort;
function dump(obj, spaces) {
    return JSON.stringify(obj, null, spaces);
}
exports.dump = dump;
function escape1(str) {
    if (str instanceof SafeString) {
        return str;
    }
    str = str === null || str === undefined ? "" : str;
    return markSafe(escape(str.toString()));
}
exports.escape = escape1;
function safe(str) {
    if (str instanceof SafeString) {
        return str;
    }
    str = str === null || str === undefined ? "" : str;
    return markSafe(str.toString());
}
exports.safe = safe;
function first(arr) {
    return arr[0];
}
exports.first = first;
function forceescape(str) {
    str = str === null || str === undefined ? "" : str;
    return markSafe(escape(str.toString()));
}
exports.forceescape = forceescape;
function groupby(arr, attr) {
    return groupBy(arr, attr, this.env.opts.throwOnUndefined);
}
exports.groupby = groupby;
function indent(str, width, indentfirst) {
    str = normalize12(str, "");
    if (str === "") {
        return "";
    }
    width = width || 4;
    const lines = str.split("\n");
    const sp = repeat(" ", width);
    const res = lines.map((l, i)=>{
        return i === 0 && !indentfirst ? l : `${sp}${l}`;
    }).join("\n");
    return copySafeness(str, res);
}
exports.indent = indent;
function join12(arr, del, attr) {
    del = del || "";
    if (attr) {
        arr = map(arr, (v)=>v[attr]);
    }
    return arr.join(del);
}
exports.join = join12;
function last1(arr) {
    return arr[arr.length - 1];
}
exports.last = last1;
function lengthFilter(val) {
    var value = normalize12(val, "");
    if (value !== undefined) {
        if (typeof Map === "function" && value instanceof Map || typeof Set === "function" && value instanceof Set) {
            return value.size;
        }
        if (isObject1(value) && !(value instanceof SafeString)) {
            return keys_(value).length;
        }
        return value.length;
    }
    return 0;
}
exports.length = lengthFilter;
function list(val) {
    if (isString(val)) {
        return val.split("");
    } else if (isObject1(val)) {
        return _entries(val || {}).map(([key, value])=>({
                key,
                value
            }));
    } else if (isArray(val)) {
        return val;
    } else {
        throw new TemplateError("list filter: type not iterable");
    }
}
exports.list = list;
function lower(str) {
    str = normalize12(str, "");
    return str.toLowerCase();
}
exports.lower = lower;
function nl2br(str) {
    if (str === null || str === undefined) {
        return "";
    }
    return copySafeness(str, str.replace(/\r\n|\n/g, "<br />\n"));
}
exports.nl2br = nl2br;
function random(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
}
exports.random = random;
function getSelectOrReject(expectedTestResult) {
    function filter(arr, testName = "truthy", secondArg) {
        const context = this;
        const test = context.env.getTest(testName);
        return toArray(arr).filter(function examineTestResult(item) {
            return test.call(context, item, secondArg) === expectedTestResult;
        });
    }
    return filter;
}
exports.reject = getSelectOrReject(false);
function rejectattr(arr, attr) {
    return arr.filter((item)=>!item[attr]);
}
exports.rejectattr = rejectattr;
exports.select = getSelectOrReject(true);
function selectattr(arr, attr) {
    return arr.filter((item)=>!!item[attr]);
}
exports.selectattr = selectattr;
function replace(str, old, new_, maxCount) {
    var originalStr = str;
    if (old instanceof RegExp) {
        return str.replace(old, new_);
    }
    if (typeof maxCount === "undefined") {
        maxCount = -1;
    }
    let res = "";
    if (typeof old === "number") {
        old = "" + old;
    } else if (typeof old !== "string") {
        return str;
    }
    if (typeof str === "number") {
        str = "" + str;
    }
    if (typeof str !== "string" && !(str instanceof SafeString)) {
        return str;
    }
    if (old === "") {
        res = new_ + str.split("").join(new_) + new_;
        return copySafeness(str, res);
    }
    let nextIndex = str.indexOf(old);
    if (maxCount === 0 || nextIndex === -1) {
        return str;
    }
    let pos = 0;
    let count = 0;
    while(nextIndex > -1 && (maxCount === -1 || count < maxCount)){
        res += str.substring(pos, nextIndex) + new_;
        pos = nextIndex + old.length;
        count++;
        nextIndex = str.indexOf(old, pos);
    }
    if (pos < str.length) {
        res += str.substring(pos);
    }
    return copySafeness(originalStr, res);
}
exports.replace = replace;
function reverse(val) {
    var arr;
    if (isString(val)) {
        arr = list(val);
    } else {
        arr = map(val, (v)=>v);
    }
    arr.reverse();
    if (isString(val)) {
        return copySafeness(val, arr.join(""));
    }
    return arr;
}
exports.reverse = reverse;
function round(val, precision, method) {
    precision = precision || 0;
    const factor = Math.pow(10, precision);
    let rounder;
    if (method === "ceil") {
        rounder = Math.ceil;
    } else if (method === "floor") {
        rounder = Math.floor;
    } else {
        rounder = Math.round;
    }
    return rounder(val * factor) / factor;
}
exports.round = round;
function slice(arr, slices, fillWith) {
    const sliceLength = Math.floor(arr.length / slices);
    const extra = arr.length % slices;
    const res = [];
    let offset = 0;
    for(let i = 0; i < slices; i++){
        const start = offset + i * sliceLength;
        if (i < extra) {
            offset++;
        }
        const end = offset + (i + 1) * sliceLength;
        const currSlice = arr.slice(start, end);
        if (fillWith && i >= extra) {
            currSlice.push(fillWith);
        }
        res.push(currSlice);
    }
    return res;
}
exports.slice = slice;
function sum(arr, attr, start = 0) {
    if (attr) {
        arr = map(arr, (v)=>v[attr]);
    }
    return start + arr.reduce((a, b)=>a + b, 0);
}
exports.sum = sum;
exports.sort = makeMacro([
    "value",
    "reverse",
    "case_sensitive",
    "attribute"
], [], function sortFilter(arr, reversed, caseSens, attr) {
    let array = map(arr, (v)=>v);
    let getAttribute = getAttrGetter(attr);
    array.sort((a, b)=>{
        let x = attr ? getAttribute(a) : a;
        let y = attr ? getAttribute(b) : b;
        if (this.env.opts.throwOnUndefined && attr && (x === undefined || y === undefined)) {
            throw new TypeError(`sort: attribute "${attr}" resolved to undefined`);
        }
        if (!caseSens && isString(x) && isString(y)) {
            x = x.toLowerCase();
            y = y.toLowerCase();
        }
        if (x < y) {
            return reversed ? 1 : -1;
        } else if (x > y) {
            return reversed ? -1 : 1;
        } else {
            return 0;
        }
    });
    return array;
});
function string(obj) {
    return copySafeness(obj, obj);
}
exports.string = string;
function striptags(input, preserveLinebreaks) {
    input = normalize12(input, "");
    let tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>|<!--[\s\S]*?-->/gi;
    let trimmedInput = trim(input.replace(tags, ""));
    let res = "";
    if (preserveLinebreaks) {
        res = trimmedInput.replace(/^ +| +$/gm, "").replace(/ +/g, " ").replace(/(\r\n)/g, "\n").replace(/\n\n\n+/g, "\n\n");
    } else {
        res = trimmedInput.replace(/\s+/gi, " ");
    }
    return copySafeness(input, res);
}
exports.striptags = striptags;
function title1(str) {
    str = normalize12(str, "");
    let words = str.split(" ").map((word)=>capitalize(word));
    return copySafeness(str, words.join(" "));
}
exports.title = title1;
function trim(str) {
    return copySafeness(str, str.replace(/^\s*|\s*$/g, ""));
}
exports.trim = trim;
function truncate(input, length, killwords, end) {
    var orig = input;
    input = normalize12(input, "");
    length = length || 255;
    if (input.length <= length) {
        return input;
    }
    if (killwords) {
        input = input.substring(0, length);
    } else {
        let idx = input.lastIndexOf(" ", length);
        if (idx === -1) {
            idx = length;
        }
        input = input.substring(0, idx);
    }
    input += end !== undefined && end !== null ? end : "...";
    return copySafeness(orig, input);
}
exports.truncate = truncate;
function upper(str) {
    str = normalize12(str, "");
    return str.toUpperCase();
}
exports.upper = upper;
function urlencode(obj) {
    var enc = encodeURIComponent;
    if (isString(obj)) {
        return enc(obj);
    } else {
        let keyvals = isArray(obj) ? obj : _entries(obj);
        return keyvals.map(([k, v])=>`${enc(k)}=${enc(v)}`).join("&");
    }
}
exports.urlencode = urlencode;
const puncRe = /^(?:\(|<|&lt;)?(.*?)(?:\.|,|\)|\n|&gt;)?$/;
const emailRe = /^[\w.!#$%&'*+\-\/=?\^`{|}~]+@[a-z\d\-]+(\.[a-z\d\-]+)+$/i;
const httpHttpsRe = /^https?:\/\/.*$/;
const wwwRe = /^www\./;
const tldRe = /\.(?:org|net|com)(?:\:|\/|$)/;
function urlize(str, length, nofollow) {
    if (isNaN1(length)) {
        length = Infinity;
    }
    const noFollowAttr = nofollow === true ? ' rel="nofollow"' : "";
    const words = str.split(/(\s+)/).filter((word)=>{
        return word && word.length;
    }).map((word)=>{
        var matches = word.match(puncRe);
        var possibleUrl = matches ? matches[1] : word;
        var shortUrl = possibleUrl.substr(0, length);
        if (httpHttpsRe.test(possibleUrl)) {
            return `<a href="${possibleUrl}"${noFollowAttr}>${shortUrl}</a>`;
        }
        if (wwwRe.test(possibleUrl)) {
            return `<a href="http://${possibleUrl}"${noFollowAttr}>${shortUrl}</a>`;
        }
        if (emailRe.test(possibleUrl)) {
            return `<a href="mailto:${possibleUrl}">${possibleUrl}</a>`;
        }
        if (tldRe.test(possibleUrl)) {
            return `<a href="http://${possibleUrl}"${noFollowAttr}>${shortUrl}</a>`;
        }
        return word;
    });
    return words.join("");
}
exports.urlize = urlize;
function wordcount(str) {
    str = normalize12(str, "");
    const words = str ? str.match(/\w+/g) : null;
    return words ? words.length : null;
}
exports.wordcount = wordcount;
function __float(val, def) {
    var res = parseFloat(val);
    return isNaN1(res) ? def : res;
}
exports.float = __float;
const intFilter = makeMacro([
    "value",
    "default",
    "base"
], [], function doInt(value, defaultValue, base = 10) {
    var res = parseInt(value, base);
    return isNaN1(res) ? defaultValue : res;
});
exports.int = intFilter;
exports.d = exports.default;
exports.e = exports.escape;
class Loader extends EmitterObj {
    resolve(from, to) {
        return mod7.resolve(mod7.dirname(from), to);
    }
    isRelative(filename) {
        return filename.indexOf("./") === 0 || filename.indexOf("../") === 0;
    }
}
class PrecompiledLoader extends Loader {
    constructor(compiledTemplates){
        super();
        this.precompiled = compiledTemplates || {};
    }
    getSource(name) {
        if (this.precompiled[name]) {
            return {
                src: {
                    type: "code",
                    obj: this.precompiled[name]
                },
                path: name
            };
        }
        return null;
    }
}
class FileSystemLoader extends Loader {
    constructor(searchPaths, opts){
        super();
        if (typeof opts === "boolean") {
            console.log("[nunjucks] Warning: you passed a boolean as the second " + "argument to FileSystemLoader, but it now takes an options " + "object. See http://mozilla.github.io/nunjucks/api.html#filesystemloader");
        }
        opts = opts || {};
        this.pathsToNames = {};
        this.noCache = !!opts.noCache;
        if (searchPaths) {
            searchPaths = Array.isArray(searchPaths) ? searchPaths : [
                searchPaths
            ];
            this.searchPaths = searchPaths.map(mod7.normalize);
        } else {
            this.searchPaths = [
                "."
            ];
        }
        if (opts.watch) {
            throw new Error("The `watch` option is not supported by the Deno fork of Nunjucks");
        }
    }
    getSource(name) {
        var fullpath = null;
        var paths = this.searchPaths;
        for(let i = 0; i < paths.length; i++){
            const basePath = mod7.resolve(paths[i]);
            const p = mod7.resolve(paths[i], name);
            if (p.indexOf(basePath) === 0 && existsSync(p)) {
                fullpath = p;
                break;
            }
        }
        if (!fullpath) {
            return null;
        }
        this.pathsToNames[fullpath] = name;
        const source = {
            src: Deno.readTextFileSync(fullpath),
            path: fullpath,
            noCache: this.noCache
        };
        this.emit("load", name, source);
        return source;
    }
}
class NodeResolveLoader extends Loader {
    constructor(opts){
        super();
        opts = opts || {};
        this.pathsToNames = {};
        this.noCache = !!opts.noCache;
        if (opts.watch) {
            throw new Error("The `watch` option is not supported by the Deno fork of Nunjucks");
        }
    }
    getSource(name) {
        if (/^\.?\.?(\/|\\)/.test(name)) {
            return null;
        }
        if (/^[A-Z]:/.test(name)) {
            return null;
        }
        let fullpath;
        try {
            fullpath = require.resolve(name);
        } catch (e) {
            return null;
        }
        this.pathsToNames[fullpath] = name;
        const source = {
            src: Deno.readTextFileSync(fullpath),
            path: fullpath,
            noCache: this.noCache
        };
        this.emit("load", name, source);
        return source;
    }
}
const exports1 = {};
function callable(value) {
    return typeof value === "function";
}
exports1.callable = callable;
function defined(value) {
    return value !== undefined;
}
exports1.defined = defined;
function divisibleby(one, two) {
    return one % two === 0;
}
exports1.divisibleby = divisibleby;
function escaped(value) {
    return value instanceof SafeString;
}
exports1.escaped = escaped;
function equalto(one, two) {
    return one === two;
}
exports1.equalto = equalto;
exports1.eq = exports1.equalto;
exports1.sameas = exports1.equalto;
function even(value) {
    return value % 2 === 0;
}
exports1.even = even;
function falsy(value) {
    return !value;
}
exports1.falsy = falsy;
function ge(one, two) {
    return one >= two;
}
exports1.ge = ge;
function greaterthan(one, two) {
    return one > two;
}
exports1.greaterthan = greaterthan;
exports1.gt = exports1.greaterthan;
function le(one, two) {
    return one <= two;
}
exports1.le = le;
function lessthan(one, two) {
    return one < two;
}
exports1.lessthan = lessthan;
exports1.lt = exports1.lessthan;
function lower1(value) {
    return value.toLowerCase() === value;
}
exports1.lower = lower1;
function ne(one, two) {
    return one !== two;
}
exports1.ne = ne;
function nullTest(value) {
    return value === null;
}
exports1.null = nullTest;
function number(value) {
    return typeof value === "number";
}
exports1.number = number;
function odd(value) {
    return value % 2 === 1;
}
exports1.odd = odd;
function string1(value) {
    return typeof value === "string";
}
exports1.string = string1;
function truthy(value) {
    return !!value;
}
exports1.truthy = truthy;
function undefinedTest(value) {
    return value === undefined;
}
exports1.undefined = undefinedTest;
function upper1(value) {
    return value.toUpperCase() === value;
}
exports1.upper = upper1;
function iterable(value) {
    if (typeof Symbol !== "undefined") {
        return !!value[Symbol.iterator];
    } else {
        return Array.isArray(value) || typeof value === "string";
    }
}
exports1.iterable = iterable;
function mapping(value) {
    var bool = value !== null && value !== undefined && typeof value === "object" && !Array.isArray(value);
    if (Set) {
        return bool && !(value instanceof Set);
    } else {
        return bool;
    }
}
exports1.mapping = mapping;
function cycler(items) {
    var index = -1;
    return {
        current: null,
        reset () {
            index = -1;
            this.current = null;
        },
        next () {
            index++;
            if (index >= items.length) {
                index = 0;
            }
            this.current = items[index];
            return this.current;
        }
    };
}
function joiner(sep) {
    sep = sep || ",";
    let first = true;
    return ()=>{
        const val = first ? "" : sep;
        first = false;
        return val;
    };
}
function globals() {
    return {
        range (start, stop, step) {
            if (typeof stop === "undefined") {
                stop = start;
                start = 0;
                step = 1;
            } else if (!step) {
                step = 1;
            }
            const arr = [];
            if (step > 0) {
                for(let i = start; i < stop; i += step){
                    arr.push(i);
                }
            } else {
                for(let i1 = start; i1 > stop; i1 += step){
                    arr.push(i1);
                }
            }
            return arr;
        },
        cycler () {
            return cycler(Array.prototype.slice.call(arguments));
        },
        joiner (sep) {
            return joiner(sep);
        }
    };
}
function express(env, app) {
    function NunjucksView(name, opts) {
        this.name = name;
        this.path = name;
        this.defaultEngine = opts.defaultEngine;
        this.ext = mod7.extname(name);
        if (!this.ext && !this.defaultEngine) {
            throw new Error("No default engine was specified and no extension was provided.");
        }
        if (!this.ext) {
            this.name += this.ext = (this.defaultEngine[0] !== "." ? "." : "") + this.defaultEngine;
        }
    }
    NunjucksView.prototype.render = function render(opts, cb) {
        env.render(this.name, opts, cb);
    };
    app.set("view", NunjucksView);
    app.set("nunjucksEnv", env);
    return env;
}
const { handleError: handleError1 , Frame: Frame1  } = mod8;
function callbackAsap(cb, err, res) {
    queueMicrotask(()=>{
        cb(err, res);
    });
}
const noopTmplSrc = {
    type: "code",
    obj: {
        root (env, context, frame, runtime, cb) {
            try {
                cb(null, "");
            } catch (e) {
                cb(handleError1(e, null, null));
            }
        }
    }
};
class Environment extends EmitterObj {
    init(loaders, opts) {
        opts = this.opts = opts || {};
        this.opts.dev = !!opts.dev;
        this.opts.autoescape = opts.autoescape != null ? opts.autoescape : true;
        this.opts.throwOnUndefined = !!opts.throwOnUndefined;
        this.opts.trimBlocks = !!opts.trimBlocks;
        this.opts.lstripBlocks = !!opts.lstripBlocks;
        this.loaders = [];
        if (!loaders) {
            if (FileSystemLoader) {
                this.loaders = [
                    new FileSystemLoader("views")
                ];
            }
        } else {
            this.loaders = isArray(loaders) ? loaders : [
                loaders
            ];
        }
        if (typeof window !== "undefined" && window.nunjucksPrecompiled) {
            this.loaders.unshift(new PrecompiledLoader(window.nunjucksPrecompiled));
        }
        this._initLoaders();
        this.globals = globals();
        this.filters = {};
        this.tests = {};
        this.asyncFilters = [];
        this.extensions = {};
        this.extensionsList = [];
        _entries(exports).forEach(([name, filter])=>this.addFilter(name, filter));
        _entries(exports1).forEach(([name, test])=>this.addTest(name, test));
    }
    _initLoaders() {
        this.loaders.forEach((loader)=>{
            loader.cache = {};
            if (typeof loader.on === "function") {
                loader.on("update", (name, fullname)=>{
                    loader.cache[name] = null;
                    this.emit("update", name, fullname, loader);
                });
                loader.on("load", (name, source)=>{
                    this.emit("load", name, source, loader);
                });
            }
        });
    }
    invalidateCache() {
        this.loaders.forEach((loader)=>{
            loader.cache = {};
        });
    }
    addExtension(name, extension) {
        extension.__name = name;
        this.extensions[name] = extension;
        this.extensionsList.push(extension);
        return this;
    }
    removeExtension(name) {
        var extension = this.getExtension(name);
        if (!extension) {
            return;
        }
        this.extensionsList = without(this.extensionsList, extension);
        delete this.extensions[name];
    }
    getExtension(name) {
        return this.extensions[name];
    }
    hasExtension(name) {
        return !!this.extensions[name];
    }
    addGlobal(name, value) {
        this.globals[name] = value;
        return this;
    }
    getGlobal(name) {
        if (typeof this.globals[name] === "undefined") {
            throw new Error("global not found: " + name);
        }
        return this.globals[name];
    }
    addFilter(name, func, async) {
        var wrapped = func;
        if (async) {
            this.asyncFilters.push(name);
        }
        this.filters[name] = wrapped;
        return this;
    }
    getFilter(name) {
        if (!this.filters[name]) {
            throw new Error("filter not found: " + name);
        }
        return this.filters[name];
    }
    addTest(name, func) {
        this.tests[name] = func;
        return this;
    }
    getTest(name) {
        if (!this.tests[name]) {
            throw new Error("test not found: " + name);
        }
        return this.tests[name];
    }
    resolveTemplate(loader, parentName, filename) {
        var isRelative = loader.isRelative && parentName ? loader.isRelative(filename) : false;
        return isRelative && loader.resolve ? loader.resolve(parentName, filename) : filename;
    }
    getTemplate(name, eagerCompile, parentName, ignoreMissing, cb) {
        var that = this;
        var tmpl = null;
        if (name && name.raw) {
            name = name.raw;
        }
        if (isFunction(parentName)) {
            cb = parentName;
            parentName = null;
            eagerCompile = eagerCompile || false;
        }
        if (isFunction(eagerCompile)) {
            cb = eagerCompile;
            eagerCompile = false;
        }
        if (name instanceof Template) {
            tmpl = name;
        } else if (typeof name !== "string") {
            throw new Error("template names must be a string: " + name);
        } else {
            for(let i = 0; i < this.loaders.length; i++){
                const loader = this.loaders[i];
                tmpl = loader.cache[this.resolveTemplate(loader, parentName, name)];
                if (tmpl) {
                    break;
                }
            }
        }
        if (tmpl) {
            if (eagerCompile) {
                tmpl.compile();
            }
            if (cb) {
                cb(null, tmpl);
                return undefined;
            } else {
                return tmpl;
            }
        }
        let syncResult;
        const createTemplate = (err, info)=>{
            if (!info && !err && !ignoreMissing) {
                err = new Error("template not found: " + name);
            }
            if (err) {
                if (cb) {
                    cb(err);
                    return;
                } else {
                    throw err;
                }
            }
            let newTmpl;
            if (!info) {
                newTmpl = new Template(noopTmplSrc, this, "", eagerCompile);
            } else {
                newTmpl = new Template(info.src, this, info.path, eagerCompile);
                if (!info.noCache) {
                    info.loader.cache[name] = newTmpl;
                }
            }
            if (cb) {
                cb(null, newTmpl);
            } else {
                syncResult = newTmpl;
            }
        };
        asyncIter(this.loaders, (loader, i, next, done)=>{
            function handle(err, src) {
                if (err) {
                    done(err);
                } else if (src) {
                    src.loader = loader;
                    done(null, src);
                } else {
                    next();
                }
            }
            name = that.resolveTemplate(loader, parentName, name);
            if (loader.async) {
                loader.getSource(name, handle);
            } else {
                handle(null, loader.getSource(name));
            }
        }, createTemplate);
        return syncResult;
    }
    express(app) {
        return express(this, app);
    }
    render(name, ctx, cb) {
        if (isFunction(ctx)) {
            cb = ctx;
            ctx = null;
        }
        let syncResult = null;
        this.getTemplate(name, (err, tmpl)=>{
            if (err && cb) {
                callbackAsap(cb, err);
            } else if (err) {
                throw err;
            } else {
                syncResult = tmpl.render(ctx, cb);
            }
        });
        return syncResult;
    }
    renderString(src, ctx, opts, cb) {
        if (isFunction(opts)) {
            cb = opts;
            opts = {};
        }
        opts = opts || {};
        const tmpl = new Template(src, this, opts.path);
        return tmpl.render(ctx, cb);
    }
    waterfall(tasks, callback, forceAsync) {
        return __default1(tasks, callback, forceAsync);
    }
}
class Context extends Obj {
    init(ctx, blocks, env) {
        this.env = env || new Environment();
        this.ctx = extend({}, ctx);
        this.blocks = {};
        this.exported = [];
        keys_(blocks).forEach((name)=>{
            this.addBlock(name, blocks[name]);
        });
    }
    lookup(name) {
        if (name in this.env.globals && !(name in this.ctx)) {
            return this.env.globals[name];
        } else {
            return this.ctx[name];
        }
    }
    setVariable(name, val) {
        this.ctx[name] = val;
    }
    getVariables() {
        return this.ctx;
    }
    addBlock(name, block) {
        this.blocks[name] = this.blocks[name] || [];
        this.blocks[name].push(block);
        return this;
    }
    getBlock(name) {
        if (!this.blocks[name]) {
            throw new Error('unknown block "' + name + '"');
        }
        return this.blocks[name][0];
    }
    getSuper(env, name, block, frame, runtime, cb) {
        var idx = indexOf(this.blocks[name] || [], block);
        var blk = this.blocks[name][idx + 1];
        var context = this;
        if (idx === -1 || !blk) {
            throw new Error('no super block available for "' + name + '"');
        }
        blk(env, context, frame, runtime, cb);
    }
    addExport(name) {
        this.exported.push(name);
    }
    getExported() {
        var exported = {};
        this.exported.forEach((name)=>{
            exported[name] = this.ctx[name];
        });
        return exported;
    }
}
class Template extends Obj {
    init(src, env, path, eagerCompile) {
        this.env = env || new Environment();
        if (isObject1(src)) {
            switch(src.type){
                case "code":
                    this.tmplProps = src.obj;
                    break;
                case "string":
                    this.tmplStr = src.obj;
                    break;
                default:
                    throw new Error(`Unexpected template object type ${src.type}; expected 'code', or 'string'`);
            }
        } else if (isString(src)) {
            this.tmplStr = src;
        } else {
            throw new Error("src must be a string or an object describing the source");
        }
        this.path = path;
        if (eagerCompile) {
            try {
                this._compile();
            } catch (err) {
                throw _prettifyError(this.path, this.env.opts.dev, err);
            }
        } else {
            this.compiled = false;
        }
    }
    render(ctx, parentFrame, cb) {
        if (typeof ctx === "function") {
            cb = ctx;
            ctx = {};
        } else if (typeof parentFrame === "function") {
            cb = parentFrame;
            parentFrame = null;
        }
        const forceAsync = !parentFrame;
        try {
            this.compile();
        } catch (e) {
            const err = _prettifyError(this.path, this.env.opts.dev, e);
            if (cb) {
                return callbackAsap(cb, err);
            } else {
                throw err;
            }
        }
        const context = new Context(ctx || {}, this.blocks, this.env);
        const frame = parentFrame ? parentFrame.push(true) : new Frame1();
        frame.topLevel = true;
        let syncResult = null;
        let didError = false;
        this.rootRenderFunc(this.env, context, frame, mod8, (err, res)=>{
            if (didError && cb && typeof res !== "undefined") {
                return;
            }
            if (err) {
                err = _prettifyError(this.path, this.env.opts.dev, err);
                didError = true;
            }
            if (cb) {
                if (forceAsync) {
                    callbackAsap(cb, err, res);
                } else {
                    cb(err, res);
                }
            } else {
                if (err) {
                    throw err;
                }
                syncResult = res;
            }
        });
        return syncResult;
    }
    getExported(ctx, parentFrame, cb) {
        if (typeof ctx === "function") {
            cb = ctx;
            ctx = {};
        }
        if (typeof parentFrame === "function") {
            cb = parentFrame;
            parentFrame = null;
        }
        try {
            this.compile();
        } catch (e) {
            if (cb) {
                return cb(e);
            } else {
                throw e;
            }
        }
        const frame = parentFrame ? parentFrame.push() : new Frame1();
        frame.topLevel = true;
        const context = new Context(ctx || {}, this.blocks, this.env);
        this.rootRenderFunc(this.env, context, frame, mod8, (err)=>{
            if (err) {
                cb(err, null);
            } else {
                cb(null, context.getExported());
            }
        });
    }
    compile() {
        if (!this.compiled) {
            this._compile();
        }
    }
    _compile() {
        var props;
        if (this.tmplProps) {
            props = this.tmplProps;
        } else {
            const source = __default6.compile(this.tmplStr, this.env.asyncFilters, this.env.extensionsList, this.path, this.env.opts);
            const func = new Function(source);
            props = func();
        }
        this.blocks = this._getBlocks(props);
        this.rootRenderFunc = props.root;
        this.compiled = true;
    }
    _getBlocks(props) {
        var blocks = {};
        keys_(props).forEach((k)=>{
            if (k.slice(0, 2) === "b_") {
                blocks[k.slice(2)] = props[k];
            }
        });
        return blocks;
    }
}
function precompileGlobal(templates, opts) {
    var out = "";
    opts = opts || {};
    for(let i = 0; i < templates.length; i++){
        const name = JSON.stringify(templates[i].name);
        const template = templates[i].template;
        out += "(function() {" + "(window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})" + "[" + name + "] = (function() {\n" + template + "\n})();\n";
        if (opts.asFunction) {
            out += "return function(ctx, cb) { return nunjucks.render(" + name + ", ctx, cb); }\n";
        }
        out += "})();\n";
    }
    return out;
}
const readdirNamesSync = (p)=>Deno.readdirSync(p).map((q)=>q.name).sort();
function match(filename, patterns) {
    if (!Array.isArray(patterns)) {
        return false;
    }
    return patterns.some((pattern)=>filename.match(pattern));
}
function precompileString(str, opts) {
    opts = opts || {};
    opts.isString = true;
    const env = opts.env || new Environment([]);
    const wrapper = opts.wrapper || precompileGlobal;
    if (!opts.name) {
        throw new Error('the "name" option is required when compiling a string');
    }
    return wrapper([
        _precompile(str, opts.name, env)
    ], opts);
}
function precompile(input, opts) {
    opts = opts || {};
    const env = opts.env || new Environment([]);
    const wrapper = opts.wrapper || precompileGlobal;
    if (opts.isString) {
        return precompileString(input, opts);
    }
    const pathStats = existsSync(input) && Deno.statSync(input);
    const precompiled = [];
    const templates = [];
    function addTemplates(dir) {
        readdirNamesSync(dir).forEach((file)=>{
            const filepath = mod7.join(dir, file);
            let subpath = filepath.substr(mod7.join(input, "/").length);
            const stat = Deno.statSync(filepath);
            if (stat && stat.isDirectory()) {
                subpath += "/";
                if (!match(subpath, opts.exclude)) {
                    addTemplates(filepath);
                }
            } else if (match(subpath, opts.include)) {
                templates.push(filepath);
            }
        });
    }
    if (pathStats.isFile()) {
        precompiled.push(_precompile(Deno.readTextFileSync(input), opts.name || input, env));
    } else if (pathStats.isDirectory()) {
        addTemplates(input);
        for(let i = 0; i < templates.length; i++){
            const name = templates[i].replace(mod7.join(input, "/"), "");
            try {
                precompiled.push(_precompile(Deno.readTextFileSync(templates[i]), name, env));
            } catch (e) {
                if (opts.force) {
                    console.error(e);
                } else {
                    throw e;
                }
            }
        }
    }
    return wrapper(precompiled, opts);
}
function _precompile(str, name, env) {
    env = env || new Environment([]);
    const asyncFilters = env.asyncFilters;
    const extensions = env.extensionsList;
    let template;
    name = name.replace(/\\/g, "/");
    try {
        template = __default6.compile(str, asyncFilters, extensions, name, env.opts);
    } catch (err) {
        throw _prettifyError(name, false, err);
    }
    return {
        name: name,
        template: template
    };
}
const __default7 = {
    precompile: precompile,
    precompileString: precompileString
};
function installCompat() {
    var runtime = this.runtime;
    var lib = this.lib;
    var Compiler = this.compiler.Compiler;
    var Parser = this.parser.Parser;
    var nodes = this.nodes;
    var lexer = this.lexer;
    var orig_contextOrFrameLookup = runtime.contextOrFrameLookup;
    var orig_memberLookup = runtime.memberLookup;
    var orig_Compiler_assertType;
    var orig_Parser_parseAggregate;
    if (Compiler) {
        orig_Compiler_assertType = Compiler.prototype.assertType;
    }
    if (Parser) {
        orig_Parser_parseAggregate = Parser.prototype.parseAggregate;
    }
    function uninstall() {
        runtime.contextOrFrameLookup = orig_contextOrFrameLookup;
        runtime.memberLookup = orig_memberLookup;
        if (Compiler) {
            Compiler.prototype.assertType = orig_Compiler_assertType;
        }
        if (Parser) {
            Parser.prototype.parseAggregate = orig_Parser_parseAggregate;
        }
    }
    runtime.contextOrFrameLookup = function contextOrFrameLookup(context, frame, key) {
        var val = orig_contextOrFrameLookup.apply(this, arguments);
        if (val !== undefined) {
            return val;
        }
        switch(key){
            case "True":
                return true;
            case "False":
                return false;
            case "None":
                return null;
            default:
                return undefined;
        }
    };
    function getTokensState(tokens) {
        return {
            index: tokens.index,
            lineno: tokens.lineno,
            colno: tokens.colno
        };
    }
    if (process.env.BUILD_TYPE !== "SLIM" && nodes && Compiler && Parser) {
        const Slice = nodes.Node.extend("Slice", {
            fields: [
                "start",
                "stop",
                "step"
            ],
            init (lineno, colno, start, stop, step) {
                start = start || new nodes.Literal(lineno, colno, null);
                stop = stop || new nodes.Literal(lineno, colno, null);
                step = step || new nodes.Literal(lineno, colno, 1);
                this.parent(lineno, colno, start, stop, step);
            }
        });
        Compiler.prototype.assertType = function assertType(node) {
            if (node instanceof Slice) {
                return;
            }
            orig_Compiler_assertType.apply(this, arguments);
        };
        Compiler.prototype.compileSlice = function compileSlice(node, frame) {
            this._emit("(");
            this._compileExpression(node.start, frame);
            this._emit("),(");
            this._compileExpression(node.stop, frame);
            this._emit("),(");
            this._compileExpression(node.step, frame);
            this._emit(")");
        };
        Parser.prototype.parseAggregate = function parseAggregate() {
            var origState = getTokensState(this.tokens);
            origState.colno--;
            origState.index--;
            try {
                return orig_Parser_parseAggregate.apply(this);
            } catch (e) {
                const errState = getTokensState(this.tokens);
                const rethrow = ()=>{
                    lib._assign(this.tokens, errState);
                    return e;
                };
                lib._assign(this.tokens, origState);
                this.peeked = false;
                const tok = this.peekToken();
                if (tok.type !== lexer.TOKEN_LEFT_BRACKET) {
                    throw rethrow();
                } else {
                    this.nextToken();
                }
                const node = new Slice(tok.lineno, tok.colno);
                let isSlice = false;
                for(let i = 0; i <= node.fields.length; i++){
                    if (this.skip(lexer.TOKEN_RIGHT_BRACKET)) {
                        break;
                    }
                    if (i === node.fields.length) {
                        if (isSlice) {
                            this.fail("parseSlice: too many slice components", tok.lineno, tok.colno);
                        } else {
                            break;
                        }
                    }
                    if (this.skip(lexer.TOKEN_COLON)) {
                        isSlice = true;
                    } else {
                        const field = node.fields[i];
                        node[field] = this.parseExpression();
                        isSlice = this.skip(lexer.TOKEN_COLON) || isSlice;
                    }
                }
                if (!isSlice) {
                    throw rethrow();
                }
                return new nodes.Array(tok.lineno, tok.colno, [
                    node
                ]);
            }
        };
    }
    function sliceLookup(obj, start, stop, step) {
        obj = obj || [];
        if (start === null) {
            start = step < 0 ? obj.length - 1 : 0;
        }
        if (stop === null) {
            stop = step < 0 ? -1 : obj.length;
        } else if (stop < 0) {
            stop += obj.length;
        }
        if (start < 0) {
            start += obj.length;
        }
        const results = [];
        for(let i = start;; i += step){
            if (i < 0 || i > obj.length) {
                break;
            }
            if (step > 0 && i >= stop) {
                break;
            }
            if (step < 0 && i <= stop) {
                break;
            }
            results.push(runtime.memberLookup(obj, i));
        }
        return results;
    }
    function hasOwnProp(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
    }
    const ARRAY_MEMBERS = {
        pop (index) {
            if (index === undefined) {
                return this.pop();
            }
            if (index >= this.length || index < 0) {
                throw new Error("KeyError");
            }
            return this.splice(index, 1);
        },
        append (element) {
            return this.push(element);
        },
        remove (element) {
            for(let i = 0; i < this.length; i++){
                if (this[i] === element) {
                    return this.splice(i, 1);
                }
            }
            throw new Error("ValueError");
        },
        count (element) {
            var count = 0;
            for(let i = 0; i < this.length; i++){
                if (this[i] === element) {
                    count++;
                }
            }
            return count;
        },
        index (element) {
            var i;
            if ((i = this.indexOf(element)) === -1) {
                throw new Error("ValueError");
            }
            return i;
        },
        find (element) {
            return this.indexOf(element);
        },
        insert (index, elem) {
            return this.splice(index, 0, elem);
        }
    };
    const OBJECT_MEMBERS = {
        items () {
            return lib._entries(this);
        },
        values () {
            return lib._values(this);
        },
        keys () {
            return lib.keys(this);
        },
        get (key, def) {
            var output = this[key];
            if (output === undefined) {
                output = def;
            }
            return output;
        },
        has_key (key) {
            return hasOwnProp(this, key);
        },
        pop (key, def) {
            var output = this[key];
            if (output === undefined && def !== undefined) {
                output = def;
            } else if (output === undefined) {
                throw new Error("KeyError");
            } else {
                delete this[key];
            }
            return output;
        },
        popitem () {
            const keys = lib.keys(this);
            if (!keys.length) {
                throw new Error("KeyError");
            }
            const k = keys[0];
            const val = this[k];
            delete this[k];
            return [
                k,
                val
            ];
        },
        setdefault (key, def = null) {
            if (!(key in this)) {
                this[key] = def;
            }
            return this[key];
        },
        update (kwargs) {
            lib._assign(this, kwargs);
            return null;
        }
    };
    OBJECT_MEMBERS.iteritems = OBJECT_MEMBERS.items;
    OBJECT_MEMBERS.itervalues = OBJECT_MEMBERS.values;
    OBJECT_MEMBERS.iterkeys = OBJECT_MEMBERS.keys;
    runtime.memberLookup = function memberLookup(obj, val, autoescape) {
        if (arguments.length === 4) {
            return sliceLookup.apply(this, arguments);
        }
        obj = obj || {};
        if (lib.isArray(obj) && hasOwnProp(ARRAY_MEMBERS, val)) {
            return ARRAY_MEMBERS[val].bind(obj);
        }
        if (lib.isObject(obj) && hasOwnProp(OBJECT_MEMBERS, val)) {
            return OBJECT_MEMBERS[val].bind(obj);
        }
        return orig_memberLookup.apply(this, arguments);
    };
    return uninstall;
}
let e;
function configure(templatesPath, opts) {
    opts = opts || {};
    if (mod4.isObject(templatesPath)) {
        opts = templatesPath;
        templatesPath = null;
    }
    let TemplateLoader;
    if (FileSystemLoader) {
        TemplateLoader = new FileSystemLoader(templatesPath, {
            watch: opts.watch,
            noCache: opts.noCache
        });
    }
    e = new Environment(TemplateLoader, opts);
    if (opts && opts.express) {
        e.express(opts.express);
    }
    return e;
}
const __default8 = {
    Environment: Environment,
    Template: Template,
    Loader: Loader,
    FileSystemLoader: FileSystemLoader,
    NodeResolveLoader: NodeResolveLoader,
    PrecompiledLoader: PrecompiledLoader,
    compiler: __default6,
    parser: __default4,
    lexer: __default2,
    runtime: mod8,
    lib: mod4,
    nodes: __default3,
    installJinjaCompat: installCompat,
    configure: configure,
    reset () {
        e = undefined;
    },
    compile (src, env, path, eagerCompile) {
        if (!e) {
            configure();
        }
        return new Template(src, env, path, eagerCompile);
    },
    render (name, ctx, cb) {
        if (!e) {
            configure();
        }
        return e.render(name, ctx, cb);
    },
    renderString (src, ctx, cb) {
        if (!e) {
            configure();
        }
        return e.renderString(src, ctx, cb);
    },
    precompile: __default7 ? __default7.precompile : undefined,
    precompileString: __default7 ? __default7.precompileString : undefined
};
function verify(alg, key) {
    if (alg === "none") {
        if (key) throw new Error(`The alg '${alg}' does not allow a key.`);
        else return true;
    } else {
        if (!key) throw new Error(`The alg '${alg}' demands a key.`);
        const algorithm = getAlgorithm(alg);
        if (key.algorithm.name === algorithm.name) {
            if (key.algorithm.hash?.name && key.algorithm.hash?.name === algorithm.hash.name) {
                return true;
            }
        }
    }
    return false;
}
function getAlgorithm(alg) {
    switch(alg){
        case "HS256":
            return {
                hash: {
                    name: "SHA-256"
                },
                name: "HMAC"
            };
        case "HS384":
            return {
                hash: {
                    name: "SHA-384"
                },
                name: "HMAC"
            };
        case "HS512":
            return {
                hash: {
                    name: "SHA-512"
                },
                name: "HMAC"
            };
        case "PS256":
            return {
                hash: {
                    name: "SHA-256"
                },
                name: "RSA-PSS",
                saltLength: 256 >> 3
            };
        case "PS384":
            return {
                hash: {
                    name: "SHA-384"
                },
                name: "RSA-PSS",
                saltLength: 384 >> 3
            };
        case "PS512":
            return {
                hash: {
                    name: "SHA-512"
                },
                name: "RSA-PSS",
                saltLength: 512 >> 3
            };
        case "RS256":
            return {
                hash: {
                    name: "SHA-256"
                },
                name: "RSASSA-PKCS1-v1_5"
            };
        case "RS384":
            return {
                hash: {
                    name: "SHA-384"
                },
                name: "RSASSA-PKCS1-v1_5"
            };
        case "RS512":
            return {
                hash: {
                    name: "SHA-512"
                },
                name: "RSASSA-PKCS1-v1_5"
            };
        default:
            throw new Error(`The jwt's alg '${alg}' is not supported.`);
    }
}
const base64abc = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/"
];
function encode(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i;
    const l = uint8.length;
    for(i = 2; i < l; i += 3){
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 0x0f) << 2 | uint8[i] >> 6];
        result += base64abc[uint8[i] & 0x3f];
    }
    if (i === l + 1) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4];
        result += "==";
    }
    if (i === l) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
function decode(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        bytes[i] = binString.charCodeAt(i);
    }
    return bytes;
}
function addPaddingToBase64url(base64url) {
    if (base64url.length % 4 === 2) return base64url + "==";
    if (base64url.length % 4 === 3) return base64url + "=";
    if (base64url.length % 4 === 1) {
        throw new TypeError("Illegal base64url string!");
    }
    return base64url;
}
function convertBase64urlToBase64(b64url) {
    if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
        throw new TypeError("Failed to decode base64url: invalid character");
    }
    return addPaddingToBase64url(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url(b64) {
    return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode1(uint8) {
    return convertBase64ToBase64url(encode(uint8));
}
function decode1(b64url) {
    return decode(convertBase64urlToBase64(b64url));
}
const mod9 = {
    addPaddingToBase64url: addPaddingToBase64url,
    encode: encode1,
    decode: decode1
};
const encoder = new TextEncoder();
async function verify1(signature, key, alg, signingInput) {
    return key === null ? signature.length === 0 : await crypto.subtle.verify(getAlgorithm(alg), key, signature, encoder.encode(signingInput));
}
const decoder = new TextDecoder();
function isExpired(exp, leeway = 0) {
    return exp + leeway < Date.now() / 1000;
}
function isTooEarly(nbf, leeway = 0) {
    return nbf - leeway > Date.now() / 1000;
}
function isObject2(obj) {
    return obj !== null && typeof obj === "object" && Array.isArray(obj) === false;
}
function is3Tuple(arr) {
    return arr.length === 3;
}
function hasInvalidTimingClaims(...claimValues) {
    return claimValues.some((claimValue)=>claimValue !== undefined ? typeof claimValue !== "number" : false);
}
function decode2(jwt) {
    try {
        const arr = jwt.split(".").map(mod9.decode).map((uint8Array, index)=>{
            switch(index){
                case 0:
                case 1:
                    return JSON.parse(decoder.decode(uint8Array));
                case 2:
                    return uint8Array;
            }
        });
        if (is3Tuple(arr)) return arr;
        else throw new Error();
    } catch  {
        throw TypeError("The serialization of the jwt is invalid.");
    }
}
function validate1([header, payload, signature]) {
    if (typeof header?.alg !== "string") {
        throw new Error(`The header 'alg' parameter of the jwt must be a string.`);
    }
    if (isObject2(payload)) {
        if (hasInvalidTimingClaims(payload.exp, payload.nbf)) {
            throw new Error(`The jwt has an invalid 'exp' or 'nbf' claim.`);
        }
        if (typeof payload.exp === "number" && isExpired(payload.exp, 1)) {
            throw RangeError("The jwt is expired.");
        }
        if (typeof payload.nbf === "number" && isTooEarly(payload.nbf, 1)) {
            throw RangeError("The jwt is used too early.");
        }
        return {
            header,
            payload,
            signature
        };
    } else {
        throw new Error(`The jwt claims set is not a JSON object.`);
    }
}
async function verify2(jwt, key) {
    const { header , payload , signature  } = validate1(decode2(jwt));
    if (verify(header.alg, key)) {
        if (!await verify1(signature, key, header.alg, jwt.slice(0, jwt.lastIndexOf(".")))) {
            throw new Error("The jwt's signature does not match the verification signature.");
        }
        return payload;
    } else {
        throw new Error(`The jwt's alg '${header.alg}' does not match the key's algorithm.`);
    }
}
function createSigningInput(header, payload) {
    return `${mod9.encode(encoder.encode(JSON.stringify(header)))}.${mod9.encode(encoder.encode(JSON.stringify(payload)))}`;
}
async function create(alg, key, signingInput) {
    return key === null ? "" : mod9.encode(new Uint8Array(await crypto.subtle.sign(getAlgorithm(alg), key, encoder.encode(signingInput))));
}
async function create1(header, payload, key) {
    if (verify(header.alg, key)) {
        const signingInput = createSigningInput(header, payload);
        const signature = await create(header.alg, key, signingInput);
        return `${signingInput}.${signature}`;
    } else {
        throw new Error(`The jwt's alg '${header.alg}' does not match the key's algorithm.`);
    }
}
function getNumericDate(exp) {
    return Math.round((exp instanceof Date ? exp.getTime() : Date.now() + exp * 1000) / 1000);
}
const assignProperties = (schema, schema2)=>{
    const newSchema = {
        ...schema,
        properties: {
            ...schema.properties,
            ...schema2.properties
        }
    };
    if (schema2.required) {
        newSchema['required'] = [
            ...schema['required'] || [],
            ...schema2.required
        ];
    }
    if (schema2.definitions) {
        newSchema.definitions = Object.assign(newSchema.definitions || {}, schema2.definitions);
    }
    return newSchema;
};
async function exists(filePath) {
    try {
        await Deno.lstat(filePath);
        return true;
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            return false;
        }
        throw err;
    }
}
function existsSync1(filePath) {
    try {
        Deno.lstatSync(filePath);
        return true;
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            return false;
        }
        throw err;
    }
}
new Deno.errors.AlreadyExists("dest already exists.");
var EOL;
(function(EOL) {
    EOL["LF"] = "\n";
    EOL["CRLF"] = "\r\n";
})(EOL || (EOL = {}));
function fileToDataAdapter(fileAdapter) {
    return class FileAsDataAdapter extends fileAdapter {
        readKey = async (dataset, key)=>{
            const data = await this.read(pathCombine(dataset, key), [
                'json'
            ]);
            return data.ok ? await data.asJson() || {} : data.statusCode;
        };
        writeKey = (dataset, key, data)=>this.write(pathCombine(dataset, key), data, [
                'json'
            ]);
        deleteKey = (dataset, key)=>this.delete(pathCombine(dataset, key), [
                'json'
            ]);
        listDataset = async (dataset, _take = 1000, _skip = 0, getUpdateTime)=>{
            const msgBody = await this.readDirectory(dataset || '/', getUpdateTime);
            if (!msgBody.ok) {
                if (msgBody.statusCode === 404) {
                    return [];
                } else {
                    return msgBody.statusCode;
                }
            }
            const paths = await msgBody.asJson() || [];
            return paths;
        };
        deleteDataset = (dataset)=>this.deleteDirectory(dataset, '.schema.json');
        checkKey = (dataset, key)=>this.check(pathCombine(dataset, key), [
                'json'
            ]);
    };
}
function dataToSchemaAdapter(dataAdapter) {
    return class DataAsSchemaAdapter extends dataAdapter {
        checkSchema(dataset) {
            return this.checkKey(dataset, '.schema.json');
        }
        readSchema(dataset) {
            return this.readKey(dataset, '.schema.json');
        }
        writeSchema(dataset, schema) {
            return this.writeKey(dataset, '.schema.json', MessageBody.fromObject(schema));
        }
        instanceContentType(dataset, baseUrl) {
            const url = [
                baseUrl,
                dataset,
                '.schema.json'
            ].filter((s)=>s !== '').join('/');
            return Promise.resolve(`application/json; schema="${url}"`);
        }
    };
}
class LocalFileAdapterBase {
    rootPath;
    basePath;
    constructor(context, props){
        this.context = context;
        this.props = props;
        this.dirIter = async function*(dirPath, getUpdateTime) {
            yield '[';
            let first = true;
            for await (const entry of Deno.readDir(dirPath)){
                let updateStr = "";
                if (getUpdateTime) {
                    const stat = await Deno.stat(join3(dirPath, entry.name));
                    updateStr = stat.mtime ? "," + stat.mtime.getTime().toString() : "";
                }
                const listName = entry.name + (entry.isDirectory ? "/" : "");
                yield `${first ? '' : ','} [ "${listName}"${updateStr} ]`;
                first = false;
            }
            yield ']';
        };
        this.rootPath = props.rootPath.replace('${tenant}', context.tenant);
        this.basePath = props.basePath;
    }
    canonicalisePath(path) {
        return path.replace(/[\\:*"<>|]/g, '-');
    }
    decanonicalisePath(path) {
        return path;
    }
    getPathParts(reqPath, extensions, forDir, ensureDirExists) {
        reqPath = reqPath.split('?')[0];
        if (reqPath.endsWith('/')) forDir = true;
        let fullPath = this.basePath + '/' + decodeURI(slashTrim(reqPath));
        fullPath = fullPath.replace(/^\//, '').replace('//', '/');
        fullPath = this.canonicalisePath(fullPath);
        const pathParts = fullPath.split('/');
        if (ensureDirExists) ensureDir(join3(this.rootPath, ...pathParts.slice(0, -1)));
        let ext = '';
        if (!forDir) {
            const dotParts = pathParts[pathParts.length - 1].split('.');
            const pathExt = dotParts[dotParts.length - 1];
            extensions = extensions || [];
            if (extensions.length && (dotParts.length === 1 || !extensions.includes(pathExt))) {
                ext = extensions[0];
            } else if (dotParts.length > 1) {
                ext = dotParts.pop();
                pathParts[pathParts.length - 1] = dotParts.join('.');
            }
        }
        const filePath = join3(this.rootPath, ...pathParts);
        return [
            filePath,
            ext
        ];
    }
    getPath(reqPath, extensions, forDir, ensureDir) {
        const [filePath, ext] = this.getPathParts(reqPath, extensions, forDir, ensureDir);
        return filePath + (ext ? '.' + ext : '');
    }
    async read(readPath, extensions, startByte, endByte) {
        const filePath = this.getPath(readPath, extensions);
        let stream;
        try {
            stream = await readFileStream(filePath, startByte, endByte);
            return new MessageBody(stream, getType(filePath) || 'text/plain');
        } catch (err) {
            if (err instanceof Deno.errors.NotFound) return MessageBody.fromError(404);
            throw new Error(`LocalFileAdapter reading file: ${readPath}, ${err}`);
        }
    }
    async write(path, data, extensions) {
        let writeStream = null;
        try {
            writeStream = await writeFileStream(this.getPath(path, extensions, false, true));
            const readableStream = data.asReadable();
            if (readableStream === null) throw new Error('no data');
            await readableStream.pipeTo(writeStream);
            return 200;
        } catch (err) {
            return err instanceof Deno.errors.NotFound ? 404 : 500;
        }
    }
    async delete(path, extensions) {
        try {
            await Deno.remove(this.getPath(path, extensions));
        } catch (err) {
            return err instanceof Deno.errors.NotFound ? 404 : 500;
        }
        return 200;
    }
    dirIter;
    async readDirectory(readPath, getUpdateTime = false) {
        const filePath = this.getPath(readPath, undefined, true);
        let stat;
        try {
            stat = await Deno.stat(filePath);
        } catch (err) {
            return err instanceof Deno.errors.NotFound ? MessageBody.fromError(404) : MessageBody.fromError(500);
        }
        if (!stat.isDirectory) return MessageBody.fromError(400);
        const blockIter = toBlockChunks(this.dirIter(filePath, getUpdateTime || false));
        return new MessageBody(readableStreamFromIterable(blockIter), 'text/plain').setIsDirectory();
    }
    async deleteDirectory(path, deleteableFileSuffix = '') {
        const filePath = this.getPath(path, undefined, true);
        let stat;
        try {
            stat = await Deno.stat(filePath);
        } catch (err) {
            return err instanceof Deno.errors.NotFound ? 200 : 500;
        }
        if (!stat.isDirectory) return 400;
        for await (const entry of Deno.readDir(filePath)){
            if (entry.isDirectory || !(deleteableFileSuffix && entry.name.endsWith(deleteableFileSuffix))) {
                return 400;
            }
        }
        await Deno.remove(filePath, {
            recursive: true
        });
        return 200;
    }
    async check(path, extensions) {
        const filePath = this.getPath(path, extensions);
        let stat;
        try {
            stat = await Deno.stat(filePath);
        } catch  {
            return {
                status: 'none'
            };
        }
        const status = stat.isDirectory ? "directory" : "file";
        switch(status){
            case "directory":
                return {
                    status,
                    dateModified: stat.mtime
                };
            default:
                return {
                    status,
                    size: stat.size,
                    dateModified: stat.mtime
                };
        }
    }
    async move(fromPath, toPath, extensions) {
        const fromFullPath = this.getPath(fromPath);
        const toFullPath = this.getPath(toPath, extensions, false, true);
        try {
            await Deno.rename(fromFullPath, toFullPath);
        } catch (err) {
            return err instanceof Deno.errors.NotFound ? 404 : 500;
        }
        return 200;
    }
    context;
    props;
}
const __default9 = dataToSchemaAdapter(fileToDataAdapter(LocalFileAdapterBase));
const __default10 = {
    "name": "Local File Adapter",
    "description": "Reads and writes files on the file system local to the runtime",
    "moduleUrl": "./adapter/LocalFileAdapter.ts",
    "configSchema": {
        "type": "object",
        "properties": {
            "rootPath": {
                "type": "string",
                "description": "File path to root of all file storage"
            },
            "basePath": {
                "type": "string",
                "description": "Path below root path to storage for this service (generally unique)"
            }
        }
    },
    "adapterInterfaces": [
        "IFileAdapter",
        "IDataAdapter"
    ]
};
const $XML = Symbol("x/xml");
const schema = {
    comment: "#comment",
    text: "#text",
    attribute: {
        prefix: "@"
    },
    property: {
        prefix: "@"
    }
};
const SeekMode = Object.freeze({
    Current: Deno?.SeekMode?.Current ?? 0,
    Start: Deno?.SeekMode?.Start ?? 1,
    End: Deno?.SeekMode?.End ?? 2
});
const entities = {
    xml: {
        "&lt;": "<",
        "&gt;": ">",
        "&apos;": "'",
        "&quot;": '"',
        "&amp;": "&"
    },
    char: {
        "&": "&amp;",
        '"': "&quot;",
        "<": "&lt;",
        ">": "&gt;",
        "'": "&apos;"
    }
};
const tokens = {
    entity: {
        regex: {
            entities: /&#(?<hex>x?)(?<code>\d+);/g
        }
    },
    prolog: {
        start: "<?xml",
        end: "?>"
    },
    doctype: {
        start: "<!DOCTYPE",
        end: ">",
        elements: {
            start: "[",
            end: "]"
        },
        element: {
            start: "<!ELEMENT",
            end: ">",
            value: {
                start: "(",
                end: ")",
                regex: {
                    end: {
                        until: /\)/,
                        bytes: 1
                    }
                }
            }
        }
    },
    comment: {
        start: "<!--",
        end: "-->",
        regex: {
            end: {
                until: /(?<!-)-->/,
                bytes: 4,
                length: 3
            }
        }
    },
    cdata: {
        start: "<![CDATA[",
        end: "]]>",
        regex: {
            end: {
                until: /\]\]>/,
                bytes: 3
            }
        }
    },
    tag: {
        start: "<",
        end: ">",
        close: {
            start: "</",
            end: ">",
            self: "/",
            regex: {
                start: /<\//,
                end: /\/?>/
            }
        },
        attribute: {
            regex: {
                name: {
                    until: /=/,
                    bytes: 1
                }
            }
        },
        regex: {
            name: {
                until: /[\s\/>]/,
                bytes: 1
            },
            start: {
                until: /</,
                bytes: 1
            }
        }
    },
    text: {
        regex: {
            end: {
                until: /(<\/)|(<!)/,
                bytes: 2
            }
        }
    }
};
class Parser1 {
    constructor(stream, options = {}){
        this.#stream = stream;
        this.#options = options;
        this.#options.reviver ??= function({ value  }) {
            return value;
        };
    }
    parse() {
        return this.#document();
    }
    #options;
    #debug(path6, string2) {
        if (this.#options.debug) {
            console.debug(`${path6.map((node)=>node[$XML].name).join(" > ")} | ${string2}`.trim());
        }
    }
    #document() {
        const document = {};
        const path11 = [];
        const comments = [];
        let root = false;
        let clean;
        this.#trim();
        try {
            while(true){
                clean = true;
                if (this.#peek(tokens.comment.start)) {
                    clean = false;
                    comments.push(this.#comment({
                        path: path11
                    }));
                    continue;
                }
                if (this.#peek(tokens.prolog.start)) {
                    if (document.xml) {
                        throw new SyntaxError("Multiple prolog declaration found");
                    }
                    clean = false;
                    Object.assign(document, this.#prolog({
                        path: path11
                    }));
                    continue;
                }
                if (this.#peek(tokens.doctype.start)) {
                    if (document.doctype) {
                        throw new SyntaxError("Multiple doctype declaration found");
                    }
                    clean = false;
                    Object.assign(document, this.#doctype({
                        path: path11
                    }));
                    continue;
                }
                if (this.#peek(tokens.tag.start)) {
                    if (root) {
                        throw new SyntaxError("Multiple root elements found");
                    }
                    clean = false;
                    Object.assign(document, this.#node({
                        path: path11
                    }));
                    this.#trim();
                    root = true;
                    continue;
                }
            }
        } catch (error) {
            if (error instanceof Deno.errors.UnexpectedEof && clean) {
                if (comments.length) {
                    document[schema.comment] = comments;
                }
                return document;
            }
            throw error;
        }
    }
    #node({ path: path21  }) {
        if (this.#options.progress) {
            this.#options.progress(this.#stream.cursor);
        }
        if (this.#peek(tokens.comment.start)) {
            return {
                [schema.comment]: this.#comment({
                    path: path21
                })
            };
        }
        return this.#tag({
            path: path21
        });
    }
    #prolog({ path: path31  }) {
        this.#debug(path31, "parsing prolog");
        const prolog = this.#make.node({
            name: "xml",
            path: path31
        });
        this.#consume(tokens.prolog.start);
        while(!this.#peek(tokens.prolog.end)){
            Object.assign(prolog, this.#attribute({
                path: [
                    ...path31,
                    prolog
                ]
            }));
        }
        this.#consume(tokens.prolog.end);
        return {
            xml: prolog
        };
    }
    #doctype({ path: path41  }) {
        this.#debug(path41, "parsing doctype");
        const doctype = this.#make.node({
            name: "doctype",
            path: path41
        });
        Object.defineProperty(doctype, $XML, {
            enumerable: false,
            writable: true
        });
        this.#consume(tokens.doctype.start);
        while(!this.#peek(tokens.doctype.end)){
            if (this.#peek(tokens.doctype.elements.start)) {
                this.#consume(tokens.doctype.elements.start);
                while(!this.#peek(tokens.doctype.elements.end)){
                    Object.assign(doctype, this.#doctypeElement({
                        path: path41
                    }));
                }
                this.#consume(tokens.doctype.elements.end);
            } else {
                Object.assign(doctype, this.#property({
                    path: path41
                }));
            }
        }
        this.#stream.consume({
            content: tokens.doctype.end
        });
        return {
            doctype
        };
    }
    #doctypeElement({ path: path51  }) {
        this.#debug(path51, "parsing doctype element");
        this.#consume(tokens.doctype.element.start);
        const element = Object.keys(this.#property({
            path: path51
        })).shift().substring(schema.property.prefix.length);
        this.#debug(path51, `found doctype element "${element}"`);
        this.#consume(tokens.doctype.element.value.start);
        const value = this.#capture(tokens.doctype.element.value.regex.end);
        this.#consume(tokens.doctype.element.value.end);
        this.#debug(path51, `found doctype element value "${value}"`);
        this.#consume(tokens.doctype.element.end);
        return {
            [element]: value
        };
    }
    #tag({ path: path61  }) {
        this.#debug(path61, "parsing tag");
        const tag = this.#make.node({
            path: path61
        });
        this.#consume(tokens.tag.start);
        const name = this.#capture(tokens.tag.regex.name);
        Object.assign(tag[$XML], {
            name
        });
        this.#debug(path61, `found tag "${name}"`);
        while(!tokens.tag.close.regex.end.test(this.#stream.peek(2))){
            Object.assign(tag, this.#attribute({
                path: [
                    ...path61,
                    tag
                ]
            }));
        }
        const selfclosed = this.#peek(tokens.tag.close.self);
        if (selfclosed) {
            this.#debug(path61, `tag "${name}" is self-closed`);
            this.#consume(tokens.tag.close.self);
        }
        this.#consume(tokens.tag.end);
        if (!selfclosed) {
            if (this.#peek(tokens.cdata.start) || !this.#peek(tokens.tag.start)) {
                Object.assign(tag, this.#text({
                    close: name,
                    path: [
                        ...path61,
                        tag
                    ]
                }));
            } else {
                while(!tokens.tag.close.regex.start.test(this.#stream.peek(2))){
                    const child = this.#node({
                        path: [
                            ...path61,
                            tag
                        ]
                    });
                    const [key, value1] = Object.entries(child).shift();
                    if (Array.isArray(tag[key])) {
                        tag[key].push(value1);
                        this.#debug([
                            ...path61,
                            tag
                        ], `add new child "${key}" to array`);
                    } else if (key in tag) {
                        const array = [
                            tag[key],
                            value1
                        ];
                        Object.defineProperty(array, $XML, {
                            enumerable: false,
                            writable: true
                        });
                        if (tag[key]?.[$XML]) {
                            Object.assign(array, {
                                [$XML]: tag[key][$XML]
                            });
                        }
                        tag[key] = array;
                        this.#debug([
                            ...path61,
                            tag
                        ], `multiple children named "${key}", using array notation`);
                    } else {
                        Object.assign(tag, child);
                        this.#debug([
                            ...path61,
                            tag
                        ], `add new child "${key}"`);
                    }
                }
            }
            this.#consume(tokens.tag.close.start);
            this.#consume(name);
            this.#consume(tokens.tag.close.end);
            this.#debug(path61, `found closing tag for "${name}"`);
        }
        for (const [key1] of Object.entries(tag).filter(([_, value])=>typeof value === "undefined")){
            delete tag[key1];
        }
        if (!Object.keys(tag).includes(schema.text)) {
            const children = Object.keys(tag).filter((key)=>!key.startsWith(schema.attribute.prefix) && key !== schema.text);
            if (!children.length) {
                this.#debug(path61, `tag "${name}" has implictely obtained a text node as it has no children but has attributes`);
                tag[schema.text] = this.#revive({
                    key: schema.text,
                    value: "",
                    tag
                });
            }
        }
        if ((this.#options.flatten ?? true) && Object.keys(tag).includes(schema.text) && Object.keys(tag).length === 1) {
            this.#debug(path61, `tag "${name}" has been implicitely flattened as it only has a text node`);
            return {
                [name]: tag[schema.text]
            };
        }
        return {
            [name]: tag
        };
    }
    #attribute({ path: path7  }) {
        this.#debug(path7, "parsing attribute");
        const attribute = this.#capture(tokens.tag.attribute.regex.name);
        this.#debug(path7, `found attribute "${attribute}"`);
        this.#consume("=");
        const quote = this.#stream.peek();
        this.#consume(quote);
        const value2 = this.#capture({
            until: new RegExp(quote),
            bytes: quote.length
        });
        this.#consume(quote);
        this.#debug(path7, `found attribute value "${value2}"`);
        return {
            [`${schema.attribute.prefix}${attribute}`]: this.#revive({
                key: `${schema.attribute.prefix}${attribute}`,
                value: value2,
                tag: path7.at(-1)
            })
        };
    }
    #property({ path: path8  }) {
        this.#debug(path8, "parsing property");
        const quote1 = this.#stream.peek();
        const delimiter9 = /["']/.test(quote1) ? quote1 : " ";
        if (delimiter9.trim().length) {
            this.#consume(delimiter9);
        }
        const property = this.#capture({
            until: new RegExp(delimiter9),
            bytes: delimiter9.length
        });
        this.#debug(path8, `found property ${property}`);
        if (delimiter9.trim().length) {
            this.#consume(delimiter9);
        }
        return {
            [`${schema.property.prefix}${property}`]: true
        };
    }
    #text({ close , path: path9  }) {
        this.#debug(path9, "parsing text");
        const tag1 = this.#make.node({
            name: schema.text,
            path: path9
        });
        let text = "";
        const comments1 = [];
        while(this.#peek(tokens.cdata.start) || !this.#peeks([
            tokens.tag.close.start,
            close,
            tokens.tag.close.end
        ])){
            if (this.#peek(tokens.cdata.start)) {
                text += this.#cdata({
                    path: [
                        ...path9,
                        tag1
                    ]
                });
            } else if (this.#peek(tokens.comment.start)) {
                comments1.push(this.#comment({
                    path: [
                        ...path9,
                        tag1
                    ]
                }));
            } else {
                text += this.#capture(tokens.text.regex.end);
                if (this.#peek(tokens.cdata.start) || this.#peek(tokens.comment.start)) {
                    continue;
                }
                if (!this.#peeks([
                    tokens.tag.close.start,
                    close,
                    tokens.tag.close.end
                ])) {
                    text += tokens.tag.close.start;
                    this.#consume(tokens.tag.close.start);
                }
            }
        }
        this.#debug(path9, `parsed text "${text}"`);
        if (comments1.length) {
            this.#debug(path9, `parsed comments ${JSON.stringify(comments1)}`);
        }
        Object.assign(tag1, {
            [schema.text]: this.#revive({
                key: schema.text,
                value: text.trim(),
                tag: path9.at(-1)
            }),
            ...comments1.length ? {
                [schema.comment]: comments1
            } : {}
        });
        return tag1;
    }
    #cdata({ path: path10  }) {
        this.#debug(path10, "parsing cdata");
        this.#consume(tokens.cdata.start);
        const data = this.#capture(tokens.cdata.regex.end);
        this.#consume(tokens.cdata.end);
        return data;
    }
    #comment({ path: path111  }) {
        this.#debug(path111, "parsing comment");
        this.#consume(tokens.comment.start);
        const comment = this.#capture(tokens.comment.regex.end).trim();
        this.#consume(tokens.comment.end);
        return comment;
    }
    #revive({ key: key2 , value: value3 , tag: tag2  }) {
        return this.#options.reviver.call(tag2, {
            key: key2,
            tag: tag2[$XML].name,
            properties: !(key2.startsWith(schema.attribute.prefix) || key2.startsWith(schema.property.prefix)) ? {
                ...tag2
            } : null,
            value: (()=>{
                switch(true){
                    case (this.#options.emptyToNull ?? true) && /^\s*$/.test(value3):
                        return null;
                    case (this.#options.reviveBooleans ?? true) && /^(?:true|false)$/i.test(value3):
                        return /^true$/i.test(value3);
                    case this.#options.reviveNumbers ?? true:
                        {
                            const num = Number(value3);
                            if (Number.isFinite(num)) {
                                return num;
                            }
                        }
                    default:
                        value3 = value3.replace(tokens.entity.regex.entities, (_, hex, code)=>String.fromCharCode(parseInt(code, hex ? 16 : 10)));
                        for (const [entity, character] of Object.entries(entities.xml)){
                            value3 = value3.replaceAll(entity, character);
                        }
                        return value3;
                }
            })()
        });
    }
    #make = {
        node ({ name ="" , path =[]  }) {
            const node = {
                [$XML]: {
                    name,
                    parent: path[path.length - 1] ?? null
                }
            };
            Object.defineProperty(node, $XML, {
                enumerable: false,
                writable: true
            });
            return node;
        }
    };
    #stream;
    #peek(token1) {
        return this.#stream.peek(token1.length) === token1;
    }
    #peeks(tokens1) {
        let offset = 0;
        for(let i1 = 0; i1 < tokens1.length; i1++){
            const token11 = tokens1[i1];
            while(true){
                if (/\s/.test(this.#stream.peek(1, offset))) {
                    offset++;
                    continue;
                }
                if (this.#stream.peek(token11.length, offset) === token11) {
                    offset += token11.length;
                    break;
                }
                return false;
            }
        }
        return true;
    }
    #consume(token2) {
        return this.#stream.consume({
            content: token2
        });
    }
    #capture(token3) {
        return this.#stream.capture(token3);
    }
    #trim() {
        return this.#stream.trim();
    }
}
class Stream {
    constructor(content){
        this.#content = content;
    }
    #decoder = new TextDecoder();
    #encoder = new TextEncoder();
    #content;
    get cursor() {
        return this.#content.seekSync(0, SeekMode.Current);
    }
    peek(bytes = 1, offset = 0) {
        const buffer = new Uint8Array(bytes);
        const cursor = this.cursor;
        if (offset) {
            this.#content.seekSync(offset, SeekMode.Current);
        }
        if (this.#content.readSync(buffer)) {
            this.#content.seekSync(cursor, SeekMode.Start);
            return this.#decoder.decode(buffer);
        }
        throw new Deno.errors.UnexpectedEof();
    }
    read(bytes = 1) {
        const buffer = new Uint8Array(bytes);
        if (this.#content.readSync(buffer)) {
            return buffer;
        }
        throw new Deno.errors.UnexpectedEof();
    }
    capture({ until , bytes , trim =true , length =bytes  }) {
        if (trim) {
            this.trim();
        }
        const buffer = [];
        while(!until.test(this.peek(bytes))){
            buffer.push(this.read(1)[0]);
        }
        if (bytes !== length) {
            buffer.push(...this.read(bytes - length));
        }
        if (trim) {
            this.trim();
        }
        return this.#decoder.decode(Uint8Array.from(buffer));
    }
    consume({ content , trim =true  }) {
        if (trim) {
            this.trim();
        }
        const bytes = this.#encoder.encode(content).length;
        if (content === this.peek(bytes)) {
            this.read(bytes);
            if (trim) {
                this.trim();
            }
            return;
        }
        throw new SyntaxError(`Expected next sequence to be "${content}", got "${this.peek(bytes)}" instead`);
    }
    trim() {
        try {
            while(/\s/.test(this.peek())){
                this.read(1);
            }
        } catch (error) {
            if (error instanceof Deno.errors.UnexpectedEof) {
                return;
            }
            throw error;
        }
    }
}
class Streamable {
    constructor(string){
        this.#buffer = new TextEncoder().encode(string);
    }
    #buffer;
    #cursor = 0;
    readSync(buffer) {
        const bytes = this.#buffer.slice(this.#cursor, this.#cursor + buffer.length);
        buffer.set(bytes);
        this.#cursor = Math.min(this.#cursor + bytes.length, this.#buffer.length);
        return bytes.length || null;
    }
    seekSync(offset, whence) {
        switch(whence){
            case SeekMode.Start:
                this.#cursor = offset;
                break;
            case SeekMode.Current:
                this.#cursor += offset;
                break;
            case SeekMode.End:
                this.#cursor = this.#buffer.length + offset;
                break;
        }
        return this.#cursor;
    }
}
function parse9(content, options) {
    if (typeof content === "string") {
        content = new Streamable(content);
    }
    return new Parser1(new Stream(content), options).parse();
}
class S3FileAdapterBase {
    basePath;
    bucketName;
    aws4ProxyAdapter;
    constructor(context, props){
        this.context = context;
        this.props = props;
        this.aws4ProxyAdapter = null;
        this.basePath = props.rootPath;
        this.bucketName = props.bucketName;
    }
    async ensureProxyAdapter() {
        if (this.aws4ProxyAdapter === null) {
            this.aws4ProxyAdapter = await this.context.getAdapter("./adapter/AWS4ProxyAdapter.ts", {
                service: "s3",
                region: this.props.region,
                secretAccessKey: this.props.secretAccessKey,
                accessKeyId: this.props.accessKeyId,
                urlPattern: `https://${this.bucketName}.s3.amazonaws.com/$P*`,
                ec2IamRole: this.props.ec2IamRole
            });
        }
    }
    async processForAws(msg) {
        await this.ensureProxyAdapter();
        msg.startSpan(this.context.traceparent, this.context.tracestate);
        const msgOut = await this.aws4ProxyAdapter.buildMessage(msg);
        return msgOut;
    }
    canonicalisePath(path) {
        return path.replace(/[^0-9a-zA-Z!_.*'()/-]/g, (match)=>match === '~' ? '%7E' : encodeURIComponent(match));
    }
    queryCanonicalisePath(path) {
        return path;
    }
    decanonicalisePath(path) {
        return decodeURIComponent(path.replace('%7E', '~'));
    }
    getPathParts(reqPath, extensions, forDir, forQuery) {
        reqPath = reqPath.split('?')[0];
        let fullPath = pathCombine(this.basePath, decodeURI(reqPath));
        if (fullPath.startsWith('/')) fullPath = fullPath.substr(1);
        if (fullPath.endsWith('/')) {
            forDir = true;
            fullPath = fullPath.slice(0, -1);
        }
        const transPath = forQuery ? this.queryCanonicalisePath(fullPath) : this.canonicalisePath(fullPath);
        const pathParts = transPath.split('/');
        if (this.props.tenantDirectories) pathParts.unshift(this.context.tenant);
        let ext = '';
        if (!forDir) {
            const dotParts = last(pathParts).split('.');
            extensions = extensions || [];
            if (extensions.length && (dotParts.length === 1 || extensions.indexOf(last(dotParts)) < 0)) {
                ext = extensions[0];
            } else if (dotParts.length > 1) {
                ext = dotParts.pop();
                pathParts[pathParts.length - 1] = dotParts.join('.');
            }
        }
        let filePath = pathParts.join('/');
        if (filePath === '.') filePath = '';
        return [
            filePath,
            ext
        ];
    }
    getPath(reqPath, extensions, forDir, forQuery) {
        const [filePath, ext] = this.getPathParts(reqPath, extensions, forDir, forQuery);
        return filePath + (ext ? '.' + ext : '');
    }
    async read(readPath, extensions, startByte, endByte) {
        const getParams = {
            bucket: this.bucketName,
            key: this.getPath(readPath, extensions)
        };
        const s3Msg = new Message(getParams.key, this.context.tenant, "GET", null);
        if (startByte || endByte) {
            const range = `bytes=${startByte ?? ''}-${endByte ?? ''}`;
            s3Msg.setHeader('Range', range);
        }
        const msgSend = await this.processForAws(s3Msg);
        const msgOut = await this.context.makeRequest(msgSend);
        msgOut.data.statusCode = msgOut.status;
        return msgOut.data;
    }
    async write(path, data, extensions) {
        const key = this.getPath(path, extensions);
        const s3Msg = new Message(key, this.context.tenant, "PUT", null);
        s3Msg.data = data;
        this.context.logger.info(`AWS S3 write start ${path} at ${new Date().getTime()}`);
        await s3Msg.data.ensureDataIsArrayBuffer();
        const msgSend = await this.processForAws(s3Msg);
        try {
            this.context.logger.info(`AWS S3 begin request ${path} at ${new Date().getTime()}`);
            const msgOut = await this.context.makeRequest(msgSend);
            if (!msgOut.ok) {
                this.context.logger.error('AWS S3 write error: ' + await msgOut.data?.asString());
            }
            if (msgOut.data) await msgOut.data.ensureDataIsArrayBuffer();
            this.context.logger.info(`AWS S3 write done ${path} at ${new Date().getTime()}`);
            return msgOut.status || 500;
        } catch (err) {
            this.context.logger.error(err);
            return 500;
        }
    }
    async delete(path, extensions) {
        const deleteParams = {
            bucket: this.bucketName,
            key: this.getPath(path, extensions)
        };
        const metadata = await this.check(path, extensions);
        if (metadata.status === "none") return 404;
        const s3Msg = new Message(deleteParams.key, this.context.tenant, "DELETE", null);
        const msgSend = await this.processForAws(s3Msg);
        try {
            const msgOut = await this.context.makeRequest(msgSend);
            if (msgOut.data) await msgOut.data.ensureDataIsArrayBuffer();
            return msgOut.ok ? 200 : msgOut.status;
        } catch (err) {
            console.log(err);
            return 500;
        }
    }
    async *listPrefixed(filePath, maxKeys) {
        const url = new Url("/?list-type=2");
        if (maxKeys) url.query['max-keys'] = [
            maxKeys.toString()
        ];
        if (filePath && filePath !== '/') url.query['prefix'] = [
            filePath
        ];
        try {
            url.query["delimiter"] = [
                "/"
            ];
            const s3Msg = new Message(url, this.context.tenant, "GET", null);
            const sendMsg = await this.processForAws(s3Msg);
            const msgOut = await this.context.makeRequest(sendMsg);
            if (!msgOut.ok) this.context.logger.error(await msgOut.data.asString());
            const status = msgOut.status;
            if (status && status !== 200) return status;
            const text = await msgOut.data.asString();
            const output = parse9(text);
            const contents = (output?.['ListBucketResult'])?.['Contents'];
            for (const item of arrayify(contents)){
                yield {
                    key: this.decanonicalisePath(item.Key || ''),
                    name: this.decanonicalisePath(last((item.Key || '').split('/'))),
                    lastModified: new Date(item.LastModified),
                    size: item.Size
                };
            }
            const commonPrefixes = (output?.['ListBucketResult'])?.['CommonPrefixes'];
            for (const item1 of arrayify(commonPrefixes)){
                yield {
                    key: this.decanonicalisePath(item1.Prefix || ''),
                    name: this.decanonicalisePath((item1.Prefix || '').split('/').slice(-2, -1)[0] + '/'),
                    lastModified: undefined,
                    size: undefined
                };
            }
        } catch (err) {
            this.context.logger.error(err);
            return 500;
        }
    }
    async *jsonStreamPrefixed(filePath, maxKeys) {
        yield '[';
        let first = true;
        for await (const item of this.listPrefixed(filePath, maxKeys)){
            let modifiedStr = '';
            if (item.name.endsWith('/') && item.lastModified) {
                modifiedStr = "," + item.lastModified.getTime().toString();
            }
            yield `${first ? '' : ','} [ "${item.name}"${modifiedStr} ]`;
            first = false;
        }
        yield ']';
    }
    readDirectory(readPath, _getUpdateTime = false) {
        let filePath = this.getPath(readPath, undefined, true, true) + '/';
        const blockIter = toBlockChunks(this.jsonStreamPrefixed(filePath));
        return Promise.resolve(new MessageBody(readableStreamFromIterable(blockIter), 'text/plain').setIsDirectory());
    }
    async deleteDirectory(path, deleteableFileSuffix = '') {
        const filePath = this.getPath(path, undefined, true);
        const files = this.listPrefixed(filePath);
        let file = await files.next();
        if (file.done) return 200;
        if (deleteableFileSuffix !== '*') {
            while(!file.done){
                if (file.value.name.includes('/') || !(deleteableFileSuffix && file.value.name.endsWith(deleteableFileSuffix))) return 400;
                file = await files.next();
            }
        }
        return 200;
    }
    async check(path, extensions) {
        const fullPath = this.getPath(path, extensions, undefined, true);
        const files = this.listPrefixed(fullPath, 1);
        const file = await files.next();
        const item = file.done ? null : file.value;
        const deFullPath = this.decanonicalisePath(fullPath);
        let status = "none";
        if (item != null) {
            if (item.key === deFullPath) {
                status = "file";
            } else if (path.endsWith('/') && item.key !== deFullPath || deFullPath + '/' === item.key) {
                status = "directory";
            } else {
                this.context.logger.info(`AWS S3 list found ${path} wrong key ${item.key} at ${new Date().getTime()}`);
                status = "none";
            }
        } else {
            this.context.logger.info(`AWS S3 list can't find ${path} at ${new Date().getTime()}`);
            return {
                status: "none"
            };
        }
        switch(status){
            case "none":
                return {
                    status
                };
            case "directory":
                return {
                    status,
                    dateModified: item.lastModified
                };
            case "file":
                return {
                    status,
                    size: item.size,
                    dateModified: item.lastModified
                };
        }
    }
    context;
    props;
}
const __default11 = dataToSchemaAdapter(fileToDataAdapter(S3FileAdapterBase));
const __default12 = {
    "name": "S3 File Adapter",
    "description": "Reads and writes files on the AWS S3",
    "moduleUrl": "./adapter/S3FileAdapter.ts",
    "configSchema": {
        "type": "object",
        "properties": {
            "rootPath": {
                "type": "string"
            },
            "bucketName": {
                "type": "string"
            },
            "region": {
                "type": "string"
            },
            "tenantDirectories": {
                "type": "boolean"
            },
            "secretAccessKey": {
                "type": "string"
            },
            "ec2IamRole": {
                "type": "string",
                "description": "If running on EC2 with an associated IAM role, this can be provided instead of account keys"
            },
            "accessKeyId": {
                "type": "string"
            }
        },
        "required": [
            "rootPath",
            "bucketName",
            "region"
        ]
    },
    "adapterInterfaces": [
        "IFileAdapter",
        "IDataAdapter"
    ]
};
const __default13 = {
    "name": "Nunjucks Template Adapter",
    "description": "Supplies Nunjucks template processing",
    "moduleUrl": "./adapter/NunjucksTemplateAdapter.ts",
    "adapterInterfaces": [
        "ITemplateAdapter"
    ]
};
class SimpleProxyAdapter {
    urlPattern;
    constructor(context, props){
        this.context = context;
        this.props = props;
        this.urlPattern = props.urlPattern;
    }
    buildMessage(msg) {
        return Promise.resolve(msg.setUrl(resolvePathPatternWithUrl(this.urlPattern, msg.url, msg.data)));
    }
    context;
    props;
}
const __default14 = {
    "name": "Simple Proxy Adapter",
    "description": "Forwards a request to a configured path pattern without adding headers",
    "moduleUrl": "./adapter/SimpleProxyAdapter.ts",
    "configSchema": {
        "type": "object",
        "properties": {
            "urlPattern": {
                "type": "string",
                "description": "Url pattern where to send request"
            }
        },
        "required": [
            "urlPattern"
        ]
    },
    "adapterInterfaces": [
        "IProxyAdapter"
    ]
};
const ANY_BUT_DIGITS = /[^\d]/g;
const ANY_BUT_DIGITS_T = /[^\dT]/g;
const toAmz = (date)=>{
    return `${date.toISOString().slice(0, 19).replace(ANY_BUT_DIGITS_T, "")}Z`;
};
const toDateStamp = (date)=>{
    return date.toISOString().slice(0, 10).replace(ANY_BUT_DIGITS, "");
};
function hex(data) {
    return [
        ...data
    ].map((b)=>b.toString(16).padStart(2, "0")).join("");
}
async function sha256Hex(data) {
    if (typeof data === "string") {
        data = new TextEncoder().encode(data);
    }
    const hash = await crypto.subtle.digest("SHA-256", data);
    return hex(new Uint8Array(hash));
}
async function hmacSha256(keyData, data) {
    if (typeof keyData === "string") {
        keyData = new TextEncoder().encode(keyData);
    }
    const key = await crypto.subtle.importKey("raw", keyData, {
        name: "HMAC",
        hash: "SHA-256"
    }, false, [
        "sign"
    ]);
    const mac = await crypto.subtle.sign({
        name: "HMAC",
        hash: "SHA-256"
    }, key, new TextEncoder().encode(data));
    return new Uint8Array(mac);
}
const AWS4 = new TextEncoder().encode("AWS4");
async function signAwsV4(key, msg) {
    const hash = await hmacSha256(key, msg);
    return hex(hash);
}
async function getSignatureKey(key, dateStamp, region, service) {
    if (typeof key === "string") {
        key = new TextEncoder().encode(key);
    }
    const paddedKey = new Uint8Array(4 + key.byteLength);
    paddedKey.set(AWS4, 0);
    paddedKey.set(key, 4);
    let mac = await hmacSha256(paddedKey, dateStamp);
    mac = await hmacSha256(mac, region);
    mac = await hmacSha256(mac, service);
    mac = await hmacSha256(mac, "aws4_request");
    return new Uint8Array(mac);
}
class AWSSignerV4 {
    region;
    credentials;
    constructor(region, credentials){
        this.region = region || this.#getDefaultRegion();
        this.credentials = credentials || this.#getDefaultCredentials();
    }
    hexEncode = (c)=>`%${c.charCodeAt(0).toString(16).toUpperCase()}`;
    escapeUri = (uri)=>encodeURIComponent(decodeURIComponent(uri)).replace(/[!'()*]/g, this.hexEncode);
    async sign(service, request) {
        const date = new Date();
        const amzdate = toAmz(date);
        const datestamp = toDateStamp(date);
        const parseUrl = /^((https?:\/\/)([^?#\/]+)|\/)?([^?#]*)(\?[^#]*)?(#.*)?$/;
        const parsed = parseUrl.exec(request.url);
        if (!parsed) throw new Error("Bad url format");
        const host = parsed[3];
        const pathname = parsed[4];
        let query = parsed[5];
        query = query ? query.substring(1) : '';
        const params = query.split('&').map((s)=>s.split("="));
        params.sort((a, b)=>a.join() === b.join() ? 0 : a.join() > b.join() ? 1 : -1);
        const canonicalQuerystring = params.map(([k, v])=>this.escapeUri(k) + (v ? `=${this.escapeUri(v)}` : '')).join('&');
        const headers = new Headers(request.headers);
        headers.set("x-amz-date", amzdate);
        if (this.credentials.sessionToken) {
            headers.set("x-amz-security-token", this.credentials.sessionToken);
        }
        headers.set("host", host);
        const proxyChangeableHeaders = [
            'x-forwarded-for',
            'via',
            'user-agent',
            'accept',
            'accept-charset',
            'accept-encoding',
            'accept-language'
        ];
        proxyChangeableHeaders.forEach((key)=>headers.delete(key));
        let canonicalHeaders = "";
        let signedHeaders = "";
        for (const key of [
            ...headers.keys()
        ].sort()){
            canonicalHeaders += `${key.toLowerCase()}:${headers.get(key)}\n`;
            signedHeaders += `${key.toLowerCase()};`;
        }
        signedHeaders = signedHeaders.substring(0, signedHeaders.length - 1);
        const body = request.body ? new Uint8Array(await request.arrayBuffer()) : null;
        const payloadHash = await sha256Hex(body ?? new Uint8Array(0));
        const { awsAccessKeyId , awsSecretKey  } = this.credentials;
        const canonicalRequest = `${request.method}\n${pathname}\n${canonicalQuerystring}\n${canonicalHeaders}\n${signedHeaders}\n${payloadHash}`;
        const canonicalRequestDigest = await sha256Hex(canonicalRequest);
        const algorithm = "AWS4-HMAC-SHA256";
        const credentialScope = `${datestamp}/${this.region}/${service}/aws4_request`;
        const stringToSign = `${algorithm}\n${amzdate}\n${credentialScope}\n${canonicalRequestDigest}`;
        const signingKey = await getSignatureKey(awsSecretKey, datestamp, this.region, service);
        const signature = await signAwsV4(signingKey, stringToSign);
        const authHeader = `${algorithm} Credential=${awsAccessKeyId}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signature}`;
        headers.set("Authorization", authHeader);
        headers.set("x-amz-content-sha256", payloadHash);
        return new Request(request.url, {
            headers,
            method: request.method,
            body,
            redirect: request.redirect
        });
    }
    #getDefaultCredentials = ()=>{
        const AWS_ACCESS_KEY_ID = Deno.env.get("AWS_ACCESS_KEY_ID");
        const AWS_SECRET_ACCESS_KEY = Deno.env.get("AWS_SECRET_ACCESS_KEY");
        const AWS_SESSION_TOKEN = Deno.env.get("AWS_SESSION_TOKEN");
        if (!AWS_ACCESS_KEY_ID || !AWS_SECRET_ACCESS_KEY) {
            throw new Error("Invalid Credentials");
        }
        return {
            awsAccessKeyId: AWS_ACCESS_KEY_ID,
            awsSecretKey: AWS_SECRET_ACCESS_KEY,
            sessionToken: AWS_SESSION_TOKEN
        };
    };
    #getDefaultRegion = ()=>{
        const AWS_REGION = Deno.env.get("AWS_REGION");
        if (!AWS_REGION) {
            throw new Error("Invalid Region");
        }
        return AWS_REGION;
    };
}
class AWS4ProxyAdapter {
    tempKeysValiditySecs;
    expiration;
    signer;
    sessionToken;
    setSigner(accessKeyId, secretAccessKey) {
        this.signer = new AWSSignerV4(this.props.region, {
            awsAccessKeyId: accessKeyId,
            awsSecretKey: secretAccessKey
        });
    }
    constructor(context, props){
        this.context = context;
        this.props = props;
        this.tempKeysValiditySecs = 21600;
        if (!(props.accessKeyId && props.secretAccessKey) && !props.ec2IamRole) {
            throw new Error('Must supply access keys or an EC2 IAM role');
        }
        const { accessKeyId , secretAccessKey  } = props;
        if (accessKeyId && secretAccessKey) {
            this.setSigner(accessKeyId, secretAccessKey);
        }
    }
    async getEc2TempKeys() {
        try {
            const tokenResp = await fetch("http://169.254.169.254/latest/api/token", {
                method: "PUT",
                headers: {
                    "X-aws-ec2-metadata-token-ttl-seconds": this.tempKeysValiditySecs.toString()
                }
            });
            if (!tokenResp.ok) throw new Error(`Request failed status ${tokenResp.status} ${tokenResp.statusText}`);
            const token = await tokenResp.text();
            const keysResp = await fetch(`http://169.254.169.254/latest/meta-data/iam/security-credentials/${this.props.ec2IamRole}`, {
                headers: {
                    "X-aws-ec2-metadata-token": token
                }
            });
            const keys = await keysResp.json();
            const { AccessKeyId: accessKeyId , SecretAccessKey: secretAccessKey , Token: sessionToken  } = keys;
            this.setSigner(accessKeyId, secretAccessKey);
            this.expiration = new Date(keys.expiration);
            this.sessionToken = sessionToken;
        } catch (err) {
            this.context.logger.error(`Failed to get £C2 temp keys: ${err}`);
        }
    }
    async buildMessage(msg) {
        msg.setUrl(resolvePathPatternWithUrl(this.props.urlPattern, msg.url, msg.data));
        if (!(this.props.accessKeyId && this.props.secretAccessKey) || this.expiration && new Date() > this.expiration) {
            await this.getEc2TempKeys();
        }
        if (this.sessionToken) msg.setHeader("X-Amz-Security-Token", this.sessionToken);
        const req = await this.signer.sign(this.props.service, msg.toRequest());
        const msgOut = Message.fromRequest(req, msg.tenant);
        return msgOut;
    }
    context;
    props;
}
const __default15 = {
    "name": "AWS 4 Proxy Adapter",
    "description": "Forwards a request to a configured path pattern after signing using AWS-4 signature",
    "moduleUrl": "./adapter/AWS4ProxyAdapter.ts",
    "configSchema": {
        "type": "object",
        "properties": {
            "service": {
                "type": "string",
                "description": "AWS service e.g. s3"
            },
            "region": {
                "type": "string",
                "description": "AWS region e.g. eu-west-1"
            },
            "secretAccessKey": {
                "type": "string",
                "description": "AWS account keys, secret"
            },
            "accessKeyId": {
                "type": "string",
                "description": "AWS account keys, public access"
            },
            "ec2IamRole": {
                "type": "string",
                "description": "If running on EC2 with an associated IAM role, this can be provided instead of account keys"
            },
            "urlPattern": {
                "type": "string",
                "description": "AWS endpoint url pattern"
            }
        },
        "required": [
            "urlPattern"
        ]
    },
    "adapterInterfaces": [
        "IProxyAdapter"
    ]
};
class ElasticProxyAdapter {
    constructor(context, props){
        this.context = context;
        this.props = props;
        if (!props.host) {
            throw new Error('Must supply host for Elastic');
        }
    }
    buildMessage(msg) {
        if (this.props.username && this.props.password) {
            const token = btoa(`${this.props.username}:${this.props.password}`);
            msg.setHeader('Authorization', `Basic ${token}`);
        }
        const newUrl = msg.url.copy();
        const hostUrl = new Url(this.props.host);
        newUrl.domain = hostUrl.domain;
        newUrl.scheme = hostUrl.scheme;
        return Promise.resolve(msg.setUrl(newUrl));
    }
    context;
    props;
}
const __default16 = {
    "name": "Elasticsearch Proxy Adapter",
    "description": "Forwards a request to a configured elasticsearch node using provided user and password",
    "moduleUrl": "./adapter/ElasticProxyAdapter.ts",
    "configSchema": {
        "type": "object",
        "properties": {
            "username": {
                "type": "string",
                "description": "Elastic account username"
            },
            "password": {
                "type": "string",
                "description": "Elastic account password"
            },
            "host": {
                "type": "string",
                "description": "Elastic node host (starting http:// or https://)"
            }
        },
        "required": [
            "host"
        ]
    },
    "adapterInterfaces": [
        "IProxyAdapter"
    ]
};
const schemaToMapping = (schema)=>{
    let submapping = {};
    const esProps = [
        'type',
        'fields',
        'index',
        'index_options',
        'index_prefixes',
        'index_phrases',
        'norms',
        'store',
        'search_analyzer',
        'search_quote_analyzer',
        'similarity',
        'term_vector',
        'doc_values',
        'eager_global_ordinals',
        'ignore_above',
        'null_value',
        'normalizer',
        'split_queries_on_whitespace',
        'time_series_dimension',
        'coerce',
        'ignore_malformed',
        'scaling_factor',
        'format',
        'locale',
        'dynamic',
        'enabled',
        'subobjects',
        'depth_limit',
        'include_in_parent',
        'include_in_root',
        'metrics',
        'default_metric',
        'fielddata',
        'fielddata_frequency_filter',
        'position_increment_gap',
        'preserve_separators',
        'preserve_position_increments',
        'max_input_length',
        'max_shingle_size',
        'dims',
        'ignore_z_value',
        'orientation'
    ];
    switch(schema.type){
        case "string":
            {
                submapping = schema.search === 'textual' ? {
                    type: "text"
                } : [
                    'date',
                    'date-time'
                ].includes(schema.format || 'zzz') ? {
                    type: "date"
                } : {
                    type: "keyword"
                };
                [
                    'fields',
                    'index',
                    'index_options',
                    'index_prefixes',
                    'index_phrases',
                    'norms',
                    'store',
                    'search_analyzer',
                    'search_quote_analyzer',
                    'similarity',
                    'term_vector'
                ].forEach((k)=>{
                    if (schema['es_' + k]) {
                        submapping[k] = schema['es_' + k];
                    }
                });
                break;
            }
        case "number":
            submapping = {
                type: "double"
            };
            break;
        case "boolean":
            submapping = {
                type: "boolean"
            };
            break;
        case "object":
            submapping = {
                properties: Object.fromEntries(Object.entries(schema.properties).map(([k, subschema])=>[
                        k,
                        schemaToMapping(subschema)
                    ]))
            };
            break;
        case "array":
            if (schema.items.type !== "object") {
                submapping = schemaToMapping(schema.items);
            } else {
                submapping = {
                    type: "nested",
                    properties: Object.fromEntries(Object.entries(schema.items.properties).map(([k, subschema])=>[
                            k,
                            schemaToMapping(subschema)
                        ]))
                };
            }
    }
    Object.keys(schema).filter((k)=>k.startsWith('es_')).forEach((k)=>{
        const esKey = k.substring(3);
        if (esProps.includes(esKey)) submapping[esKey] = schema[k];
    });
    return submapping;
};
class ElasticDataAdapter {
    elasticProxyAdapter;
    schemasIndexChecked;
    defaultWriteDelayMs;
    constructor(context, props){
        this.context = context;
        this.props = props;
        this.elasticProxyAdapter = null;
        this.schemasIndexChecked = false;
        this.defaultWriteDelayMs = 1500;
    }
    waitForWrite() {
        return new Promise((res)=>setInterval(()=>res(), this.props.writeDelayMs || this.defaultWriteDelayMs));
    }
    normaliseIndexName(s) {
        if (s === '.' || s === '..') throw new Error('Elastic does not allow index names . or ..');
        return s.toLowerCase().replace(/[\\/*?"<>| ,#]/g, '').replace(/$[-_+]/, '').slice(0, 255);
    }
    async ensureProxyAdapter() {
        if (this.elasticProxyAdapter === null) {
            this.elasticProxyAdapter = await this.context.getAdapter("./adapter/ElasticProxyAdapter.ts", {
                username: this.props.username,
                password: this.props.password,
                host: this.props.host
            });
        }
    }
    async requestElastic(msg) {
        msg.startSpan(this.context.traceparent, this.context.tracestate);
        await this.ensureProxyAdapter();
        const sendMsg = await this.elasticProxyAdapter.buildMessage(msg);
        return await this.context.makeRequest(sendMsg);
    }
    async readKey(dataset, key) {
        dataset = this.normaliseIndexName(dataset);
        const msg = new Message(`/${dataset}/_source/${key}`, this.context.tenant, "GET", null);
        const msgOut = await this.requestElastic(msg);
        if (!msgOut.ok) {
            return msgOut.status;
        } else {
            const data = await msgOut.data?.asJson();
            return data;
        }
    }
    async listDataset(dataset, take = 1000, skip = 0) {
        if (dataset === '') {
            const msg = new Message("/_aliases", this.context.tenant, "GET", null);
            const msgOut = await this.requestElastic(msg);
            if (!msgOut.ok) {
                return msgOut.status;
            } else {
                const data = await msgOut.data?.asJson();
                const listing = Object.keys(data).filter((k)=>k !== "_schemas").map((k)=>[
                        k + '/'
                    ]);
                return listing;
            }
        } else {
            dataset = this.normaliseIndexName(dataset);
            const msg1 = new Message(`/${dataset}/_search`, this.context.tenant, "POST", null);
            msg1.setDataJson({
                size: take,
                from: skip,
                query: {
                    match_all: {}
                },
                fields: [
                    "_id",
                    "_timestamp"
                ],
                "_source": false
            });
            const msgOut1 = await this.requestElastic(msg1);
            if (msgOut1.status === 404) {
                return [];
            } else if (!msgOut1.ok) {
                return msgOut1.status;
            } else {
                const data1 = await msgOut1.data?.asJson();
                const listing1 = data1.hits.hits.map((h)=>h.fields._timestamp ? [
                        h._id,
                        h.fields._timestamp
                    ] : [
                        h._id
                    ]);
                listing1.push([
                    '.schema.json'
                ]);
                return listing1;
            }
        }
    }
    async writeKey(dataset, key, data) {
        dataset = this.normaliseIndexName(dataset);
        const msg = new Message(`/${dataset}/_doc/${key}`, this.context.tenant, "PUT", null);
        const writeData = await data.asJson();
        writeData._timestamp = new Date().getTime();
        msg.setDataJson(writeData);
        const msgOut = await this.requestElastic(msg);
        if (!msgOut.ok) {
            return msgOut.status;
        } else {
            const data1 = await msgOut.data?.asJson();
            await this.waitForWrite();
            return data1.result === "created" ? 201 : 200;
        }
    }
    async deleteKey(dataset, key) {
        dataset = this.normaliseIndexName(dataset);
        const msg = new Message(`/${dataset}/_doc/${key}`, this.context.tenant, "DELETE", null);
        const msgOut = await this.requestElastic(msg);
        await this.waitForWrite();
        return msgOut.status;
    }
    async deleteDataset(dataset) {
        dataset = this.normaliseIndexName(dataset);
        const msg = new Message(`/${dataset}`, this.context.tenant, "DELETE", null);
        const msgOut = await this.requestElastic(msg);
        await this.waitForWrite();
        return msgOut.status;
    }
    async checkKey(dataset, key) {
        dataset = this.normaliseIndexName(dataset);
        const msg = new Message(`/${dataset}/_doc/${key}`, this.context.tenant, "GET", null);
        const msgOut = await this.requestElastic(msg);
        let status = "none";
        if (!msgOut.ok) {
            return {
                status
            };
        } else {
            const data = await msgOut.data?.asJson();
            if (!data.found) {
                return {
                    status
                };
            }
            status = "file";
            return {
                status,
                dateModified: new Date(data._source._timestamp),
                size: JSON.stringify(data._source).length
            };
        }
    }
    async ensureSchemasIndex() {
        if (!this.schemasIndexChecked) {
            const msg = new Message(`/.schemas`, this.context.tenant, "GET", null);
            const msgCheck = await this.requestElastic(msg);
            if (!msgCheck.ok) {
                const createMappingMsg = new Message('/.schemas', this.context.tenant, "PUT", null);
                createMappingMsg.setDataJson({
                    settings: {
                        index: {
                            hidden: true
                        }
                    }
                });
                const msgCreated = await this.requestElastic(createMappingMsg);
                if (!msgCreated.ok) {
                    this.context.logger.error(`Failed to create .schemas index on ${this.props.host}, request status ${msgCreated.status}`);
                }
            }
            this.schemasIndexChecked = true;
        }
    }
    async writeSchema(dataset, schema) {
        dataset = this.normaliseIndexName(dataset);
        const params = {
            mappings: schemaToMapping(schema)
        };
        if (schema['es_settings']) {
            params.es_settings = schema['es_settings'];
        }
        const msg = new Message(`/${dataset}`, this.context.tenant, "GET", null);
        const msgCheck = await this.requestElastic(msg);
        const setMappingMsg = new Message(`/${dataset}/_mapping`, this.context.tenant, "PUT", null);
        let resCode = 200;
        setMappingMsg.setDataJson(params.mappings);
        if (!msgCheck.ok) {
            setMappingMsg.setUrl(`/${dataset}`).setMethod("PUT");
            setMappingMsg.setDataJson(params);
            resCode = 201;
        }
        const msgOut = await this.requestElastic(setMappingMsg);
        if (!msgOut.ok) {
            return msgOut.status;
        }
        await this.ensureSchemasIndex();
        const storeRes = await this.writeKey('.schemas', dataset, MessageBody.fromObject({
            schema: JSON.stringify(schema)
        }));
        if (storeRes >= 300) {
            return storeRes;
        }
        return resCode;
    }
    async readSchema(dataset) {
        dataset = this.normaliseIndexName(dataset);
        const schemaStore = await this.readKey('.schemas', dataset);
        if (typeof schemaStore === 'number') return schemaStore;
        return JSON.parse(schemaStore.schema);
    }
    async checkSchema(dataset) {
        dataset = this.normaliseIndexName(dataset);
        return await this.checkKey('.schemas', dataset);
    }
    instanceContentType(dataset, baseUrl) {
        const url = [
            baseUrl,
            dataset,
            '.schema.json'
        ].filter((s)=>s !== '').join('/');
        return Promise.resolve(`application/json; schema="${url}"`);
    }
    context;
    props;
}
const __default17 = {
    "name": "Elasticsearch Data Adapter",
    "description": "Reads and writes data to Elasticsearch",
    "moduleUrl": "./adapter/ElasticDataAdapter.ts",
    "configSchema": {
        "type": "object",
        "properties": {
            "username": {
                "type": "string"
            },
            "password": {
                "type": "string"
            },
            "host": {
                "type": "string",
                "description": "Elastic node host (starting http:// or https://)"
            },
            "writeDelayMs": {
                "type": "number"
            }
        },
        "required": [
            "host"
        ]
    },
    "adapterInterfaces": [
        "IDataAdapter"
    ]
};
class ElasticQueryAdapter {
    elasticProxyAdapter;
    constructor(context, props){
        this.context = context;
        this.props = props;
        this.elasticProxyAdapter = null;
    }
    async ensureProxyAdapter() {
        if (this.elasticProxyAdapter === null) {
            this.elasticProxyAdapter = await this.context.getAdapter("./adapter/ElasticProxyAdapter.ts", {
                username: this.props.username,
                password: this.props.password,
                host: this.props.host
            });
        }
    }
    async requestElastic(msg) {
        await this.ensureProxyAdapter();
        const sendMsg = await this.elasticProxyAdapter.buildMessage(msg);
        return await this.context.makeRequest(sendMsg);
    }
    async runQuery(query, take = 1000, skip = 0) {
        await this.ensureProxyAdapter();
        let index = '';
        let queryObj = {};
        try {
            queryObj = JSON.parse(query);
        } catch  {
            return 400;
        }
        if (queryObj.index) {
            index = '/' + queryObj.index;
            delete queryObj.index;
        }
        queryObj.size = take;
        queryObj.from = skip;
        const msg = new Message(index + '/_search', this.context.tenant, "POST", null);
        msg.startSpan(this.context.traceparent, this.context.tracestate);
        msg.setDataJson(queryObj);
        const res = await this.requestElastic(msg);
        if (!res.ok) {
            const report = await res.data?.asString();
            throw new Error(`Elastic adapter error, query: ${report}`);
        }
        const data = await res.data?.asJson();
        return data.hits.hits;
    }
    quote(x) {
        if (typeof x === "string") {
            return "\"" + x.replace("\"", "\\\"") + "\"";
        } else if (typeof x !== "object") {
            return JSON.stringify(x);
        } else if (Array.isArray(x)) {
            return JSON.stringify(x.filter((item)=>typeof item !== "object"));
        } else {
            return new Error('query variable must be a primitive, or an array of primitives');
        }
    }
    context;
    props;
}
const __default18 = {
    "name": "Elasticsearch Query Adapter",
    "description": "Stores and runs Elasticsearch queries",
    "moduleUrl": "./adapter/ElasticQueryAdapter.ts",
    "configSchema": {
        "type": "object",
        "properties": {
            "username": {
                "type": "string"
            },
            "password": {
                "type": "string"
            },
            "host": {
                "type": "string",
                "description": "Elastic node host (starting http:// or https://)"
            }
        },
        "required": [
            "host"
        ]
    },
    "adapterInterfaces": [
        "IQueryAdapter"
    ]
};
class LogLine {
    constructor(line){
        this.line = line;
    }
    get tenant() {
        return this.line.substring(81, this.line.indexOf(' ', 81));
    }
    line;
}
class FileLogReaderAdapter {
    logPath;
    blockSize;
    constructor(context, props){
        this.context = context;
        this.props = props;
        this.blockSize = 1024;
        this.logPath = props.logPath;
    }
    async *scanBack(count) {
        const stat = await Deno.stat(this.logPath);
        const fileLen = stat.size;
        const file = await Deno.open(this.logPath, {
            read: true
        });
        const decoder = new TextDecoder();
        const blockSize = stat.blksize || this.blockSize;
        const buf = new Uint8Array(blockSize);
        let toRead = fileLen % blockSize;
        let blocks = Math.floor(fileLen / blockSize) + 1;
        if (toRead === 0) {
            toRead = blockSize;
            blocks--;
        }
        file.seek((blocks - 1) * blockSize, Deno.SeekMode.Start);
        let overflow = '';
        while(count > 0 && blocks > 0){
            let nRead = await file.read(buf);
            while(nRead < toRead){
                const nThisRead = await file.read(buf.subarray(nRead));
                if (nThisRead == 0) yield "file.read === 0";
                if (!nThisRead) break;
                nRead += nThisRead;
            }
            const str = decoder.decode(buf.subarray(0, nRead));
            let idx = str.length - 1;
            while(idx > 0 && count > 0){
                const newIdx = str.lastIndexOf("\n", idx);
                if (newIdx > 0) {
                    const line = new LogLine(str.substring(newIdx + 1, idx + 1) + overflow);
                    if (line.tenant === this.context.tenant) {
                        yield line.line;
                        count--;
                    }
                    overflow = '';
                } else {
                    overflow = str.substring(0, idx + 1);
                    blocks--;
                    if (blocks > 0) file.seek((blocks - 1) * blockSize, Deno.SeekMode.Start);
                    toRead = blockSize;
                }
                idx = newIdx - 1;
            }
        }
        if (overflow.length && count > 0) {
            const line1 = new LogLine(overflow);
            if (line1.tenant === this.context.tenant) {
                yield overflow;
            }
        }
    }
    async tail(nLines) {
        const lines = [];
        for await (const line of this.scanBack(nLines)){
            lines.unshift(line);
        }
        return lines;
    }
    async search(maxLines, search) {
        const lines = [];
        for await (const line of this.scanBack(maxLines)){
            if (line.includes(search)) {
                lines.unshift(line);
            }
        }
        return lines;
    }
    context;
    props;
}
const __default19 = {
    "name": "Local File Log Reader Adapter",
    "description": "Scans a log file on the local file system",
    "moduleUrl": "./adapter/FileLogReaderAdapter.ts",
    "configSchema": {
        "type": "object",
        "properties": {
            "logPath": {
                "type": "string",
                "description": "Full system file path to log file"
            }
        }
    },
    "adapterInterfaces": [
        "ILogReaderAdapter"
    ]
};
const __default20 = {
    "name": "Services Service",
    "description": "Provides discovery of configured services and service catalogue",
    "moduleUrl": "./services/services.ts",
    "apis": [
        "services"
    ]
};
const __default21 = {
    "name": "Authentication Service",
    "description": "Provides simple JWT authentication",
    "moduleUrl": "./services/auth.ts",
    "apis": [
        "auth"
    ],
    "configSchema": {
        "type": "object",
        "properties": {
            "userUrlPattern": {
                "type": "string",
                "description": "Url pattern to fetch user data"
            },
            "loginPage": {
                "type": "string",
                "description": "Login page url for redirect management"
            },
            "sessionTimeoutMins": {
                "type": "number",
                "description": "How long before a new login is required in minutes"
            }
        },
        "required": [
            "userUrlPattern"
        ]
    }
};
const service = new Service();
const isSchema = (adapter)=>adapter.checkSchema !== undefined;
const isWriteSchema = (adapter)=>adapter.writeSchema !== undefined;
const normaliseKey = (key)=>{
    if (key.endsWith('.json')) return key.slice(0, -5);
    return key;
};
service.get(async (msg, { adapter  })=>{
    if (msg.url.servicePathElements.length !== 2) {
        return msg.setStatus(400, 'Data GET request should have a service path like <dataset>/<key>');
    }
    let [dataset, key] = msg.url.servicePathElements;
    key = normaliseKey(key);
    if (isSchema(adapter) && key.endsWith('.schema')) {
        const schema = await adapter.readSchema(dataset);
        if (typeof schema === 'number') {
            return msg.setStatus(schema);
        } else {
            const outMsg = msg.setDataJson(schema);
            outMsg.data.mimeType = 'application/schema+json';
            return outMsg;
        }
    }
    const details = await adapter.checkKey(dataset, key);
    if (details.status === "none") {
        msg.data = undefined;
        return msg.setStatus(404, 'Not found');
    }
    if (msg.method !== 'HEAD') {
        const val = await adapter.readKey(dataset, key);
        msg.data = MessageBody.fromObject(val);
        msg.data.dateModified = details.dateModified;
    }
    if (isSchema(adapter) && msg.data) {
        msg.data.mimeType = await adapter.instanceContentType(dataset, msg.url.baseUrl());
    }
    return msg;
});
service.getDirectory(async (msg, { adapter  })=>{
    if (msg.url.servicePathElements.length > 1) {
        return msg.setStatus(400, 'Data GET directory request should be like <dataset>/ or just /');
    }
    const pathEls = msg.url.servicePathElements;
    const dataset = pathEls.length ? pathEls[0] : '';
    const paths = await adapter.listDataset(dataset);
    if (typeof paths === 'number') return msg.setStatus(paths);
    let DirState;
    (function(DirState) {
        DirState[DirState["topLevelNoCreate"] = 0] = "topLevelNoCreate";
        DirState[DirState["topLevelCreateDirs"] = 1] = "topLevelCreateDirs";
        DirState[DirState["mustCreateSchema"] = 2] = "mustCreateSchema";
        DirState[DirState["createJson"] = 3] = "createJson";
        DirState[DirState["createInstance"] = 4] = "createInstance";
    })(DirState || (DirState = {}));
    let dirState;
    if (dataset === '') {
        dirState = isWriteSchema(adapter) ? DirState.topLevelCreateDirs : DirState.topLevelNoCreate;
    } else {
        if (isSchema(adapter)) {
            dirState = paths.some(([filename])=>filename === '.schema.json') ? DirState.createInstance : DirState.mustCreateSchema;
        } else {
            dirState = DirState.createJson;
        }
    }
    const spec = {
        pattern: "store",
        storeMimeTypes: [],
        createDirectory: false,
        createFiles: true
    };
    switch(dirState){
        case DirState.createInstance:
            {
                const instanceMimeType = await adapter.instanceContentType(dataset, msg.url.baseUrl());
                spec.storeMimeTypes = [
                    instanceMimeType
                ];
                spec.exceptionMimeTypes = {
                    ".schema.json": [
                        'application/schema+json',
                        'application/schema+json'
                    ]
                };
                break;
            }
        case DirState.createJson:
            spec.storeMimeTypes = [
                'application/json'
            ];
            break;
        case DirState.mustCreateSchema:
            spec.exceptionMimeTypes = {
                ".schema.json": [
                    'application/schema+json',
                    'application/schema+json'
                ]
            };
            spec.createFiles = false;
            break;
        case DirState.topLevelNoCreate:
            break;
        case DirState.topLevelCreateDirs:
            spec.createDirectory = true;
            spec.createFiles = false;
            break;
    }
    const dirDesc = {
        path: msg.url.servicePath,
        paths,
        spec
    };
    return msg.setDirectoryJson(dirDesc);
});
const write1 = async (msg, adapter, logger, isPatch)=>{
    if (msg.url.servicePathElements.length !== 2) {
        return msg.setStatus(400, 'Data write request should have a service path like <dataset>/<key>');
    }
    if (!msg.hasData()) return msg.setStatus(400, "No data to write");
    let [dataset, key] = msg.url.servicePathElements;
    key = normaliseKey(key);
    if (isWriteSchema(adapter) && key.endsWith('.schema')) {
        const schemaDetails = await adapter.checkSchema(dataset);
        const res = await adapter.writeSchema(dataset, await msg.data.asJson());
        msg.data.mimeType = 'application/json-schema';
        if (msg.method === "PUT") msg.data = undefined;
        return msg.setStatus(res === 200 && schemaDetails.status === 'none' ? 201 : res);
    } else {
        const details = await adapter.checkKey(dataset, key);
        const isDirectory = details.status === "directory" || details.status === "none" && msg.url.isDirectory;
        if (isDirectory) {
            msg.data = undefined;
            return msg.setStatus(403, "Forbidden: can't overwrite directory");
        }
        let resCode = 0;
        logger.info(`isPatch: ${isPatch || msg.url.fragment}`);
        if (isPatch || msg.url.fragment) {
            let val = await adapter.readKey(dataset, key);
            if (typeof val === 'number') {
                if (val === 404) {
                    val = {};
                } else {
                    return msg.setStatus(val, 'Was reading full value to write back fragment');
                }
            }
            const d = await msg.data?.asJson();
            logger.info(`patch data ${JSON.stringify(d)}`);
            if (isPatch) {
                val = patch(val, d);
                logger.info(`patch result ${JSON.stringify(val)}`);
            } else {
                setProp(val, msg.url.fragment, d);
            }
            resCode = await adapter.writeKey(dataset, key, MessageBody.fromObject(val));
        } else {
            resCode = await adapter.writeKey(dataset, key, msg.data.copy());
        }
        msg.data = undefined;
        if (resCode !== 200) return msg.setStatus(resCode);
        return msg.setDateModified(details.dateModified).setHeader('Location', msg.url.toString()).setStatus(details.status === "none" ? 201 : 200, details.status === "none" ? "Created" : "OK");
    }
};
service.post((msg, { adapter , logger  })=>write1(msg, adapter, logger, false));
service.put((msg, { adapter , logger  })=>write1(msg, adapter, logger, false));
service.patch((msg, { adapter , logger  })=>write1(msg, adapter, logger, true));
service.delete(async (msg, { adapter  })=>{
    if (msg.url.servicePathElements.length !== 2) {
        return msg.setStatus(400, 'Data DELETE request should have a service path like <dataset>/<key> or <dataset>');
    }
    let [dataset, key] = msg.url.servicePathElements;
    key = normaliseKey(key);
    let res = 0;
    if (msg.url.fragment) {
        const val = await adapter.readKey(dataset, key);
        if (typeof val === 'number') {
            return msg.setStatus(val, 'Was reading full value to write back fragment');
        }
        try {
            deleteProp(val, msg.url.fragment);
        } catch  {
            return msg.setStatus(400, 'Cannot delete this fragment path');
        }
        res = await adapter.writeKey(dataset, key, MessageBody.fromObject(val));
    } else {
        res = await adapter.deleteKey(dataset, key);
    }
    if (res === 404) {
        return msg.setStatus(404, 'Not found');
    } else if (res === 500) {
        return msg.setStatus(500, 'Internal server error');
    } else {
        return msg.setStatus(200);
    }
});
service.deleteDirectory(async (msg, { adapter  })=>{
    if (msg.url.servicePathElements.length !== 1) {
        return msg.setStatus(400, 'Data DELETE request should have a service path like <dataset>/<key> or <dataset>');
    }
    const [dataset] = msg.url.servicePathElements;
    try {
        const status = await adapter.deleteDataset(dataset);
        if (status === 400) {
            return msg.setStatus(400, 'Not empty');
        } else if (status === 404) {
            return msg.setStatus(404, 'Not found');
        } else if (status === 500) {
            return msg.setStatus(500, 'Internal server error');
        }
    } catch  {
        return msg.setStatus(500, 'Internal server error');
    }
    return msg;
});
const __default22 = {
    "name": "Data Service",
    "description": "Reads and writes data from urls with the pattern datasource/key",
    "moduleUrl": "./services/data.ts",
    "apis": [
        "store",
        "data.base"
    ],
    "adapterInterface": "IDataAdapter",
    "configSchema": {
        "type": "object",
        "properties": {
            "uploadBaseUrl": {
                "type": "string",
                "description": "The url to a file store for uploading associated files"
            }
        }
    },
    "defaults": {
        "basePath": "/data"
    },
    "exposedConfigProperties": [
        "uploadBaseUrl"
    ]
};
const service1 = new Service();
const isSchema1 = (adapter)=>adapter.checkSchema !== undefined;
const isWriteSchema1 = (adapter)=>adapter.writeSchema !== undefined;
const normaliseKey1 = (key)=>{
    if (key.endsWith('.json')) return key.slice(0, -5);
    return key;
};
function configSchemaInstanceContentType(dataset, baseUrl) {
    const url = `${baseUrl}/.schema.json`;
    return Promise.resolve(`application/json; schema="${url}"`);
}
service1.get(async (msg, { adapter  }, config)=>{
    if (msg.url.servicePathElements.length !== 1) {
        return msg.setStatus(400, 'Dataset GET request should have a service path like <key>');
    }
    let [key] = msg.url.servicePathElements;
    key = normaliseKey1(key);
    let schema = undefined;
    if (isSchema1(adapter) && !config.schema && key.endsWith('.schema')) {
        const schemaOut = await adapter.readSchema('');
        if (typeof schemaOut === 'number') {
            return msg.setStatus(schemaOut);
        } else {
            schema = schemaOut;
        }
    } else if (key.endsWith('.schema')) {
        schema = config.schema;
    }
    if (schema) {
        const msgOut = msg.setDataJson(schema);
        msgOut.data.setMimeType('application/schema+json');
        return msgOut;
    }
    const details = await adapter.checkKey('', key);
    if (details.status === "none") {
        msg.data = undefined;
        return msg.setStatus(404, 'Not found');
    }
    if (msg.method !== 'HEAD') {
        const val = await adapter.readKey('', key);
        msg.data = MessageBody.fromObject(val);
        msg.data.dateModified = details.dateModified;
    }
    let getInstanceContentType = configSchemaInstanceContentType;
    if (isSchema1(adapter) && !config.schema) {
        getInstanceContentType = adapter.instanceContentType;
    }
    msg.data.mimeType = await getInstanceContentType('', msg.url.baseUrl());
    return msg;
});
service1.getDirectory(async (msg, { adapter  }, config)=>{
    if (msg.url.servicePathElements.length !== 0) {
        return msg.setStatus(400, 'Dataset GET directory request should have no service path');
    }
    let DirState;
    (function(DirState) {
        DirState[DirState["mustCreateSchema"] = 0] = "mustCreateSchema";
        DirState[DirState["createInstanceAdapterSchema"] = 1] = "createInstanceAdapterSchema";
        DirState[DirState["createInstanceConfigSchema"] = 2] = "createInstanceConfigSchema";
    })(DirState || (DirState = {}));
    const paths = await adapter.listDataset('');
    if (typeof paths === 'number') return msg.setStatus(paths);
    let dirState;
    const schemaExists = paths.some(([f])=>f === '.schema.json');
    if (isSchema1(adapter) && !config.schema) {
        dirState = isWriteSchema1(adapter) && !schemaExists ? DirState.mustCreateSchema : DirState.createInstanceAdapterSchema;
    } else {
        dirState = DirState.createInstanceConfigSchema;
    }
    const spec = {
        pattern: "store",
        storeMimeTypes: [],
        createDirectory: false,
        createFiles: true
    };
    switch(dirState){
        case DirState.mustCreateSchema:
            spec.exceptionMimeTypes = {
                "/.schema.json": [
                    'application/schema+json',
                    'application/schema+json'
                ]
            };
            spec.createFiles = false;
            break;
        case DirState.createInstanceConfigSchema:
            spec.exceptionMimeTypes = {
                "/.schema.json": [
                    'application/schema+json',
                    ''
                ]
            };
            spec.storeMimeTypes = [
                await configSchemaInstanceContentType('', msg.url.baseUrl())
            ];
            break;
        case DirState.createInstanceAdapterSchema:
            spec.storeMimeTypes = [
                await adapter.instanceContentType('', msg.url.baseUrl())
            ];
            if (config.schema) {
                spec.exceptionMimeTypes = {
                    "/.schema.json": [
                        'application/schema+json',
                        ''
                    ]
                };
            }
            break;
    }
    const dirDesc = {
        path: msg.url.servicePath,
        paths,
        spec
    };
    msg.data = MessageBody.fromObject(dirDesc).setIsDirectory();
    return msg;
});
const write2 = async (msg, adapter, config)=>{
    if (msg.url.servicePathElements.length !== 1) {
        return msg.setStatus(400, 'Dataset write request should have a service path like <key>');
    }
    if (!msg.data) return msg.setStatus(400, "No data to write");
    let [key] = msg.url.servicePathElements;
    key = normaliseKey1(key);
    if (isWriteSchema1(adapter) && key.endsWith('.schema')) {
        if (config.schema) return msg.setStatus(400, "Can't write fixed schema");
        const schemaDetails = await adapter.checkSchema('');
        const res = await adapter.writeSchema('', await msg.data.asJson());
        msg.data.mimeType = 'application/json-schema';
        if (msg.method === "PUT") msg.data = undefined;
        return msg.setStatus(res === 200 && schemaDetails.status === 'none' ? 201 : res);
    } else {
        const details = await adapter.checkKey('', key);
        const isDirectory = details.status === "directory" || details.status === "none" && msg.url.isDirectory;
        if (isDirectory) {
            msg.data = undefined;
            return msg.setStatus(403, "Forbidden: can't over.writeKey directory");
        }
        const resCode = await adapter.writeKey('', key, msg.data.copy());
        msg.data = undefined;
        if (resCode !== 200) return msg.setStatus(resCode);
        return msg.setDateModified(details.dateModified).setHeader('Location', msg.url.toString()).setStatus(details.status === "none" ? 201 : 200, details.status === "none" ? "Created" : "OK");
    }
};
service1.post((msg, { adapter  }, config)=>write2(msg, adapter, config));
service1.put((msg, { adapter  }, config)=>write2(msg, adapter, config));
service1.delete(async (msg, { adapter  })=>{
    if (msg.url.servicePathElements.length !== 1) {
        return msg.setStatus(400, 'Dataset DELETE request should have a service path like <key>');
    }
    let [key] = msg.url.servicePathElements;
    key = normaliseKey1(key);
    const res = await adapter.deleteKey('', key);
    if (res === 404) {
        return msg.setStatus(404, 'Not found');
    } else if (res === 500) {
        return msg.setStatus(500, 'Internal server error');
    } else {
        return msg.setStatus(200);
    }
});
service1.deleteDirectory((msg)=>{
    return Promise.resolve(msg.setStatus(400, 'Cannot delete the underlying dataset of a dataset service'));
});
const __default23 = {
    "name": "Dataset Service",
    "description": "Reads and writes data with configured schema from urls by key",
    "moduleUrl": "./services/dataset.ts",
    "apis": [
        "store",
        "data.set"
    ],
    "adapterInterface": "IDataAdapter",
    "configSchema": {
        "type": "object",
        "properties": {
            "datasetName": {
                "type": "string",
                "description": "The name for the dataset which corresponds to its name in the underlying service"
            },
            "schema": {
                "type": "object",
                "description": "The schema for all data items in the dataset"
            },
            "uploadBaseUrl": {
                "type": "string",
                "description": "The url to a file store for uploading associated files"
            }
        },
        "required": [
            "datasetName"
        ]
    },
    "exposedConfigProperties": [
        "datasetName",
        "schema"
    ]
};
const findParent = async (url, context, config)=>{
    const testUrl = url.copy();
    const servicePathLen = url.servicePathElements.length;
    if (servicePathLen <= 1) return [
        null,
        null
    ];
    testUrl.servicePath = '';
    let idx = 0;
    testUrl.pathElements.push(url.servicePathElements[idx]);
    while((await context.adapter.check(testUrl.servicePath, config.extensions)).status === "directory" && idx < servicePathLen){
        idx++;
        testUrl.pathElements.push(url.servicePathElements[idx]);
    }
    if (idx === servicePathLen) return [
        null,
        null
    ];
    const details = await context.adapter.check(testUrl.servicePath, config.extensions);
    return details.status === "file" ? [
        testUrl,
        details
    ] : [
        null,
        null
    ];
};
const service2 = new Service();
const getDirectory = async (msg, { adapter  }, config)=>{
    const readDirPath = async (path)=>{
        const dirData = await adapter.readDirectory(path);
        const paths = dirData?.ok ? await dirData.asJson() || [] : [];
        return {
            path: msg.url.servicePath,
            paths,
            spec: {
                pattern: "store",
                storeMimeTypes: (config.extensions || []).map((ext)=>getType(ext)),
                createDirectory: true,
                createFiles: true
            }
        };
    };
    const featureResult = await readDirPath(msg.url.servicePath);
    return msg.setDirectoryJson(featureResult);
};
service2.getDirectory(async (msg, context, config)=>{
    if (config.defaultResource && msg.url.servicePathElements.length === 0 && !msg.isManageRequest) {
        msg.url.pathElements.push(config.defaultResource);
        return await get(msg, context, config);
    }
    return await getDirectory(msg, context, config);
});
const get = async (msg, context, config)=>{
    let details = await context.adapter.check(msg.url.servicePath, config.extensions);
    if (details.status === "directory") {
        if (config.defaultResource) {
            msg.url.pathElements.push(config.defaultResource);
            details = await context.adapter.check(msg.url.servicePath, config.extensions);
        } else {
            return await getDirectory(msg, context, config);
        }
    }
    if (details.status === "none") {
        if (config.parentIfMissing) {
            const [parentUrl, parentDetails] = await findParent(msg.url, context, config);
            if (parentUrl !== null && parentDetails !== null) {
                msg.setUrl(parentUrl);
                msg.setHeader('Location', parentUrl.toString());
                details = parentDetails;
            }
        }
        if (details.status === "none") {
            msg.data = undefined;
            return msg.setStatus(404, 'Not found');
        }
    }
    const fileDetails = details;
    let start, end;
    msg.setHeader('Accept-Ranges', 'bytes');
    msg.data = new MessageBody(null, "text/plain");
    const range = msg.getRequestRange(fileDetails.size);
    if (range === -1) {
        return msg.setRange('bytes', fileDetails.size).setStatus(416, 'Requested Range not Satisfiable');
    }
    if (range && range !== -2 && range.length === 1) {
        msg.setStatus(206).setRange('bytes', fileDetails.size, range[0]);
        start = range[0].start;
        end = Math.min(range[0].end, fileDetails.size - 1);
    }
    if (msg.method !== 'HEAD') {
        msg.data = await context.adapter.read(msg.url.servicePath, config.extensions, start, end);
    }
    msg.data.size = start !== undefined && end !== undefined ? end - start + 1 : fileDetails.size;
    msg.data.dateModified = details.dateModified;
    return msg;
};
service2.get(get);
const writeAction = (returnData)=>async (msg, context, config)=>{
        const { adapter  } = context;
        if (!msg.hasData()) return msg.setStatus(400, "No data to write");
        const details = await adapter.check(msg.url.servicePath, config.extensions);
        if (details.status === "directory" || details.status === "none" && msg.url.isDirectory) {
            if (isZip(msg.getHeader('Content-Type'))) {
                let failCount = 0;
                let failStatus = undefined;
                try {
                    for await (const resMsg of unzip(msg).flatMap((msg)=>writeAction(returnData)(msg, context, config))){
                        if (!resMsg.ok) {
                            failCount++;
                            if (failStatus === undefined) failStatus = resMsg.status;
                            else if (failStatus !== resMsg.status) failStatus = -1;
                        }
                    }
                } catch (err) {
                    return msg.setStatus(500, `Error unzipping: ${err}`);
                }
                if (failCount) return msg.setStatus(failStatus || 400);
            } else {
                return msg.setStatus(403, "Forbidden: can't overwrite directory");
            }
        } else {
            const resCode = await adapter.write(msg.url.servicePath, msg.data.copy(), config.extensions);
            if (!returnData) msg.data = undefined;
            if (resCode !== 200) return msg.setStatus(resCode);
        }
        return msg.setHeader('Location', msg.url.toString()).setStatus(details.status === "none" ? 201 : 200);
    };
service2.post(writeAction(true));
service2.put(writeAction(false));
service2.delete(async (msg, { adapter  }, config)=>{
    const res = await adapter.delete(msg.url.servicePath, config.extensions);
    msg.data = undefined;
    if (res === 404) {
        return msg.setStatus(404, 'Not found');
    } else if (res === 500) {
        return msg.setStatus(500, 'Internal server error');
    } else {
        return msg.setStatus(200);
    }
});
service2.deleteDirectory(async (msg, { adapter  })=>{
    try {
        const status = await adapter.deleteDirectory(msg.url.servicePath, '.config.json');
        if (status === 400) {
            return msg.setStatus(400, 'Not empty');
        } else if (status === 404) {
            return msg.setStatus(404, 'Not found');
        } else if (status === 500) {
            return msg.setStatus(500, 'Internal server error');
        }
    } catch  {
        return msg.setStatus(500, 'Internal server error');
    }
    return msg;
});
const __default24 = {
    "name": "File Service",
    "description": "GET files from urls and PUT files to urls",
    "moduleUrl": "./services/file.ts",
    "apis": [
        "store",
        "file.base"
    ],
    "adapterInterface": "IFileAdapter",
    "configSchema": {
        "type": "object",
        "properties": {
            "extensions": {
                "type": "array",
                "items": {
                    "type": "string"
                },
                "description": "Optional list of the file extensions allowed to be stored"
            },
            "parentIfMissing": {
                "type": "boolean",
                "description": "Optional flag which if set, when a missing file is requested, will substitute the nearest parent file on the path tree if one exists"
            },
            "defaultResource": {
                "type": "string",
                "description": "If a file which is a directory is requested, serve the file with this name in the directory instead"
            }
        }
    }
};
const base64abc1 = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/", 
];
function encode2(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i;
    const l = uint8.length;
    for(i = 2; i < l; i += 3){
        result += base64abc1[uint8[i - 2] >> 2];
        result += base64abc1[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc1[(uint8[i - 1] & 0x0f) << 2 | uint8[i] >> 6];
        result += base64abc1[uint8[i] & 0x3f];
    }
    if (i === l + 1) {
        result += base64abc1[uint8[i - 2] >> 2];
        result += base64abc1[(uint8[i - 2] & 0x03) << 4];
        result += "==";
    }
    if (i === l) {
        result += base64abc1[uint8[i - 2] >> 2];
        result += base64abc1[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc1[(uint8[i - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
function decode3(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        bytes[i] = binString.charCodeAt(i);
    }
    return bytes;
}
const service3 = new Service();
service3.postPath('/bypass', (msg)=>msg);
service3.postPath('/destream', async (msg)=>{
    await msg.data?.ensureDataIsArrayBuffer();
    return msg;
});
service3.postPath('/to-b64', async (msg)=>{
    if (!msg.data) return msg;
    const arry = new Uint8Array(await msg.data.asArrayBuffer());
    return msg.setData(encode2(arry), msg.data.mimeType);
});
service3.postPath('/from-b64', async (msg)=>{
    if (!msg.data) return msg;
    const str = new TextDecoder().decode(await msg.data.asArrayBuffer());
    return msg.setData(decode3(str).buffer, msg.data.mimeType);
});
service3.postPath('/selector-schema', async (msg)=>{
    if (!msg.data) return msg;
    if (msg.data.mimeType !== 'inode/directory+json') {
        return Promise.resolve(msg.setStatus(400, 'selector-schema only applies to a directory output (mime type inode/directory+json)'));
    }
    const dirJson = await msg.data.asJson();
    const items = dirJson.filter((i)=>!i.endsWith('/'));
    const schema = {
        type: "string",
        enum: items
    };
    return msg.setDataJson(schema, "application/schema+json");
});
service3.postPath('/redirect-permanent', (msg)=>{
    const location = '/' + msg.url.servicePath;
    msg.exitConditionalMode();
    return msg.setHeader('location', location).setStatus(301);
});
service3.postPath('/redirect-temporary', (msg)=>{
    const location = '/' + msg.url.servicePath;
    msg.exitConditionalMode();
    return msg.setHeader('location', location).setStatus(307);
});
service3.postPath('/see-other', (msg)=>{
    const location = '/' + msg.url.servicePath;
    msg.exitConditionalMode();
    return msg.setHeader('location', location).setStatus(303);
});
service3.postPath('/reload-referer', (msg)=>{
    const location = msg.getHeader('referer');
    if (!location) return Promise.resolve(msg);
    msg.exitConditionalMode();
    return msg.setHeader('location', location).setStatus(303);
});
service3.postPath('/log/body', async (msg, context)=>{
    const json = await msg.data?.asJson();
    context.logger.info('BODY ' + JSON.stringify(json || {}), ...msg.loggerArgs());
    return msg;
});
const __default25 = {
    "name": "Library functions",
    "description": "A range of simple utility web functions",
    "moduleUrl": "./services/lib.ts",
    "apis": [
        "sys.lib"
    ]
};
const __default26 = {
    "name": "Pipeline",
    "description": "A pipeline of urls acting as request processors in parallel or serial",
    "moduleUrl": "./services/pipeline.ts",
    "apis": [
        "transform",
        "pipeline"
    ],
    "configSchema": {
        "$id": "http://restspace.io/services/pipeline",
        "definitions": {
            "pipeline": {
                "type": "array",
                "items": {
                    "type": [
                        "string",
                        "array",
                        "object"
                    ],
                    "oneOf": [
                        {
                            "title": "request",
                            "type": "string"
                        },
                        {
                            "title": "subpipeline",
                            "$ref": "#/definitions/pipeline"
                        },
                        {
                            "title": "transform",
                            "type": "object"
                        }
                    ],
                    "editor": "oneOfRadio"
                }
            }
        },
        "type": "object",
        "properties": {
            "pipeline": {
                "$ref": "#/definitions/pipeline"
            },
            "manualMimeTypes": {
                "type": "object",
                "properties": {
                    "requestMimeType": {
                        "type": "string"
                    },
                    "requestSchema": {
                        "type": "object"
                    },
                    "responseMimeType": {
                        "type": "string"
                    },
                    "responseSchema": {
                        "type": "object"
                    }
                }
            },
            "reauthenticate": {
                "type": "boolean"
            }
        }
    }
};
const __default27 = {
    "name": "Pipeline store",
    "description": "Run a pipeline whose specification is stored at the request url",
    "moduleUrl": "./services/pipeline-store.ts",
    "apis": [
        "store-transform"
    ],
    "isFilter": true,
    "configSchema": {
        "type": "object",
        "properties": {
            "store": {
                "type": "object",
                "description": "Configuration for the pipeline store",
                "properties": {
                    "adapterSource": {
                        "type": "string",
                        "description": "Source url for adapter for pipeline store"
                    },
                    "infraName": {
                        "type": "string",
                        "description": "Infra name for pipeline store"
                    },
                    "adapterConfig": {
                        "type": "object",
                        "properties": {}
                    },
                    "parentIfMissing": {
                        "type": "boolean",
                        "description": "Optional flag which for a pipeline on a path, sends all subpaths to that pipeline as well. Default true"
                    }
                }
            }
        },
        "required": [
            "store"
        ]
    },
    "postPipeline": [
        "if (isManage && method !== 'POST') $METHOD store/$*"
    ],
    "privateServices": {
        "store": {
            "name": "'Pipeline Store'",
            "source": "./services/file.rsm.json",
            "access": {
                "readRoles": "access.readRoles",
                "writeRoles": "access.writeRoles"
            },
            "adapterInterface": "IFileAdapter",
            "adapterSource": "store.adapterSource",
            "infraName": "store.infraName",
            "adapterConfig": "store.adapterConfig",
            "extensions": "[ 'json' ]",
            "parentIfMissing": "store.parentIfMissing === false ? false : true"
        }
    }
};
const service4 = new Service();
const processGet = async (msg, { adapter , logger  }, config)=>{
    const targetPath = msg.url.servicePath || '/';
    const details = await adapter.check(targetPath);
    if (config.divertMissingToDefault && details.status === 'none' && !msg.isManageRequest) {
        msg.setServiceRedirect('/');
        logger.debug(`static-site-filter diverting ${msg.url} to default`);
    }
    return msg;
};
service4.get(processGet);
const __default28 = {
    "name": "Static site filter",
    "description": "Provide static site behaviour with options suitable for hosting SPAs",
    "moduleUrl": "./services/static-site-filter.ts",
    "apis": [],
    "isFilter": true,
    "configSchema": {
        "type": "object",
        "properties": {
            "divertMissingToDefault": {
                "type": "boolean",
                "description": "Divert a 404 Not Found to the default file, needed for JS routing"
            }
        }
    }
};
const __default29 = {
    "name": "Static site service",
    "description": "Hosts a static site with options suitable for SPA routing",
    "moduleUrl": "./services/file.ts",
    "apis": [
        "store",
        "file.base"
    ],
    "adapterInterface": "IFileAdapter",
    "prePipeline": [
        "$METHOD staticSiteFilter/$*?targetPath=$*&outerUrl=$$"
    ],
    "configSchema": {
        "type": "object",
        "properties": {
            "divertMissingToDefault": {
                "type": "boolean",
                "description": "Divert a 404 Not Found to the default file, needed for JS routing"
            },
            "defaultResource": {
                "type": "string",
                "description": "Name of the resource served to /base-path/"
            }
        }
    },
    "privateServices": {
        "staticSiteFilter": {
            "name": "'Static site filter'",
            "access": {
                "readRoles": "'all'",
                "writeRoles": "'all'"
            },
            "source": "./services/static-site-filter.rsm.json",
            "infraName": "infraName",
            "adapterConfig": "adapterConfig",
            "adapterSource": "adapterSource",
            "divertMissingToDefault": "divertMissingToDefault"
        }
    }
};
const __default30 = {
    "name": "User data service",
    "description": "Manages access to and stores user data",
    "moduleUrl": "./services/dataset.ts",
    "apis": [
        "store",
        "data.set"
    ],
    "adapterInterface": "IDataAdapter",
    "prePipeline": [
        "$METHOD userFilter/$P*"
    ],
    "postPipeline": [
        "$METHOD userFilter/$P*"
    ],
    "privateServices": {
        "userFilter": {
            "name": "'User filter'",
            "access": {
                "readRoles": "'all'",
                "writeRoles": "'all'"
            },
            "source": "./services/user-filter.rsm.json"
        }
    }
};
const __default31 = {
    "name": "User filter",
    "description": "Manage passwords and restrict illegal operations to users",
    "moduleUrl": "./services/user-filter.ts",
    "apis": [],
    "isFilter": true
};
const service5 = new Service();
service5.post(async (msg, context, config)=>{
    const data = await msg.data?.asJson() ?? {};
    const reqTemplate = msg.copy().setMethod("GET");
    const msgTemplate = await context.makeRequest(reqTemplate);
    if (!msgTemplate.ok) return msgTemplate;
    const template = await msgTemplate.data.asString();
    const contextUrl = msg.url.copy();
    contextUrl.setSubpathFromUrl(msgTemplate.getHeader('location') || '');
    const output = await context.adapter.fillTemplate(data, template || "", contextUrl);
    return msg.setData(output, config.outputMime);
});
const __default32 = {
    "name": "Template",
    "description": "Fill a template with data from the request",
    "moduleUrl": "./services/template.ts",
    "apis": [
        "store-transform"
    ],
    "adapterInterface": "ITemplateAdapter",
    "isFilter": true,
    "configSchema": {
        "type": "object",
        "properties": {
            "outputMime": {
                "type": "string"
            },
            "store": {
                "type": "object",
                "description": "Configuration for the template store",
                "properties": {
                    "adapterSource": {
                        "type": "string",
                        "description": "Source url for adapter for template store"
                    },
                    "infraName": {
                        "type": "string",
                        "description": "Infra name for template store"
                    },
                    "adapterConfig": {
                        "type": "object",
                        "properties": {}
                    },
                    "extension": {
                        "type": "string",
                        "description": "Extension for template files"
                    },
                    "parentIfMissing": {
                        "type": "boolean",
                        "description": "Optional flag which for a pipeline on a path, sends all subpaths to that pipeline as well. Default true"
                    }
                },
                "required": [
                    "extension"
                ]
            }
        },
        "required": [
            "outputMime",
            "store"
        ]
    },
    "postPipeline": [
        "if (method !== 'POST') $METHOD store/$*"
    ],
    "privateServices": {
        "store": {
            "name": "'Template Store'",
            "source": "./services/file.rsm.json",
            "access": {
                "readRoles": "access.readRoles",
                "writeRoles": "access.writeRoles"
            },
            "adapterInterface": "IFileAdapter",
            "adapterSource": "store.adapterSource",
            "infraName": "store.infraName",
            "adapterConfig": "store.adapterConfig",
            "extensions": "[ store.extension ]",
            "parentIfMissing": "store.parentIfMissing === false ? false : true"
        }
    }
};
const service6 = new Service();
service6.all(async (msg, context)=>{
    const { adapter , makeRequest  } = context;
    let sendMsg = msg.copy();
    while(sendMsg.url.basePathElementCount > 0){
        sendMsg.url.pathElements.shift();
        sendMsg.url.basePathElementCount--;
    }
    sendMsg = await adapter.buildMessage(sendMsg);
    context.logger.info(`Proxy, msg headers: ${JSON.stringify(sendMsg.headers)}`);
    return makeRequest(sendMsg);
});
const __default33 = {
    "name": "Proxy Service",
    "description": "Forwards requests with server defined authentication or urls",
    "moduleUrl": "./services/proxy.ts",
    "apis": [
        "proxy"
    ],
    "adapterInterface": "IProxyAdapter"
};
const importMeta1 = {
    url: "https://deno.land/x/denomailer@1.2.0/client/worker/worker.ts",
    main: false
};
class SMTPWorker {
    id = 1;
    #timeout;
    constructor(config){
        this.#config = config;
        this.#timeout = config.pool.timeout;
    }
    #w;
    #idleTO = null;
    #idleMode2 = false;
    #noCon = true;
    #config;
    #resolver = new Map();
    #startup() {
        this.#w = new Worker(new URL("./worker-file.ts", importMeta1.url), {
            type: "module",
            deno: {
                permissions: {
                    net: "inherit",
                    read: true
                },
                namespace: true
            }
        });
        this.#w.addEventListener("message", (ev)=>{
            if (typeof ev.data === "object") {
                if ("err" in ev.data) {
                    this.#resolver.get(ev.data.__ret)?.rej(ev.data.err);
                }
                if ("res" in ev.data) {
                    this.#resolver.get(ev.data.__ret)?.res(ev.data.res);
                }
                this.#resolver.delete(ev.data.__ret);
                return;
            }
            if (ev.data) {
                this.#stopIdle();
            } else {
                if (this.#idleMode2) {
                    this.#cleanup();
                } else {
                    this.#startIdle();
                }
            }
        });
        this.#w.postMessage({
            __setup: {
                ...this.#config,
                client: {
                    ...this.#config.client,
                    preprocessors: []
                }
            }
        });
        this.#noCon = false;
    }
    #startIdle() {
        console.log("started idle");
        if (this.#idleTO) {
            return;
        }
        this.#idleTO = setTimeout(()=>{
            console.log("idle mod 2");
            this.#idleMode2 = true;
            this.#w.postMessage({
                __check_idle: true
            });
        }, this.#timeout);
    }
    #stopIdle() {
        if (this.#idleTO) {
            clearTimeout(this.#idleTO);
        }
        this.#idleMode2 = false;
        this.#idleTO = null;
    }
    #cleanup() {
        console.log("killed");
        this.#w.terminate();
        this.#stopIdle();
    }
    send(mail) {
        const myID = this.id;
        this.id++;
        this.#stopIdle();
        if (this.#noCon) {
            this.#startup();
        }
        this.#w.postMessage({
            __mail: myID,
            mail
        });
        return new Promise((res, rej)=>{
            this.#resolver.set(myID, {
                res,
                rej
            });
        });
    }
    close() {
        if (this.#w) this.#w.terminate();
        if (this.#idleTO) {
            clearTimeout(this.#idleTO);
        }
    }
}
class SMTPWorkerPool {
    pool = [];
    constructor(config){
        for(let i = 0; i < config.pool.size; i++){
            this.pool.push(new SMTPWorker(config));
        }
    }
    #lastUsed = -1;
    send(mail) {
        this.#lastUsed = (this.#lastUsed + 1) % this.pool.length;
        return this.pool[this.#lastUsed].send(mail);
    }
    close() {
        this.pool.forEach((v)=>v.close());
    }
}
class DenoStdInternalError3 extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert3(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError3(msg);
    }
}
function concat(...buf) {
    let length = 0;
    for (const b of buf){
        length += b.length;
    }
    const output = new Uint8Array(length);
    let index = 0;
    for (const b1 of buf){
        output.set(b1, index);
        index += b1.length;
    }
    return output;
}
function copy1(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
const MIN_BUF_SIZE = 16;
const CR = "\r".charCodeAt(0);
const LF = "\n".charCodeAt(0);
class BufferFullError extends Error {
    name;
    constructor(partial){
        super("Buffer full");
        this.partial = partial;
        this.name = "BufferFullError";
    }
    partial;
}
class PartialReadError extends Error {
    name = "PartialReadError";
    partial;
    constructor(){
        super("Encountered UnexpectedEof, data only partially read");
    }
}
class BufReader {
    #buf;
    #rd;
    #r = 0;
    #w = 0;
    #eof = false;
    static create(r, size = 4096) {
        return r instanceof BufReader ? r : new BufReader(r, size);
    }
    constructor(rd, size = 4096){
        if (size < 16) {
            size = MIN_BUF_SIZE;
        }
        this.#reset(new Uint8Array(size), rd);
    }
    size() {
        return this.#buf.byteLength;
    }
    buffered() {
        return this.#w - this.#r;
    }
    #fill = async ()=>{
        if (this.#r > 0) {
            this.#buf.copyWithin(0, this.#r, this.#w);
            this.#w -= this.#r;
            this.#r = 0;
        }
        if (this.#w >= this.#buf.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i = 100; i > 0; i--){
            const rr = await this.#rd.read(this.#buf.subarray(this.#w));
            if (rr === null) {
                this.#eof = true;
                return;
            }
            assert3(rr >= 0, "negative read");
            this.#w += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    };
    reset(r) {
        this.#reset(this.#buf, r);
    }
    #reset = (buf, rd)=>{
        this.#buf = buf;
        this.#rd = rd;
        this.#eof = false;
    };
    async read(p) {
        let rr = p.byteLength;
        if (p.byteLength === 0) return rr;
        if (this.#r === this.#w) {
            if (p.byteLength >= this.#buf.byteLength) {
                const rr1 = await this.#rd.read(p);
                const nread = rr1 ?? 0;
                assert3(nread >= 0, "negative read");
                return rr1;
            }
            this.#r = 0;
            this.#w = 0;
            rr = await this.#rd.read(this.#buf);
            if (rr === 0 || rr === null) return rr;
            assert3(rr >= 0, "negative read");
            this.#w += rr;
        }
        const copied = copy1(this.#buf.subarray(this.#r, this.#w), p, 0);
        this.#r += copied;
        return copied;
    }
    async readFull(p) {
        let bytesRead = 0;
        while(bytesRead < p.length){
            try {
                const rr = await this.read(p.subarray(bytesRead));
                if (rr === null) {
                    if (bytesRead === 0) {
                        return null;
                    } else {
                        throw new PartialReadError();
                    }
                }
                bytesRead += rr;
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = p.subarray(0, bytesRead);
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = p.subarray(0, bytesRead);
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return p;
    }
    async readByte() {
        while(this.#r === this.#w){
            if (this.#eof) return null;
            await this.#fill();
        }
        const c = this.#buf[this.#r];
        this.#r++;
        return c;
    }
    async readString(delim) {
        if (delim.length !== 1) {
            throw new Error("Delimiter should be a single character");
        }
        const buffer = await this.readSlice(delim.charCodeAt(0));
        if (buffer === null) return null;
        return new TextDecoder().decode(buffer);
    }
    async readLine() {
        let line = null;
        try {
            line = await this.readSlice(LF);
        } catch (err) {
            if (err instanceof Deno.errors.BadResource) {
                throw err;
            }
            let partial;
            if (err instanceof PartialReadError) {
                partial = err.partial;
                assert3(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
            }
            if (!(err instanceof BufferFullError)) {
                throw err;
            }
            partial = err.partial;
            if (!this.#eof && partial && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR) {
                assert3(this.#r > 0, "bufio: tried to rewind past start of buffer");
                this.#r--;
                partial = partial.subarray(0, partial.byteLength - 1);
            }
            if (partial) {
                return {
                    line: partial,
                    more: !this.#eof
                };
            }
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                line,
                more: false
            };
        }
        if (line[line.byteLength - 1] == LF) {
            let drop = 1;
            if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                drop = 2;
            }
            line = line.subarray(0, line.byteLength - drop);
        }
        return {
            line,
            more: false
        };
    }
    async readSlice(delim) {
        let s = 0;
        let slice;
        while(true){
            let i = this.#buf.subarray(this.#r + s, this.#w).indexOf(delim);
            if (i >= 0) {
                i += s;
                slice = this.#buf.subarray(this.#r, this.#r + i + 1);
                this.#r += i + 1;
                break;
            }
            if (this.#eof) {
                if (this.#r === this.#w) {
                    return null;
                }
                slice = this.#buf.subarray(this.#r, this.#w);
                this.#r = this.#w;
                break;
            }
            if (this.buffered() >= this.#buf.byteLength) {
                this.#r = this.#w;
                const oldbuf = this.#buf;
                const newbuf = this.#buf.slice(0);
                this.#buf = newbuf;
                throw new BufferFullError(oldbuf);
            }
            s = this.#w - this.#r;
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = slice;
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = slice;
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return slice;
    }
    async peek(n) {
        if (n < 0) {
            throw Error("negative count");
        }
        let avail = this.#w - this.#r;
        while(avail < n && avail < this.#buf.byteLength && !this.#eof){
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = this.#buf.subarray(this.#r, this.#w);
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = this.#buf.subarray(this.#r, this.#w);
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
            avail = this.#w - this.#r;
        }
        if (avail === 0 && this.#eof) {
            return null;
        } else if (avail < n && this.#eof) {
            return this.#buf.subarray(this.#r, this.#r + avail);
        } else if (avail < n) {
            throw new BufferFullError(this.#buf.subarray(this.#r, this.#w));
        }
        return this.#buf.subarray(this.#r, this.#r + n);
    }
}
class AbstractBufBase1 {
    buf;
    usedBufferBytes = 0;
    err = null;
    constructor(buf){
        this.buf = buf;
    }
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriter extends AbstractBufBase1 {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriter ? writer : new BufWriter(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w;
    }
    async flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p.length){
                nwritten += await this.#writer.write(p.subarray(nwritten));
            }
        } catch (e) {
            if (e instanceof Error) {
                this.err = e;
            }
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    async write(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = await this.#writer.write(data);
                } catch (e) {
                    if (e instanceof Error) {
                        this.err = e;
                    }
                    throw e;
                }
            } else {
                numBytesWritten = copy1(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                await this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy1(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
const CHAR_SPACE = " ".charCodeAt(0);
const CHAR_TAB = "\t".charCodeAt(0);
const CHAR_COLON = ":".charCodeAt(0);
const WHITESPACES = [
    CHAR_SPACE,
    CHAR_TAB
];
const decoder1 = new TextDecoder();
const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/g;
function str(buf) {
    return !buf ? "" : decoder1.decode(buf);
}
class TextProtoReader {
    constructor(r){
        this.r = r;
    }
    async readLine() {
        const s = await this.readLineSlice();
        return s === null ? null : str(s);
    }
    async readMIMEHeader() {
        const m = new Headers();
        let line;
        let buf = await this.r.peek(1);
        if (buf === null) {
            return null;
        } else if (WHITESPACES.includes(buf[0])) {
            line = await this.readLineSlice();
        }
        buf = await this.r.peek(1);
        if (buf === null) {
            throw new Deno.errors.UnexpectedEof();
        } else if (WHITESPACES.includes(buf[0])) {
            throw new Deno.errors.InvalidData(`malformed MIME header initial line: ${str(line)}`);
        }
        while(true){
            const kv = await this.readLineSlice();
            if (kv === null) throw new Deno.errors.UnexpectedEof();
            if (kv.byteLength === 0) return m;
            let i = kv.indexOf(CHAR_COLON);
            if (i < 0) {
                throw new Deno.errors.InvalidData(`malformed MIME header line: ${str(kv)}`);
            }
            const key = str(kv.subarray(0, i));
            if (key == "") {
                continue;
            }
            i++;
            while(i < kv.byteLength && WHITESPACES.includes(kv[i])){
                i++;
            }
            const value = str(kv.subarray(i)).replace(invalidHeaderCharRegex, encodeURI);
            try {
                m.append(key, value);
            } catch  {}
        }
    }
    async readLineSlice() {
        let line = new Uint8Array(0);
        let r = null;
        do {
            r = await this.r.readLine();
            if (r !== null && this.skipSpace(r.line) !== 0) {
                line = concat(line, r.line);
            }
        }while (r !== null && r.more)
        return r === null ? null : line;
    }
    skipSpace(l) {
        let n = 0;
        for (const val of l){
            if (!WHITESPACES.includes(val)) {
                n++;
            }
        }
        return n;
    }
    r;
}
const base64abc2 = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/", 
];
function encode3(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i;
    const l = uint8.length;
    for(i = 2; i < l; i += 3){
        result += base64abc2[uint8[i - 2] >> 2];
        result += base64abc2[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc2[(uint8[i - 1] & 0x0f) << 2 | uint8[i] >> 6];
        result += base64abc2[uint8[i] & 0x3f];
    }
    if (i === l + 1) {
        result += base64abc2[uint8[i - 2] >> 2];
        result += base64abc2[(uint8[i - 2] & 0x03) << 4];
        result += "==";
    }
    if (i === l) {
        result += base64abc2[uint8[i - 2] >> 2];
        result += base64abc2[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc2[(uint8[i - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
const encoder1 = new TextEncoder();
class SMTPConnection {
    secure;
    conn;
    #reader;
    #writer;
    constructor(config){
        this.config = config;
        this.secure = false;
        this.conn = null;
        this.#reader = null;
        this.#writer = null;
        this.ready = this.#connect();
    }
    ready;
    async close() {
        await this.ready;
        if (!this.conn) {
            return;
        }
        await this.conn.close();
    }
    setupConnection(conn) {
        this.conn = conn;
        const reader = new BufReader(this.conn);
        this.#writer = new BufWriter(this.conn);
        this.#reader = new TextProtoReader(reader);
    }
    async #connect() {
        if (this.config.connection.tls) {
            this.conn = await Deno.connectTls({
                hostname: this.config.connection.hostname,
                port: this.config.connection.port
            });
            this.secure = true;
        } else {
            this.conn = await Deno.connect({
                hostname: this.config.connection.hostname,
                port: this.config.connection.port
            });
        }
        this.setupConnection(this.conn);
    }
    assertCode(cmd, code, msg) {
        if (!cmd) {
            throw new Error(`invalid cmd`);
        }
        if (cmd.code !== code) {
            throw new Error(msg || cmd.code + ": " + cmd.args);
        }
    }
    async readCmd() {
        if (!this.#reader) {
            return null;
        }
        const result = [];
        while(result.length === 0 || result.at(-1) && result.at(-1).at(3) === "-"){
            result.push(await this.#reader.readLine());
        }
        const nonNullResult = result.at(-1) === null ? result.slice(0, result.length - 1) : result;
        if (nonNullResult.length === 0) return null;
        const code = parseInt(nonNullResult[0].slice(0, 3));
        const data = nonNullResult.map((v)=>v.slice(4).trim());
        if (this.config.debug.log) {
            nonNullResult.forEach((v)=>console.log(v));
        }
        return {
            code,
            args: data
        };
    }
    async writeCmd(...args) {
        if (!this.#writer) {
            return null;
        }
        if (this.config.debug.log) {
            console.table(args);
        }
        const data = encoder1.encode([
            ...args
        ].join(" ") + "\r\n");
        await this.#writer.write(data);
        await this.#writer.flush();
    }
    async writeCmdBinary(...args) {
        if (!this.#writer) {
            return null;
        }
        if (this.config.debug.log) {
            console.table(args.map(()=>"Uint8Attay"));
        }
        for(let i = 0; i < args.length; i++){
            await this.#writer.write(args[i]);
        }
        await this.#writer.flush();
    }
    config;
}
const CommandCode = {
    READY: 220,
    AUTHO_SUCCESS: 235,
    OK: 250,
    BEGIN_DATA: 354,
    FAIL: 554
};
class QUE {
    running = false;
    #que = [];
    idle = Promise.resolve();
    #idbleCB;
    que() {
        if (!this.running) {
            this.running = true;
            this.idle = new Promise((res)=>{
                this.#idbleCB = res;
            });
            return Promise.resolve();
        }
        return new Promise((res)=>{
            this.#que.push(res);
        });
    }
    next() {
        if (this.#que.length === 0) {
            this.running = false;
            if (this.#idbleCB) this.#idbleCB();
            return;
        }
        this.#que[0]();
        this.#que.splice(0, 1);
    }
}
class SMTPClient {
    #connection;
    #que;
    constructor(config){
        this.config = config;
        this.#que = new QUE();
        this.#supportedFeatures = new Set();
        const c = new SMTPConnection(config);
        this.#connection = c;
        this.#ready = (async ()=>{
            await c.ready;
            await this.#prepareConnection();
        })();
    }
    #ready;
    close() {
        return this.#connection.close();
    }
    get isSending() {
        return this.#que.running;
    }
    get idle() {
        return this.#que.idle;
    }
    async send(config) {
        await this.#ready;
        try {
            await this.#que.que();
            await this.#connection.writeCmd("MAIL", "FROM:", `<${config.from.mail}>`);
            this.#connection.assertCode(await this.#connection.readCmd(), CommandCode.OK);
            for(let i = 0; i < config.to.length; i++){
                await this.#connection.writeCmd("RCPT", "TO:", `<${config.to[i].mail}>`);
                this.#connection.assertCode(await this.#connection.readCmd(), CommandCode.OK);
            }
            for(let i1 = 0; i1 < config.cc.length; i1++){
                await this.#connection.writeCmd("RCPT", "TO:", `<${config.cc[i1].mail}>`);
                this.#connection.assertCode(await this.#connection.readCmd(), CommandCode.OK);
            }
            for(let i2 = 0; i2 < config.bcc.length; i2++){
                await this.#connection.writeCmd("RCPT", "TO:", `<${config.bcc[i2].mail}>`);
                this.#connection.assertCode(await this.#connection.readCmd(), CommandCode.OK);
            }
            await this.#connection.writeCmd("DATA");
            this.#connection.assertCode(await this.#connection.readCmd(), CommandCode.BEGIN_DATA);
            await this.#connection.writeCmd("Subject: ", config.subject);
            await this.#connection.writeCmd("From: ", `${config.from.name} <${config.from.mail}>`);
            if (config.to.length > 0) {
                await this.#connection.writeCmd("To: ", config.to.map((m)=>`${m.name} <${m.mail}>`).join(";"));
            }
            if (config.cc.length > 0) {
                await this.#connection.writeCmd("Cc: ", config.cc.map((m)=>`${m.name} <${m.mail}>`).join(";"));
            }
            await this.#connection.writeCmd("Date: ", config.date);
            const obj = Object.entries(config.headers);
            for(let i3 = 0; i3 < obj.length; i3++){
                const [name, value] = obj[i3];
                await this.#connection.writeCmd(name + ": ", value);
            }
            if (config.inReplyTo) {
                await this.#connection.writeCmd("InReplyTo: ", config.inReplyTo);
            }
            if (config.references) {
                await this.#connection.writeCmd("Refrences: ", config.references);
            }
            if (config.replyTo) {
                await this.#connection.writeCmd("ReplyTo: ", `${config.replyTo.name} <${config.replyTo.name}>`);
            }
            if (config.priority) {
                await this.#connection.writeCmd("Priority:", config.priority);
            }
            await this.#connection.writeCmd("MIME-Version: 1.0");
            let boundaryAdditionAtt = 100;
            config.mimeContent.map((v)=>v.content).join("\n").replace(new RegExp("--attachment([0-9]+)", "g"), (_, numb)=>{
                boundaryAdditionAtt += parseInt(numb, 10);
                return "";
            });
            config.attachments.map((v)=>{
                return v.content;
            }).join("\n").replace(new RegExp("--attachment([0-9]+)", "g"), (_, numb)=>{
                boundaryAdditionAtt += parseInt(numb, 10);
                return "";
            });
            const attachmentBoundary = `attachment${boundaryAdditionAtt}`;
            await this.#connection.writeCmd(`Content-Type: multipart/mixed; boundary=${attachmentBoundary}`, "\r\n");
            await this.#connection.writeCmd(`--${attachmentBoundary}`);
            let boundaryAddition = 100;
            config.mimeContent.map((v)=>v.content).join("\n").replace(new RegExp("--message([0-9]+)", "g"), (_, numb)=>{
                boundaryAddition += parseInt(numb, 10);
                return "";
            });
            const messageBoundary = `message${boundaryAddition}`;
            await this.#connection.writeCmd(`Content-Type: multipart/alternative; boundary=${messageBoundary}`, "\r\n");
            for(let i4 = 0; i4 < config.mimeContent.length; i4++){
                await this.#connection.writeCmd(`--${messageBoundary}`);
                await this.#connection.writeCmd("Content-Type: " + config.mimeContent[i4].mimeType);
                if (config.mimeContent[i4].transferEncoding) {
                    await this.#connection.writeCmd(`Content-Transfer-Encoding: ${config.mimeContent[i4].transferEncoding}` + "\r\n");
                } else {
                    await this.#connection.writeCmd("");
                }
                await this.#connection.writeCmd(config.mimeContent[i4].content, "\r\n");
            }
            await this.#connection.writeCmd(`--${messageBoundary}--\r\n`);
            for(let i5 = 0; i5 < config.attachments.length; i5++){
                const attachment = config.attachments[i5];
                await this.#connection.writeCmd(`--${attachmentBoundary}`);
                await this.#connection.writeCmd("Content-Type:", attachment.contentType + ";", "name=" + attachment.filename);
                if (attachment.contentID) {
                    await this.#connection.writeCmd(`Content-ID: <${attachment.contentID}>`);
                }
                await this.#connection.writeCmd("Content-Disposition: attachment; filename=" + attachment.filename);
                if (attachment.encoding === "base64") {
                    await this.#connection.writeCmd("Content-Transfer-Encoding: base64", "\r\n");
                    for(let line = 0; line < Math.ceil(attachment.content.length / 75); line++){
                        const lineOfBase64 = attachment.content.slice(line * 75, (line + 1) * 75);
                        await this.#connection.writeCmd(lineOfBase64);
                    }
                    await this.#connection.writeCmd("\r\n");
                } else if (attachment.encoding === "text") {
                    await this.#connection.writeCmd("Content-Transfer-Encoding: quoted-printable", "\r\n");
                    await this.#connection.writeCmd(attachment.content, "\r\n");
                }
            }
            await this.#connection.writeCmd(`--${attachmentBoundary}--\r\n`);
            await this.#connection.writeCmd(".\r\n");
            this.#connection.assertCode(await this.#connection.readCmd(), CommandCode.OK);
            await this.#cleanup();
            this.#que.next();
        } catch (ex) {
            await this.#cleanup();
            this.#que.next();
            throw ex;
        }
    }
    async #prepareConnection() {
        this.#connection.assertCode(await this.#connection.readCmd(), CommandCode.READY);
        await this.#connection.writeCmd("EHLO", this.config.connection.hostname);
        const cmd = await this.#connection.readCmd();
        if (!cmd) throw new Error("Unexpected empty response");
        if (typeof cmd.args === "string") {
            this.#supportedFeatures.add(cmd.args);
        } else {
            cmd.args.forEach((cmd)=>{
                this.#supportedFeatures.add(cmd);
            });
        }
        if (this.#supportedFeatures.has("STARTTLS") && !this.config.debug.noStartTLS) {
            await this.#connection.writeCmd("STARTTLS");
            this.#connection.assertCode(await this.#connection.readCmd(), CommandCode.READY);
            const conn = await Deno.startTls(this.#connection.conn, {
                hostname: this.config.connection.hostname
            });
            this.#connection.setupConnection(conn);
            this.#connection.secure = true;
            await this.#connection.writeCmd("EHLO", this.config.connection.hostname);
            await this.#connection.readCmd();
        }
        if (!this.config.debug.allowUnsecure && !this.#connection.secure) {
            this.#connection.close();
            this.#connection = null;
            throw new Error("Connection is not secure! Don't send authentication over non secure connection!");
        }
        if (this.config.connection.auth) {
            await this.#connection.writeCmd("AUTH", "LOGIN");
            this.#connection.assertCode(await this.#connection.readCmd(), 334);
            await this.#connection.writeCmd(btoa(this.config.connection.auth.username));
            this.#connection.assertCode(await this.#connection.readCmd(), 334);
            await this.#connection.writeCmd(btoa(this.config.connection.auth.password));
            this.#connection.assertCode(await this.#connection.readCmd(), CommandCode.AUTHO_SUCCESS);
        }
        await this.#cleanup();
    }
    #supportedFeatures;
    async #cleanup() {
        this.#connection.writeCmd("NOOP");
        while(true){
            const cmd1 = await this.#connection.readCmd();
            if (cmd1 && cmd1.code === 250) return;
        }
    }
    config;
}
function resolveClientOptions(config) {
    return {
        debug: {
            log: config.debug?.log ?? false,
            allowUnsecure: config.debug?.allowUnsecure ?? false,
            encodeLB: config.debug?.encodeLB ?? false,
            noStartTLS: config.debug?.noStartTLS ?? false
        },
        connection: {
            hostname: config.connection.hostname,
            port: config.connection.port ?? (config.connection.tls ? 465 : 25),
            tls: config.connection.tls ?? false,
            auth: config.connection.auth
        },
        pool: config.pool ? config.pool === true ? {
            size: 2,
            timeout: 60000
        } : {
            size: config.pool.size ?? 2,
            timeout: config.pool.timeout ?? 60000
        } : undefined,
        client: {
            warning: config.client?.warning ?? "log",
            preprocessors: config.client?.preprocessors ?? []
        }
    };
}
const encoder2 = new TextEncoder();
function quotedPrintableEncode(data, encLB = false) {
    data.replaceAll("=", "=3D");
    if (!encLB) {
        data = data.replaceAll(" \r\n", "=20\r\n").replaceAll(" \n", "=20\n");
    }
    const encodedData = Array.from(data).map((ch)=>{
        const encodedChar = encoder2.encode(ch);
        if (encodedChar.length === 1) {
            const code = encodedChar[0];
            if (code >= 32 && code <= 126 && code !== 61) return ch;
            if (!encLB && (code === 10 || code === 13)) return ch;
            if (code === 9) return ch;
        }
        let enc = "";
        encodedChar.forEach((i)=>{
            let c = i.toString(16);
            if (c.length === 1) c = "0" + c;
            enc += `=${c}`;
        });
        return enc;
    }).join("");
    let ret = "";
    const lines = Math.ceil(encodedData.length / 74) - 1;
    let offset = 0;
    for(let i = 0; i < lines; i++){
        let old = encodedData.slice(i * 74 + offset, (i + 1) * 74);
        offset = 0;
        if (old.at(-1) === "=") {
            old = old.slice(0, old.length - 1);
            offset = -1;
        }
        if (old.at(-2) === "=") {
            old = old.slice(0, old.length - 2);
            offset = -2;
        }
        if (old.endsWith("\r") || old.endsWith("\n")) {
            ret += old;
        } else {
            ret += `${old}=\r\n`;
        }
    }
    ret += encodedData.slice(lines * 74);
    return ret;
}
function resolveAttachment(attachment) {
    if (attachment.encoding === "binary") {
        return {
            filename: attachment.filename,
            contentType: attachment.contentType,
            encoding: "base64",
            content: encode3(attachment.content)
        };
    } else {
        return attachment;
    }
}
function resolveContent({ text , html , mimeContent  }) {
    const newContent = [
        ...mimeContent ?? []
    ];
    if (text === "auto" && html) {
        text = html.replace(/<head((.|\n|\r)*?)<\/head>/g, "").replace(/<style((.|\n|\r)*?)<\/style>/g, "").replace(/<[^>]+>/g, "");
    }
    if (text) {
        newContent.push({
            mimeType: 'text/plain; charset="utf-8"',
            content: quotedPrintableEncode(text),
            transferEncoding: "quoted-printable"
        });
    }
    if (html) {
        newContent.push({
            mimeType: 'text/html; charset="utf-8"',
            content: quotedPrintableEncode(html),
            transferEncoding: "quoted-printable"
        });
    }
    return newContent;
}
function isSingleMail(mail) {
    return /^(([^<>()\[\]\\,;:\s@"]+@[a-zA-Z0-9\-]+\.([a-zA-Z0-9\-]+\.)*[a-zA-Z]{2,})|(<[^<>()\[\]\\,;:\s@"]+@[a-zA-Z0-9]+\.([a-zA-Z0-9\-]+\.)*[a-zA-Z]{2,}>)|([^<>]+ <[^<>()\[\]\\,;:\s@"]+@[a-zA-Z0-9]+\.([a-zA-Z0-9\-]+\.)*[a-zA-Z]{2,}>))$/.test(mail);
}
function parseSingleEmail(mail) {
    if (typeof mail !== "string") {
        return {
            mail: mail.mail,
            name: mail.name ?? ""
        };
    }
    const mailSplitRe = /^([^<]*)<([^>]+)>\s*$/;
    const res = mailSplitRe.exec(mail);
    if (!res) {
        return {
            mail,
            name: ""
        };
    }
    const [_, name, email] = res;
    return {
        name: name.trim(),
        mail: email.trim()
    };
}
function parseMailList(list) {
    if (typeof list === "string") return [
        parseSingleEmail(list)
    ];
    if (Array.isArray(list)) return list.map((v)=>parseSingleEmail(v));
    if ("mail" in list) {
        return [
            {
                mail: list.mail,
                name: list.name ?? ""
            }
        ];
    }
    return Object.entries(list).map(([name, mail])=>({
            name,
            mail
        }));
}
function validateEmailList(list) {
    const ok = [];
    const bad = [];
    list.forEach((mail)=>{
        if (isSingleMail(mail.mail)) {
            ok.push(mail);
        } else {
            bad.push(mail);
        }
    });
    return {
        ok,
        bad
    };
}
function validateHeaders(headers) {
    return !(Object.keys(headers).some((v)=>v.includes("\n") || v.includes("\r")) || Object.values(headers).some((v)=>v.includes("\n") || v.includes("\r")));
}
function resolveSendConfig(config) {
    const { to , cc =[] , bcc =[] , from , date =new Date().toUTCString().split(",")[1].slice(1) , subject , content , mimeContent , html , inReplyTo , replyTo , references , priority , attachments , internalTag , headers ,  } = config;
    return {
        to: parseMailList(to),
        cc: parseMailList(cc),
        bcc: parseMailList(bcc),
        from: parseSingleEmail(from),
        date,
        mimeContent: resolveContent({
            mimeContent,
            html,
            text: content
        }),
        replyTo: replyTo ? parseSingleEmail(replyTo) : undefined,
        inReplyTo,
        subject,
        attachments: attachments ? attachments.map((attachment)=>resolveAttachment(attachment)) : [],
        references,
        priority,
        internalTag,
        headers: headers ?? {}
    };
}
function validateConfig(config, client) {
    const errors = [];
    const warn = [];
    if (!isSingleMail(config.from.mail)) {
        errors.push(`The specified from adress is not a valid email adress.`);
    }
    if (config.replyTo && !isSingleMail(config.replyTo.mail)) {
        errors.push(`The specified replyTo adress is not a valid email adress.`);
    }
    const valTo = validateEmailList(config.to);
    if (valTo.bad.length > 0) {
        config.to = valTo.ok;
        valTo.bad.forEach((m)=>{
            warn.push(`TO Email ${m.mail} is not valid!`);
        });
    }
    const valCc = validateEmailList(config.cc);
    if (valCc.bad.length > 0) {
        config.to = valCc.ok;
        valCc.bad.forEach((m)=>{
            warn.push(`CC Email ${m.mail} is not valid!`);
        });
    }
    const valBcc = validateEmailList(config.bcc);
    if (valBcc.bad.length > 0) {
        config.to = valBcc.ok;
        valBcc.bad.forEach((m)=>{
            warn.push(`BCC Email ${m.mail} is not valid!`);
        });
    }
    if (config.to.length + config.cc.length + config.bcc.length === 0) {
        errors.push(`No valid emails provided!`);
    }
    if (config.mimeContent.length === 0) {
        errors.push(`No content provided!`);
    }
    if (!config.mimeContent.some((v)=>v.mimeType.includes("text/html") || v.mimeType.includes("text/plain"))) {
        warn.push("You should provide at least html or text content!");
    }
    if (!validateHeaders(config.headers)) {
        errors.push(`Headers are not allowed to include linebreaks!`);
    }
    if (client.client.warning === "log" && warn.length > 0) {
        console.warn(warn.join("\n"));
    }
    if (client.client.warning === "error") {
        errors.push(...warn);
    }
    if (errors.length > 0) {
        throw new Error(errors.join("\n"));
    }
    return config;
}
class SMTPHandler {
    #internalClient;
    #clientConfig;
    constructor(config){
        const resolvedConfig = resolveClientOptions(config);
        resolvedConfig.client.preprocessors.push(validateConfig);
        this.#clientConfig = resolvedConfig;
        if (resolvedConfig.debug.log) {
            console.log("used resolved config");
            console.log(".debug");
            console.table(resolvedConfig.debug);
            console.log(".connection");
            console.table({
                ...resolvedConfig.connection,
                ...resolvedConfig.connection.auth ? {
                    auth: JSON.stringify(resolvedConfig.connection.auth)
                } : {}
            });
            console.log(".pool");
            console.table(resolvedConfig.pool);
        }
        const Client = resolvedConfig.pool ? resolvedConfig.pool.size > 1 ? SMTPWorkerPool : SMTPWorker : SMTPClient;
        this.#internalClient = new Client(resolvedConfig);
    }
    send(config) {
        let resolvedConfig = resolveSendConfig(config);
        for(let i = 0; i < this.#clientConfig.client.preprocessors.length; i++){
            const cb = this.#clientConfig.client.preprocessors[i];
            resolvedConfig = cb(resolvedConfig, this.#clientConfig);
        }
        return this.#internalClient.send(resolvedConfig);
    }
    close() {
        return this.#internalClient.close();
    }
}
const service7 = new Service();
service7.post(async (msg, _context, config)=>{
    const to = await msg.getParam("to", 0);
    if (!to) return msg.setStatus(400, 'No email address to send to');
    const client = new SMTPHandler({
        connection: {
            hostname: config.host,
            port: config.port,
            auth: {
                username: config.user,
                password: config.password
            }
        }
    });
    const sendConfig = {
        to,
        cc: await msg.getParam("cc"),
        bcc: await msg.getParam("bcc"),
        from: await msg.getParam("from") || config.defaultFrom,
        subject: await msg.getParam("subject"),
        content: await msg.getParam("content"),
        html: await msg.getParam("html"),
        priority: await msg.getParam("priority")
    };
    if (msg.data) {
        const { mimeType  } = msg.data;
        if (mimeType === "text/html") {
            sendConfig.html = await msg.data.asString() || undefined;
        } else if (isText(mimeType)) {
            sendConfig.content = await msg.data.asString() || undefined;
        } else if (!isJson(mimeType)) {
            sendConfig.attachments = [];
            let idx = 0;
            for await (const subMsg of msg.splitData()){
                idx++;
                const content = await subMsg.data.asArrayBuffer();
                if (content) {
                    let ext = getExtension(subMsg.data.mimeType);
                    ext = ext ? '.' + ext : '';
                    sendConfig.attachments.push({
                        encoding: "binary",
                        content,
                        contentType: subMsg.data.mimeType,
                        filename: subMsg.data.filename || `item${idx}${ext}`
                    });
                }
            }
        }
    }
    try {
        await client.send(sendConfig);
    } catch  {
        return msg.setStatus(500, 'There was a problem sending the email via the remote server');
    } finally{
        client.close();
    }
    return msg.setData(null, "").setStatus(201);
});
const __default34 = {
    "name": "Email Service",
    "description": "Send an email optionally with attachments",
    "moduleUrl": "./services/email.ts",
    "apis": [
        "email"
    ],
    "configSchema": {
        "type": "object",
        "properties": {
            "host": {
                "type": "string"
            },
            "port": {
                "type": "number"
            },
            "secure": {
                "type": "boolean"
            },
            "user": {
                "type": "string"
            },
            "password": {
                "type": "string"
            },
            "defaultFrom": {
                "type": "string",
                "description": "From address is not specified"
            }
        },
        "required": [
            "host",
            "port",
            "secure",
            "user",
            "password",
            "defaultFrom"
        ]
    }
};
const __default35 = {
    "name": "Account Service",
    "description": "Provides password reset and email verification",
    "moduleUrl": "./services/account.ts",
    "apis": [
        "account"
    ],
    "configSchema": {
        "type": "object",
        "properties": {
            "userUrlPattern": {
                "type": "string",
                "description": "Url pattern to fetch user data from"
            },
            "emailSendUrlPattern": {
                "type": "string",
                "description": "Url pattern to POST to for sending an email"
            },
            "passwordReset": {
                "type": "object",
                "description": "Config for a function allowing a user to reset their password via emailed tokenised url",
                "properties": {
                    "tokenExpiryMins": {
                        "type": "number"
                    },
                    "returnPageUrl": {
                        "type": "string",
                        "description": "url for page containing a form which posts to the service's token-update-password path"
                    },
                    "emailTemplateUrl": {
                        "type": "string",
                        "description": "url for template to create email sent to user when the service's reset-password path is called"
                    }
                },
                "required": [
                    "returnPageUrl",
                    "emailTemplateUrl"
                ]
            },
            "emailConfirm": {
                "type": "object",
                "description": "Config for a function allowing a user to validate their email via emailed tokenised url",
                "properties": {
                    "tokenExpiryMins": {
                        "type": "number"
                    },
                    "returnPageUrl": {
                        "type": "string",
                        "description": "url for page containing a form which posts to the service's confirm-email path"
                    },
                    "emailTemplateUrl": {
                        "type": "string",
                        "description": "url for template to create email sent to user when the service's verify-email path is called"
                    }
                },
                "required": [
                    "returnPageUrl",
                    "emailTemplateUrl"
                ]
            }
        },
        "required": [
            "userUrlPattern",
            "emailSendUrlPattern"
        ]
    }
};
function ByteArray(n) {
    return new Uint8Array(n);
}
function IntArray(n) {
    return new Int32Array(n);
}
function NumArray(n) {
    return new Float64Array(n);
}
function gf(init) {
    const r = NumArray(16);
    if (init) for(let i = 0; i < init.length; i++)r[i] = init[i];
    return r;
}
ByteArray(16);
const _9 = ByteArray(32);
_9[0] = 9;
const gf0 = gf();
const gf1 = gf([
    1
]);
gf([
    0xdb41,
    1
]);
const D = gf([
    0x78a3,
    0x1359,
    0x4dca,
    0x75eb,
    0xd8ab,
    0x4141,
    0x0a4d,
    0x0070,
    0xe898,
    0x7779,
    0x4079,
    0x8cc7,
    0xfe73,
    0x2b6f,
    0x6cee,
    0x5203
]);
const D2 = gf([
    0xf159,
    0x26b2,
    0x9b94,
    0xebd6,
    0xb156,
    0x8283,
    0x149a,
    0x00e0,
    0xd130,
    0xeef3,
    0x80f2,
    0x198e,
    0xfce7,
    0x56df,
    0xd9dc,
    0x2406
]);
const X = gf([
    0xd51a,
    0x8f25,
    0x2d60,
    0xc956,
    0xa7b2,
    0x9525,
    0xc760,
    0x692c,
    0xdc5c,
    0xfdd6,
    0xe231,
    0xc0a4,
    0x53fe,
    0xcd6e,
    0x36d3,
    0x2169
]);
const Y = gf([
    0x6658,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666
]);
const I = gf([
    0xa0b0,
    0x4a0e,
    0x1b27,
    0xc4ee,
    0xe478,
    0xad2f,
    0x1806,
    0x2f43,
    0xd7a7,
    0x3dfb,
    0x0099,
    0x2b4d,
    0xdf0b,
    0x4fc1,
    0x2480,
    0x2b83
]);
function A(o, a, b) {
    for(let i = 0; i < 16; i++)o[i] = a[i] + b[i];
}
function Z(o, a, b) {
    for(let i = 0; i < 16; i++)o[i] = a[i] - b[i];
}
function M(o, a, b) {
    let v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    v = a[0];
    t0 += v * b0;
    t1 += v * b1;
    t2 += v * b2;
    t3 += v * b3;
    t4 += v * b4;
    t5 += v * b5;
    t6 += v * b6;
    t7 += v * b7;
    t8 += v * b8;
    t9 += v * b9;
    t10 += v * b10;
    t11 += v * b11;
    t12 += v * b12;
    t13 += v * b13;
    t14 += v * b14;
    t15 += v * b15;
    v = a[1];
    t1 += v * b0;
    t2 += v * b1;
    t3 += v * b2;
    t4 += v * b3;
    t5 += v * b4;
    t6 += v * b5;
    t7 += v * b6;
    t8 += v * b7;
    t9 += v * b8;
    t10 += v * b9;
    t11 += v * b10;
    t12 += v * b11;
    t13 += v * b12;
    t14 += v * b13;
    t15 += v * b14;
    t16 += v * b15;
    v = a[2];
    t2 += v * b0;
    t3 += v * b1;
    t4 += v * b2;
    t5 += v * b3;
    t6 += v * b4;
    t7 += v * b5;
    t8 += v * b6;
    t9 += v * b7;
    t10 += v * b8;
    t11 += v * b9;
    t12 += v * b10;
    t13 += v * b11;
    t14 += v * b12;
    t15 += v * b13;
    t16 += v * b14;
    t17 += v * b15;
    v = a[3];
    t3 += v * b0;
    t4 += v * b1;
    t5 += v * b2;
    t6 += v * b3;
    t7 += v * b4;
    t8 += v * b5;
    t9 += v * b6;
    t10 += v * b7;
    t11 += v * b8;
    t12 += v * b9;
    t13 += v * b10;
    t14 += v * b11;
    t15 += v * b12;
    t16 += v * b13;
    t17 += v * b14;
    t18 += v * b15;
    v = a[4];
    t4 += v * b0;
    t5 += v * b1;
    t6 += v * b2;
    t7 += v * b3;
    t8 += v * b4;
    t9 += v * b5;
    t10 += v * b6;
    t11 += v * b7;
    t12 += v * b8;
    t13 += v * b9;
    t14 += v * b10;
    t15 += v * b11;
    t16 += v * b12;
    t17 += v * b13;
    t18 += v * b14;
    t19 += v * b15;
    v = a[5];
    t5 += v * b0;
    t6 += v * b1;
    t7 += v * b2;
    t8 += v * b3;
    t9 += v * b4;
    t10 += v * b5;
    t11 += v * b6;
    t12 += v * b7;
    t13 += v * b8;
    t14 += v * b9;
    t15 += v * b10;
    t16 += v * b11;
    t17 += v * b12;
    t18 += v * b13;
    t19 += v * b14;
    t20 += v * b15;
    v = a[6];
    t6 += v * b0;
    t7 += v * b1;
    t8 += v * b2;
    t9 += v * b3;
    t10 += v * b4;
    t11 += v * b5;
    t12 += v * b6;
    t13 += v * b7;
    t14 += v * b8;
    t15 += v * b9;
    t16 += v * b10;
    t17 += v * b11;
    t18 += v * b12;
    t19 += v * b13;
    t20 += v * b14;
    t21 += v * b15;
    v = a[7];
    t7 += v * b0;
    t8 += v * b1;
    t9 += v * b2;
    t10 += v * b3;
    t11 += v * b4;
    t12 += v * b5;
    t13 += v * b6;
    t14 += v * b7;
    t15 += v * b8;
    t16 += v * b9;
    t17 += v * b10;
    t18 += v * b11;
    t19 += v * b12;
    t20 += v * b13;
    t21 += v * b14;
    t22 += v * b15;
    v = a[8];
    t8 += v * b0;
    t9 += v * b1;
    t10 += v * b2;
    t11 += v * b3;
    t12 += v * b4;
    t13 += v * b5;
    t14 += v * b6;
    t15 += v * b7;
    t16 += v * b8;
    t17 += v * b9;
    t18 += v * b10;
    t19 += v * b11;
    t20 += v * b12;
    t21 += v * b13;
    t22 += v * b14;
    t23 += v * b15;
    v = a[9];
    t9 += v * b0;
    t10 += v * b1;
    t11 += v * b2;
    t12 += v * b3;
    t13 += v * b4;
    t14 += v * b5;
    t15 += v * b6;
    t16 += v * b7;
    t17 += v * b8;
    t18 += v * b9;
    t19 += v * b10;
    t20 += v * b11;
    t21 += v * b12;
    t22 += v * b13;
    t23 += v * b14;
    t24 += v * b15;
    v = a[10];
    t10 += v * b0;
    t11 += v * b1;
    t12 += v * b2;
    t13 += v * b3;
    t14 += v * b4;
    t15 += v * b5;
    t16 += v * b6;
    t17 += v * b7;
    t18 += v * b8;
    t19 += v * b9;
    t20 += v * b10;
    t21 += v * b11;
    t22 += v * b12;
    t23 += v * b13;
    t24 += v * b14;
    t25 += v * b15;
    v = a[11];
    t11 += v * b0;
    t12 += v * b1;
    t13 += v * b2;
    t14 += v * b3;
    t15 += v * b4;
    t16 += v * b5;
    t17 += v * b6;
    t18 += v * b7;
    t19 += v * b8;
    t20 += v * b9;
    t21 += v * b10;
    t22 += v * b11;
    t23 += v * b12;
    t24 += v * b13;
    t25 += v * b14;
    t26 += v * b15;
    v = a[12];
    t12 += v * b0;
    t13 += v * b1;
    t14 += v * b2;
    t15 += v * b3;
    t16 += v * b4;
    t17 += v * b5;
    t18 += v * b6;
    t19 += v * b7;
    t20 += v * b8;
    t21 += v * b9;
    t22 += v * b10;
    t23 += v * b11;
    t24 += v * b12;
    t25 += v * b13;
    t26 += v * b14;
    t27 += v * b15;
    v = a[13];
    t13 += v * b0;
    t14 += v * b1;
    t15 += v * b2;
    t16 += v * b3;
    t17 += v * b4;
    t18 += v * b5;
    t19 += v * b6;
    t20 += v * b7;
    t21 += v * b8;
    t22 += v * b9;
    t23 += v * b10;
    t24 += v * b11;
    t25 += v * b12;
    t26 += v * b13;
    t27 += v * b14;
    t28 += v * b15;
    v = a[14];
    t14 += v * b0;
    t15 += v * b1;
    t16 += v * b2;
    t17 += v * b3;
    t18 += v * b4;
    t19 += v * b5;
    t20 += v * b6;
    t21 += v * b7;
    t22 += v * b8;
    t23 += v * b9;
    t24 += v * b10;
    t25 += v * b11;
    t26 += v * b12;
    t27 += v * b13;
    t28 += v * b14;
    t29 += v * b15;
    v = a[15];
    t15 += v * b0;
    t16 += v * b1;
    t17 += v * b2;
    t18 += v * b3;
    t19 += v * b4;
    t20 += v * b5;
    t21 += v * b6;
    t22 += v * b7;
    t23 += v * b8;
    t24 += v * b9;
    t25 += v * b10;
    t26 += v * b11;
    t27 += v * b12;
    t28 += v * b13;
    t29 += v * b14;
    t30 += v * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    o[0] = t0;
    o[1] = t1;
    o[2] = t2;
    o[3] = t3;
    o[4] = t4;
    o[5] = t5;
    o[6] = t6;
    o[7] = t7;
    o[8] = t8;
    o[9] = t9;
    o[10] = t10;
    o[11] = t11;
    o[12] = t12;
    o[13] = t13;
    o[14] = t14;
    o[15] = t15;
}
function S(o, a) {
    M(o, a, a);
}
ByteArray([
    101,
    120,
    112,
    97,
    110,
    100,
    32,
    51,
    50,
    45,
    98,
    121,
    116,
    101,
    32,
    107
]);
function vn(x, xi, y, yi, n) {
    let i, d = 0;
    for(i = 0; i < n; i++)d |= x[xi + i] ^ y[yi + i];
    return (1 & d - 1 >>> 8) - 1;
}
var SecretBoxLength;
(function(SecretBoxLength) {
    SecretBoxLength[SecretBoxLength["Key"] = 32] = "Key";
    SecretBoxLength[SecretBoxLength["Nonce"] = 24] = "Nonce";
    SecretBoxLength[SecretBoxLength["Overhead"] = 16] = "Overhead";
    SecretBoxLength[SecretBoxLength["Zero"] = 32] = "Zero";
})(SecretBoxLength || (SecretBoxLength = {}));
var BoxLength;
var ScalarLength;
function set25519(r, a) {
    for(let i = 0; i < 16; i++)r[i] = a[i] | 0;
}
function _verify_32(x, xi, y, yi) {
    return vn(x, xi, y, yi, 32);
}
(function(BoxLength) {
    BoxLength[BoxLength["PublicKey"] = 32] = "PublicKey";
    BoxLength[BoxLength["SecretKey"] = 32] = "SecretKey";
    BoxLength[BoxLength["SharedKey"] = 32] = "SharedKey";
    BoxLength[BoxLength["Nonce"] = SecretBoxLength.Nonce] = "Nonce";
    BoxLength[BoxLength["Overhead"] = SecretBoxLength.Overhead] = "Overhead";
})(BoxLength || (BoxLength = {}));
function checkArrayTypes(...arrays) {
    for (const array of arrays){
        if (!(array instanceof Uint8Array)) {
            throw new TypeError('unexpected type, use ByteArray');
        }
    }
}
(function(ScalarLength) {
    ScalarLength[ScalarLength["Scalar"] = 32] = "Scalar";
    ScalarLength[ScalarLength["GroupElement"] = 32] = "GroupElement";
})(ScalarLength || (ScalarLength = {}));
function car25519(o) {
    let i, v, c = 1;
    for(i = 0; i < 16; i++){
        v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
    }
    o[0] += c - 1 + 37 * (c - 1);
}
function sel25519(p, q, b) {
    let t, c = ~(b - 1);
    for(let i = 0; i < 16; i++){
        t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
    }
}
function pack25519(o, n) {
    const m = gf(), t = gf();
    let i, j, b;
    for(i = 0; i < 16; i++)t[i] = n[i];
    car25519(t);
    car25519(t);
    car25519(t);
    for(j = 0; j < 2; j++){
        m[0] = t[0] - 0xffed;
        for(i = 1; i < 15; i++){
            m[i] = t[i] - 0xffff - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 0xffff;
        }
        m[15] = t[15] - 0x7fff - (m[14] >> 16 & 1);
        b = m[15] >> 16 & 1;
        m[14] &= 0xffff;
        sel25519(t, m, 1 - b);
    }
    for(i = 0; i < 16; i++){
        o[2 * i] = t[i] & 0xff;
        o[2 * i + 1] = t[i] >> 8;
    }
}
function neq25519(a, b) {
    const c = ByteArray(32), d = ByteArray(32);
    pack25519(c, a);
    pack25519(d, b);
    return _verify_32(c, 0, d, 0);
}
function par25519(a) {
    const d = ByteArray(32);
    pack25519(d, a);
    return d[0] & 1;
}
function unpack25519(o, n) {
    for(let i = 0; i < 16; i++)o[i] = n[2 * i] + (n[2 * i + 1] << 8);
    o[15] &= 0x7fff;
}
function inv25519(o, i) {
    const c = gf();
    let a;
    for(a = 0; a < 16; a++)c[a] = i[a];
    for(a = 253; a >= 0; a--){
        S(c, c);
        if (a !== 2 && a !== 4) M(c, c, i);
    }
    for(a = 0; a < 16; a++)o[a] = c[a];
}
var HashLength;
(function(HashLength) {
    HashLength[HashLength["Hash"] = 64] = "Hash";
})(HashLength || (HashLength = {}));
function _hash(out, m, n) {
    const hh = IntArray(8), hl = IntArray(8), x = ByteArray(256);
    let i, b = n;
    hh[0] = 0x6a09e667;
    hh[1] = 0xbb67ae85;
    hh[2] = 0x3c6ef372;
    hh[3] = 0xa54ff53a;
    hh[4] = 0x510e527f;
    hh[5] = 0x9b05688c;
    hh[6] = 0x1f83d9ab;
    hh[7] = 0x5be0cd19;
    hl[0] = 0xf3bcc908;
    hl[1] = 0x84caa73b;
    hl[2] = 0xfe94f82b;
    hl[3] = 0x5f1d36f1;
    hl[4] = 0xade682d1;
    hl[5] = 0x2b3e6c1f;
    hl[6] = 0xfb41bd6b;
    hl[7] = 0x137e2179;
    _hashblocks_hl(hh, hl, m, n);
    n %= 128;
    for(i = 0; i < n; i++)x[i] = m[b - n + i];
    x[n] = 128;
    n = 256 - 128 * (n < 112 ? 1 : 0);
    x[n - 9] = 0;
    _ts64(x, n - 8, b / 0x20000000 | 0, b << 3);
    _hashblocks_hl(hh, hl, x, n);
    for(i = 0; i < 8; i++)_ts64(out, 8 * i, hh[i], hl[i]);
    return 0;
}
const _K = [
    0x428a2f98,
    0xd728ae22,
    0x71374491,
    0x23ef65cd,
    0xb5c0fbcf,
    0xec4d3b2f,
    0xe9b5dba5,
    0x8189dbbc,
    0x3956c25b,
    0xf348b538,
    0x59f111f1,
    0xb605d019,
    0x923f82a4,
    0xaf194f9b,
    0xab1c5ed5,
    0xda6d8118,
    0xd807aa98,
    0xa3030242,
    0x12835b01,
    0x45706fbe,
    0x243185be,
    0x4ee4b28c,
    0x550c7dc3,
    0xd5ffb4e2,
    0x72be5d74,
    0xf27b896f,
    0x80deb1fe,
    0x3b1696b1,
    0x9bdc06a7,
    0x25c71235,
    0xc19bf174,
    0xcf692694,
    0xe49b69c1,
    0x9ef14ad2,
    0xefbe4786,
    0x384f25e3,
    0x0fc19dc6,
    0x8b8cd5b5,
    0x240ca1cc,
    0x77ac9c65,
    0x2de92c6f,
    0x592b0275,
    0x4a7484aa,
    0x6ea6e483,
    0x5cb0a9dc,
    0xbd41fbd4,
    0x76f988da,
    0x831153b5,
    0x983e5152,
    0xee66dfab,
    0xa831c66d,
    0x2db43210,
    0xb00327c8,
    0x98fb213f,
    0xbf597fc7,
    0xbeef0ee4,
    0xc6e00bf3,
    0x3da88fc2,
    0xd5a79147,
    0x930aa725,
    0x06ca6351,
    0xe003826f,
    0x14292967,
    0x0a0e6e70,
    0x27b70a85,
    0x46d22ffc,
    0x2e1b2138,
    0x5c26c926,
    0x4d2c6dfc,
    0x5ac42aed,
    0x53380d13,
    0x9d95b3df,
    0x650a7354,
    0x8baf63de,
    0x766a0abb,
    0x3c77b2a8,
    0x81c2c92e,
    0x47edaee6,
    0x92722c85,
    0x1482353b,
    0xa2bfe8a1,
    0x4cf10364,
    0xa81a664b,
    0xbc423001,
    0xc24b8b70,
    0xd0f89791,
    0xc76c51a3,
    0x0654be30,
    0xd192e819,
    0xd6ef5218,
    0xd6990624,
    0x5565a910,
    0xf40e3585,
    0x5771202a,
    0x106aa070,
    0x32bbd1b8,
    0x19a4c116,
    0xb8d2d0c8,
    0x1e376c08,
    0x5141ab53,
    0x2748774c,
    0xdf8eeb99,
    0x34b0bcb5,
    0xe19b48a8,
    0x391c0cb3,
    0xc5c95a63,
    0x4ed8aa4a,
    0xe3418acb,
    0x5b9cca4f,
    0x7763e373,
    0x682e6ff3,
    0xd6b2b8a3,
    0x748f82ee,
    0x5defb2fc,
    0x78a5636f,
    0x43172f60,
    0x84c87814,
    0xa1f0ab72,
    0x8cc70208,
    0x1a6439ec,
    0x90befffa,
    0x23631e28,
    0xa4506ceb,
    0xde82bde9,
    0xbef9a3f7,
    0xb2c67915,
    0xc67178f2,
    0xe372532b,
    0xca273ece,
    0xea26619c,
    0xd186b8c7,
    0x21c0c207,
    0xeada7dd6,
    0xcde0eb1e,
    0xf57d4f7f,
    0xee6ed178,
    0x06f067aa,
    0x72176fba,
    0x0a637dc5,
    0xa2c898a6,
    0x113f9804,
    0xbef90dae,
    0x1b710b35,
    0x131c471b,
    0x28db77f5,
    0x23047d84,
    0x32caab7b,
    0x40c72493,
    0x3c9ebe0a,
    0x15c9bebc,
    0x431d67c4,
    0x9c100d4c,
    0x4cc5d4be,
    0xcb3e42b6,
    0x597f299c,
    0xfc657e2a,
    0x5fcb6fab,
    0x3ad6faec,
    0x6c44198c,
    0x4a475817
];
function _hashblocks_hl(hh, hl, m, n) {
    const wh = IntArray(16), wl = IntArray(16);
    let bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
    let ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
    let pos = 0;
    while(n >= 128){
        for(i = 0; i < 16; i++){
            j = 8 * i + pos;
            wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
        }
        for(i = 0; i < 80; i++){
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            h = _K[i * 2];
            l = _K[i * 2 + 1];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 0xffff | d << 16;
            tl = a & 0xffff | b << 16;
            h = th;
            l = tl;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 0xffff | d << 16;
            bl7 = a & 0xffff | b << 16;
            h = bh3;
            l = bl3;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 0xffff | d << 16;
            bl3 = a & 0xffff | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
                for(j = 0; j < 16; j++){
                    h = wh[j];
                    l = wl[j];
                    a = l & 0xffff;
                    b = l >>> 16;
                    c = h & 0xffff;
                    d = h >>> 16;
                    h = wh[(j + 9) % 16];
                    l = wl[(j + 9) % 16];
                    a += l & 0xffff;
                    b += l >>> 16;
                    c += h & 0xffff;
                    d += h >>> 16;
                    th = wh[(j + 1) % 16];
                    tl = wl[(j + 1) % 16];
                    h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                    l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                    a += l & 0xffff;
                    b += l >>> 16;
                    c += h & 0xffff;
                    d += h >>> 16;
                    th = wh[(j + 14) % 16];
                    tl = wl[(j + 14) % 16];
                    h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                    l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                    a += l & 0xffff;
                    b += l >>> 16;
                    c += h & 0xffff;
                    d += h >>> 16;
                    b += a >>> 16;
                    c += b >>> 16;
                    d += c >>> 16;
                    wh[j] = c & 0xffff | d << 16;
                    wl[j] = a & 0xffff | b << 16;
                }
            }
        }
        h = ah0;
        l = al0;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[0];
        l = hl[0];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[0] = ah0 = c & 0xffff | d << 16;
        hl[0] = al0 = a & 0xffff | b << 16;
        h = ah1;
        l = al1;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[1];
        l = hl[1];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[1] = ah1 = c & 0xffff | d << 16;
        hl[1] = al1 = a & 0xffff | b << 16;
        h = ah2;
        l = al2;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[2];
        l = hl[2];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[2] = ah2 = c & 0xffff | d << 16;
        hl[2] = al2 = a & 0xffff | b << 16;
        h = ah3;
        l = al3;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[3];
        l = hl[3];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[3] = ah3 = c & 0xffff | d << 16;
        hl[3] = al3 = a & 0xffff | b << 16;
        h = ah4;
        l = al4;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[4];
        l = hl[4];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[4] = ah4 = c & 0xffff | d << 16;
        hl[4] = al4 = a & 0xffff | b << 16;
        h = ah5;
        l = al5;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[5];
        l = hl[5];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[5] = ah5 = c & 0xffff | d << 16;
        hl[5] = al5 = a & 0xffff | b << 16;
        h = ah6;
        l = al6;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[6];
        l = hl[6];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[6] = ah6 = c & 0xffff | d << 16;
        hl[6] = al6 = a & 0xffff | b << 16;
        h = ah7;
        l = al7;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[7];
        l = hl[7];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[7] = ah7 = c & 0xffff | d << 16;
        hl[7] = al7 = a & 0xffff | b << 16;
        pos += 128;
        n -= 128;
    }
    return n;
}
function _ts64(x, i, h, l) {
    x[i] = h >> 24 & 0xff;
    x[i + 1] = h >> 16 & 0xff;
    x[i + 2] = h >> 8 & 0xff;
    x[i + 3] = h & 0xff;
    x[i + 4] = l >> 24 & 0xff;
    x[i + 5] = l >> 16 & 0xff;
    x[i + 6] = l >> 8 & 0xff;
    x[i + 7] = l & 0xff;
}
var SignLength;
(function(SignLength) {
    SignLength[SignLength["PublicKey"] = 32] = "PublicKey";
    SignLength[SignLength["SecretKey"] = 64] = "SecretKey";
    SignLength[SignLength["Seed"] = 32] = "Seed";
    SignLength[SignLength["Signature"] = 64] = "Signature";
})(SignLength || (SignLength = {}));
function sign_detached_verify(msg, sig, publicKey) {
    checkArrayTypes(msg, sig, publicKey);
    if (sig.length !== 64) throw new Error('bad signature size');
    if (publicKey.length !== 32) throw new Error('bad public key size');
    const sm = ByteArray(64 + msg.length);
    const m = ByteArray(64 + msg.length);
    let i;
    for(i = 0; i < 64; i++)sm[i] = sig[i];
    for(i = 0; i < msg.length; i++)sm[i + SignLength.Signature] = msg[i];
    return _sign_open(m, sm, sm.length, publicKey) >= 0;
}
function _sign_open(m, sm, n, pk) {
    const t = ByteArray(32), h = ByteArray(64);
    const p = [
        gf(),
        gf(),
        gf(),
        gf()
    ], q = [
        gf(),
        gf(),
        gf(),
        gf()
    ];
    let i, mlen;
    mlen = -1;
    if (n < 64 || unpackneg(q, pk)) return -1;
    for(i = 0; i < n; i++)m[i] = sm[i];
    for(i = 0; i < 32; i++)m[i + 32] = pk[i];
    _hash(h, m, n);
    reduce(h);
    scalarmult(p, q, h);
    scalarbase(q, sm.subarray(32));
    add(p, q);
    pack(t, p);
    n -= 64;
    if (_verify_32(sm, 0, t, 0)) {
        for(i = 0; i < n; i++)m[i] = 0;
        return -1;
    }
    for(i = 0; i < n; i++)m[i] = sm[i + 64];
    mlen = n;
    return mlen;
}
function scalarbase(p, s) {
    const q = [
        gf(),
        gf(),
        gf(),
        gf()
    ];
    set25519(q[0], X);
    set25519(q[1], Y);
    set25519(q[2], gf1);
    M(q[3], X, Y);
    scalarmult(p, q, s);
}
function scalarmult(p, q, s) {
    let b, i;
    set25519(p[0], gf0);
    set25519(p[1], gf1);
    set25519(p[2], gf1);
    set25519(p[3], gf0);
    for(i = 255; i >= 0; --i){
        b = s[i / 8 | 0] >> (i & 7) & 1;
        cswap(p, q, b);
        add(q, p);
        add(p, p);
        cswap(p, q, b);
    }
}
function pack(r, p) {
    const tx = gf(), ty = gf(), zi = gf();
    inv25519(zi, p[2]);
    M(tx, p[0], zi);
    M(ty, p[1], zi);
    pack25519(r, ty);
    r[31] ^= par25519(tx) << 7;
}
function unpackneg(r, p) {
    const t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
    set25519(r[2], gf1);
    unpack25519(r[1], p);
    S(num, r[1]);
    M(den, num, D);
    Z(num, num, r[2]);
    A(den, r[2], den);
    S(den2, den);
    S(den4, den2);
    M(den6, den4, den2);
    M(t, den6, num);
    M(t, t, den);
    pow2523(t, t);
    M(t, t, num);
    M(t, t, den);
    M(t, t, den);
    M(r[0], t, den);
    S(chk, r[0]);
    M(chk, chk, den);
    if (neq25519(chk, num)) M(r[0], r[0], I);
    S(chk, r[0]);
    M(chk, chk, den);
    if (neq25519(chk, num)) return -1;
    if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
    M(r[3], r[0], r[1]);
    return 0;
}
function reduce(r) {
    const x = NumArray(64);
    let i;
    for(i = 0; i < 64; i++)x[i] = r[i];
    for(i = 0; i < 64; i++)r[i] = 0;
    modL(r, x);
}
const L = NumArray([
    0xed,
    0xd3,
    0xf5,
    0x5c,
    0x1a,
    0x63,
    0x12,
    0x58,
    0xd6,
    0x9c,
    0xf7,
    0xa2,
    0xde,
    0xf9,
    0xde,
    0x14,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0x10
]);
function modL(r, x) {
    let carry, i, j, k;
    for(i = 63; i >= 32; --i){
        carry = 0;
        for(j = i - 32, k = i - 12; j < k; ++j){
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = x[j] + 128 >> 8;
            x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
    }
    carry = 0;
    for(j = 0; j < 32; j++){
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
    }
    for(j = 0; j < 32; j++)x[j] -= carry * L[j];
    for(i = 0; i < 32; i++){
        x[i + 1] += x[i] >> 8;
        r[i] = x[i] & 255;
    }
}
function add(p, q) {
    const a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
    Z(a, p[1], p[0]);
    Z(t, q[1], q[0]);
    M(a, a, t);
    A(b, p[0], p[1]);
    A(t, q[0], q[1]);
    M(b, b, t);
    M(c, p[3], q[3]);
    M(c, c, D2);
    M(d, p[2], q[2]);
    A(d, d, d);
    Z(e, b, a);
    Z(f, d, c);
    A(g, d, c);
    A(h, b, a);
    M(p[0], e, f);
    M(p[1], h, g);
    M(p[2], g, f);
    M(p[3], e, h);
}
function cswap(p, q, b) {
    for(let i = 0; i < 4; i++){
        sel25519(p[i], q[i], b);
    }
}
function pow2523(o, i) {
    const c = gf();
    let a;
    for(a = 0; a < 16; a++)c[a] = i[a];
    for(a = 250; a >= 0; a--){
        S(c, c);
        if (a !== 1) M(c, c, i);
    }
    for(a = 0; a < 16; a++)o[a] = c[a];
}
const applyMapUrl = (mapUrl, msg, config, createTest, createMapUrl)=>{
    if (createTest && createMapUrl) {
        if (createTest(msg)) mapUrl = createMapUrl;
    }
    if (typeof mapUrl === 'string') {
        return [
            resolvePathPatternWithUrl(mapUrl, msg.url, config),
            msg.method
        ];
    } else {
        const mappedUrl = mapUrl(msg);
        if (typeof mappedUrl === 'string') return msg.setStatus(400, mappedUrl);
        const [url, method] = mappedUrl;
        return [
            resolvePathPatternWithUrl(url, msg.url, config),
            method
        ];
    }
};
const applyTransform = async (transform, resp, config)=>{
    if (!resp.ok || !resp.data) return resp;
    const json = await resp.data.asJson();
    if (transform) {
        if (typeof transform == "function") {
            return transform(json, resp, config);
        } else {
            try {
                return transformation(transform, {
                    json,
                    config,
                    resp
                }, resp.url);
            } catch (err) {
                if (err instanceof SyntaxError) {
                    const errx = err;
                    return resp.setStatus(400, `${errx.message} at: ${errx.filename} cause: ${errx.cause}`);
                }
            }
        }
    } else {
        return await resp.data.asJson();
    }
};
const schemaInstanceMime = (url)=>{
    const schemaUrl = pathCombine(url.baseUrl(), upToLast(url.servicePath, '/'), ".schema.json");
    return `application/json; schema="${schemaUrl}"`;
};
const buildDefaultDirectory = ({ basePath , service  })=>{
    service.getDirectoryPath(basePath, (msg)=>{
        const dirJson = {
            path: msg.url.servicePath,
            paths: service.pathsAt(basePath),
            spec: {
                pattern: "view",
                respMimeType: "text/plain"
            }
        };
        msg.setDataJson(dirJson);
        msg.data.setIsDirectory();
        return Promise.resolve(msg);
    });
};
const buildStore = ({ basePath , service , schema , mapUrlRead , mapUrlWrite , mapUrlDelete , createTest , mapUrlCreate , mapUrlDirectoryRead , mapUrlDirectoryDelete , transformDirectory , transformRead , transformWrite  })=>{
    service.getDirectoryPath(basePath, async (msg, context, config)=>{
        if (!mapUrlDirectoryRead) return msg.setStatus(500, 'No mapping for directory read configured when building store');
        const transformedUrl = applyMapUrl(mapUrlDirectoryRead, msg, config);
        if (transformedUrl instanceof Message) return transformedUrl;
        const [url, method] = transformedUrl;
        const reqMsg = new Message(url, context.tenant, method, msg);
        reqMsg.startSpan();
        const dirResp = await context.makeProxyRequest(reqMsg);
        const dirJson = await applyTransform(transformDirectory, dirResp, config);
        if (dirJson instanceof Message) return dirJson;
        dirJson.path = msg.url.servicePath;
        const dirPath = pathCombine(basePath, msg.url.servicePath);
        dirJson.paths.push(...service.pathsAt(dirPath));
        dirJson.spec = {
            pattern: "store",
            storeMimeTypes: [
                schemaInstanceMime(msg.url)
            ],
            createDirectory: false,
            createFiles: true,
            exceptionMimeTypes: {
                "/.schema.json": [
                    "application/schema+json",
                    ""
                ]
            }
        };
        msg.setDataJson(dirJson);
        msg.data.setIsDirectory();
        return msg;
    });
    const mapPath = (mapUrl, transformRead, transformWrite, createTest, mapUrlCreate)=>async (msg, context, config)=>{
            if (msg.url.resourceName === ".schema.json" && msg.method === "GET") {
                return msg.setDataJson(schema, "application/schema+json");
            }
            const mappedUrl = applyMapUrl(mapUrl, msg, config, createTest, mapUrlCreate);
            if (mappedUrl instanceof Message) return mappedUrl;
            const [url, method] = mappedUrl;
            const reqMsg = new Message(url, context.tenant, method, msg);
            reqMsg.startSpan();
            if (msg.method === "PUT" || msg.method === "POST") {
                if (!msg.data) return msg.setStatus(400, "No body in write operation");
                if (transformWrite) {
                    let writeJson = await msg.data.asJson();
                    writeJson = transformation(transformWrite, writeJson, msg.url);
                    reqMsg.setDataJson(writeJson, "application/json");
                } else {
                    reqMsg.setData(msg.data.data, msg.data.mimeType);
                }
            }
            const resp = await context.makeProxyRequest(reqMsg);
            if (!resp.ok) {
                await resp.data?.ensureDataIsArrayBuffer();
                return resp;
            }
            if (msg.method === "GET") {
                if (!resp.data) return resp.setStatus(400, "No body in GET response");
                if (transformRead) {
                    const json = await applyTransform(transformRead, resp, config);
                    if (json instanceof Message) return json;
                    resp.setDataJson(json, "application/json");
                } else {
                    const mimeType = schemaInstanceMime(msg.url);
                    resp.data.setMimeType(mimeType);
                }
            } else {
                resp.data = undefined;
            }
            return resp;
        };
    if (mapUrlRead) service.getPath(basePath, mapPath(mapUrlRead, transformRead, undefined));
    if (mapUrlWrite) service.putPath(basePath, mapPath(mapUrlWrite, undefined, transformWrite, createTest, mapUrlCreate));
    if (mapUrlDelete) service.deletePath(basePath, mapPath(mapUrlDelete, undefined, undefined));
    if (mapUrlDirectoryDelete) service.deleteDirectoryPath(basePath, mapPath(mapUrlDirectoryDelete, undefined, undefined));
};
const intentsNumber = (intents)=>{
    const intentValues = {
        "GUILDS": 1 << 0,
        "GUILD_MEMBERS": 1 << 1,
        "GUILD_BANS": 1 << 2,
        "GUILD_EMOJIS_AND_STICKERS": 1 << 3,
        "GUILD_INTEGRATIONS": 1 << 4,
        "GUILD_WEBHOOKS": 1 << 5,
        "GUILD_INVITES": 1 << 6,
        "GUILD_VOICE_STATES": 1 << 7,
        "GUILD_PRESENCES": 1 << 8,
        "GUILD_MESSAGES": 1 << 9,
        "GUILD_MESSAGE_REACTIONS": 1 << 10,
        "GUILD_MESSAGE_TYPING": 1 << 11,
        "DIRECT_MESSAGES": 1 << 12,
        "DIRECT_MESSAGE_REACTIONS": 1 << 13,
        "DIRECT_MESSAGE_TYPING": 1 << 14,
        "MESSAGE_CONTENT": 1 << 15,
        "GUILD_SCHEDULED_EVENTS": 1 << 16,
        "AUTO_MODERATED_CONFIGURATION": 1 << 20,
        "AUTO_MODERATED_EXECUTION": 1 << 21
    };
    return intents.reduce((p, c)=>p += intentValues[c], 0);
};
var Op;
(function(Op) {
    Op[Op["Event"] = 0] = "Event";
    Op[Op["Heartbeat"] = 1] = "Heartbeat";
    Op[Op["Identify"] = 2] = "Identify";
    Op[Op["Hello"] = 10] = "Hello";
    Op[Op["HeartbeatAck"] = 11] = "HeartbeatAck";
})(Op || (Op = {}));
const messageToInteractionResponse = async (msg)=>{
    const intResponse = {
        type: 4
    };
    let intMessage = {};
    if (!(msg.ok && msg.data)) return intResponse;
    switch(msg.data.mimeType){
        case "text/plain":
            {
                intMessage.content = await msg.data.asString() || undefined;
                break;
            }
        case "application/json":
            {
                intMessage = await msg.data.asJson();
                break;
            }
    }
    intResponse.data = intMessage;
    return intResponse;
};
const sendTrigger = async (event, data, triggerUrl, context)=>{
    let respMsg;
    if (triggerUrl) {
        const url = triggerUrl.replace('${name}', data?.data?.name || '').replace('${event}', event);
        context.logger.info(`Discord trigger to ${url} with data ${JSON.stringify(data)}`);
        const reqMsg = new Message(url, context.tenant, "GET", null);
        reqMsg.startSpan(context.traceparent, context.tracestate);
        respMsg = await context.makeRequest(reqMsg);
    } else {
        respMsg = new Message('/', context.tenant, 'GET', null);
        respMsg.startSpan(context.traceparent, context.tracestate);
        respMsg.setStatus(400, "Configuration error in bot: no processor");
    }
    return await messageToInteractionResponse(respMsg);
};
class DiscordState extends BaseStateClass {
    ws = null;
    wsState = "initializing";
    heartbeatInterval;
    intervalId;
    heartbeatAcked = null;
    token;
    receiveIntents = [];
    context;
    sessionId;
    triggerUrl;
    guilds;
    async load(context, config) {
        if (this.ws !== null) return;
        this.ws = "opening";
        this.token = config.proxyAdapterConfig.botToken;
        this.receiveIntents = config.receiveIntents || [];
        this.triggerUrl = config.triggerUrl;
        this.context = context;
        const gatewayLocationMsg = await context.makeProxyRequest(Message.fromSpec("GET /gateway/bot", context.tenant));
        const gatewayInfo = await gatewayLocationMsg.data.asJson();
        console.log(gatewayInfo);
        const ws = new WebSocket(gatewayInfo.url + "?v=10&encoding=json");
        ws.addEventListener('message', (ev)=>this.receive(ev.data));
        ws.addEventListener('close', (ev)=>this.close(ev));
        await new Promise((resolve)=>ws.addEventListener('open', ()=>resolve()));
        if (this.wsState === "closed") {
            ws.close();
        } else {
            this.ws = ws;
        }
    }
    resume() {
        this.context?.logger.info('No heartbeat ack, resuming');
    }
    async receive(dataStr) {
        const data = JSON.parse(dataStr);
        this.context.logger.info("Discord message received: " + dataStr);
        switch(this.wsState){
            case "initializing":
                {
                    if (data.op === Op.Hello) {
                        this.heartbeatInterval = data.d['heartbeat_interval'];
                        this.wsState = "running";
                        const jitter = this.heartbeatInterval * Math.random();
                        let d = null;
                        const sendHeartbeat = ()=>{
                            if (this.ws instanceof WebSocket) {
                                if (this.heartbeatAcked === false) {
                                    this.resume();
                                } else {
                                    try {
                                        this.ws.send(JSON.stringify({
                                            op: Op.Heartbeat,
                                            d
                                        }));
                                        this.context?.logger.info(`Heartbeat send ${d}`);
                                        this.heartbeatAcked = false;
                                        d = d === null ? 0 : d + 1;
                                    } catch (err) {
                                        this.context?.logger.error(`Heartbeat send failed ${err}`);
                                    }
                                }
                            }
                        };
                        setTimeout(()=>{
                            sendHeartbeat();
                            this.intervalId = setInterval(sendHeartbeat, this.heartbeatInterval);
                        }, jitter);
                        if (this.ws instanceof WebSocket) {
                            this.ws.send(JSON.stringify({
                                op: Op.Identify,
                                d: {
                                    token: this.token || '',
                                    intents: intentsNumber(this.receiveIntents),
                                    properties: {
                                        os: "linux",
                                        browser: "restspace",
                                        device: "restspace"
                                    }
                                }
                            }));
                            this.wsState = "identifying";
                        }
                    }
                    break;
                }
            case "identifying":
                {
                    if (data.t === "READY") {
                        const readyEvent = data.d;
                        this.sessionId = readyEvent.session_id;
                        this.guilds = Object.fromEntries(readyEvent.guilds.map((g)=>[
                                g.id,
                                null
                            ]));
                        this.wsState = "running";
                    } else {
                        this.context?.logger.error(`Received wrong event while Identifying: ${JSON.stringify(data)}`);
                    }
                    break;
                }
            case "running":
                await this.handleDiscordMessage(data);
                break;
        }
    }
    close(ev) {
        this.context.logger.warning(`Discord socket closed: ${ev.code} ${ev.reason}`);
        clearInterval(this.intervalId);
    }
    async handleDiscordMessage(data) {
        let resp = null;
        switch(data.op || data.t){
            case Op.HeartbeatAck:
                {
                    this.heartbeatAcked = true;
                    return;
                }
            case "INTERACTION_CREATE":
                {
                    resp = await sendTrigger("interaction", data.d, this.triggerUrl, this.context);
                    break;
                }
            case "MESSAGE_CREATE":
                {
                    await sendTrigger("message", data.d, this.triggerUrl, this.context);
                    break;
                }
            case "GUILD_CREATE":
                {
                    const guild = data.d;
                    const id = guild['id'];
                    this.guilds[id] = {
                        id,
                        botJoined: new Date(guild['joined_at']),
                        memberCount: guild['member_count'],
                        members: guild['members'].map((m)=>({
                                id: m.user.id,
                                username: m.user.username,
                                discriminator: m.user.discriminator,
                                locale: m.user.locale,
                                verified: m.user.verified,
                                email: m.user.email,
                                roles: m.roles,
                                joinedAt: new Date(m.joined_at),
                                pending: m.pending
                            })),
                        channels: guild['channels'].map((c)=>({
                                id: c.id,
                                name: c.name
                            }))
                    };
                    if (this.guilds[id].members.length === 1) this.context.logger.warning(`Guild ${id} has only one member listed on GUILD_CREATE event. Probably need Presence intent enabled in Discord application config and Restspace config for Discord service.`);
                    break;
                }
        }
        if (resp) {
            this.context?.logger.info(`Interaction response: ${JSON.stringify(resp)}`);
            const respMsg = Message.fromSpec(`POST $this /interactions/${data.d.id}/${data.d.token}/callback`, this.context.tenant, undefined, resp);
            const respSent = await this.context.makeProxyRequest(respMsg);
            if (!respSent.ok) {
                const respData = await respSent.data?.asString();
                this.context.logger.error(`Error sending interaction response for command ${data.d.data.name}, ${respSent.status} ${respData}`);
            }
        }
    }
    unload() {
        if (this.ws instanceof WebSocket && this.wsState !== "closed") {
            if (this.intervalId) clearInterval(this.intervalId);
            this.ws.close(1000);
            this.wsState = "closed";
        }
        return Promise.resolve();
    }
}
const service8 = new Service();
service8.initializer(async (context, config)=>{
    await context.state(DiscordState, context, config);
});
const commandSchema = {
    type: "object",
    properties: {
        id: {
            type: "string",
            readOnly: true
        },
        type: {
            type: "number",
            enum: [
                1,
                2,
                3
            ],
            enumText: [
                "Chat Input (slash command)",
                "User (rt click a user)",
                "Message (rt click a message)"
            ]
        },
        name: {
            type: "string",
            description: "Name of the command",
            maxLength: 32
        },
        description: {
            type: "string",
            maxLength: 100
        },
        default_permission: {
            type: "boolean"
        },
        version: {
            type: "string",
            readOnly: true
        },
        options: {
            type: "array",
            items: {
                type: "object",
                properties: {
                    type: {
                        type: "number",
                        enum: [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11
                        ],
                        enumText: [
                            "Subcommand",
                            "Subcommand Group",
                            "String",
                            "Integer",
                            "Boolean",
                            "User",
                            "Channel",
                            "Role",
                            "Mentionable",
                            "Number",
                            "Attachment"
                        ]
                    },
                    name: {
                        type: "string",
                        maxLength: 32
                    },
                    description: {
                        type: "string",
                        maxLength: 100
                    },
                    required: {
                        type: "boolean"
                    },
                    choices: {
                        type: "object",
                        properties: {
                            name: {
                                type: "string"
                            },
                            value: {
                                type: "string"
                            }
                        }
                    },
                    channel_types: {
                        type: "array",
                        items: {
                            type: "number",
                            enum: [
                                0,
                                1,
                                2,
                                3,
                                4,
                                5,
                                6,
                                13
                            ],
                            enumText: [
                                "Guild text",
                                "DM",
                                "Guild voice",
                                "Group DM",
                                "Guild category",
                                "Guild news",
                                "Guild store",
                                "Guild stage voice"
                            ]
                        }
                    },
                    min_value: {
                        type: "number"
                    },
                    max_value: {
                        type: "number"
                    },
                    autocomplete: {
                        type: "boolean"
                    }
                },
                required: [
                    "type",
                    "name",
                    "description"
                ]
            }
        }
    },
    required: [
        "name",
        "description"
    ],
    pathPattern: '${name}|${id}'
};
const verify3 = async (msg, config)=>{
    const signature = msg.getHeader('X-Signature-Ed25519');
    const timestamp = msg.getHeader('X-Signature-Timestamp');
    const body = await msg.data?.asString();
    if (!(signature && timestamp && body)) return false;
    const enc = new TextEncoder();
    const isVerified = sign_detached_verify(enc.encode(timestamp + body), hex2array(signature), hex2array(config.publicKey));
    return isVerified;
};
const snowflakeToTimestamp = (snf)=>{
    const snfi = Number(BigInt(snf) >> 22n);
    return snfi + 1420070400000;
};
service8.postPath("interaction", async (msg, context, config)=>{
    if (!await verify3(msg, config)) {
        console.log('Invalid');
        return msg.setStatus(401, 'invalid request signature');
    }
    const json = await msg.data?.asJson();
    if (json.type === 1) {
        console.log('PING');
        return msg.setDataJson({
            type: 1
        }).setStatus(200);
    }
    const intResp = await sendTrigger("INTERACTION_CREATE", json?.data, config.triggerUrl, context);
    msg.setDataJson(intResp).setStatus(200);
    return msg;
});
service8.getPath("command/.schema.json", (msg)=>Promise.resolve(msg.setDataJson(commandSchema, "application/schema+json")));
const extractId = (msg)=>{
    const id = decodeURIComponent(msg.url.servicePathElements[1]?.replace(/.json$/, '')).split('|')?.[1];
    return id;
};
const transformDirectory = (json)=>{
    const entries = json;
    return {
        paths: entries.map((ent)=>[
                commandSchema.pathPattern.replace("${name}", ent.name).replace("${id}", ent.id),
                snowflakeToTimestamp(ent.version)
            ])
    };
};
const applicationPath = 'applications/${proxyAdapterConfig.applicationId}';
buildStore({
    basePath: "/command/global",
    service: service8,
    schema: commandSchema,
    mapUrlRead: (msg)=>[
            `${applicationPath}/commands/${extractId(msg)}`,
            "GET"
        ],
    mapUrlWrite: (msg)=>[
            `${applicationPath}/commands/${extractId(msg)}`,
            "PATCH"
        ],
    mapUrlDelete: (msg)=>[
            `${applicationPath}/commands/${extractId(msg)}`,
            "DELETE"
        ],
    createTest: (msg)=>!extractId(msg),
    mapUrlCreate: (_)=>[
            `${applicationPath}/commands`,
            "POST"
        ],
    mapUrlDirectoryRead: applicationPath + "/commands",
    transformDirectory
});
buildStore({
    basePath: "/command",
    service: service8,
    schema: commandSchema,
    mapUrlRead: (msg)=>[
            `${applicationPath}/guilds/$>0/commands/${extractId(msg)}`,
            "GET"
        ],
    mapUrlWrite: (msg)=>[
            `${applicationPath}/guilds/$>0/commands/${extractId(msg)}`,
            "PATCH"
        ],
    mapUrlDelete: (msg)=>[
            `${applicationPath}/guilds/$>0/commmands/${extractId(msg)}`,
            "DELETE"
        ],
    createTest: (msg)=>!extractId(msg),
    mapUrlCreate: (_)=>[
            `${applicationPath}/guilds/$>0/commands`,
            "POST"
        ],
    mapUrlDirectoryRead: applicationPath + "/guilds/$>0/commands",
    transformDirectory
});
buildDefaultDirectory({
    basePath: "/",
    service: service8
});
service8.getDirectoryPath("/command/.", (msg, _, config)=>{
    const dir = {
        path: msg.url.servicePath,
        paths: [
            [
                "global/"
            ],
            ...(config.guildIds || []).map((id)=>[
                    id + "/"
                ])
        ],
        spec: {
            pattern: "view",
            respMimeType: "text/plain"
        }
    };
    msg.data = MessageBody.fromObject(dir).setIsDirectory();
    return Promise.resolve(msg);
});
const __default36 = {
    "name": "Discord Service",
    "description": "Manages command creation for Discord",
    "moduleUrl": "./services/discord.ts",
    "apis": [
        "store"
    ],
    "configSchema": {
        "type": "object",
        "properties": {
            "proxyAdapterConfig": {
                "type": "object",
                "properties": {
                    "applicationId": {
                        "type": "string"
                    },
                    "botToken": {
                        "type": "string"
                    }
                },
                "required": [
                    "applicationId",
                    "botToken"
                ]
            },
            "publicKey": {
                "type": "string"
            },
            "guildIds": {
                "type": "array",
                "items": {
                    "type": "string"
                }
            },
            "receiveIntents": {
                "type": "array",
                "items": {
                    "type": "string",
                    "enum": [
                        "GUILDS",
                        "GUILD_MEMBERS",
                        "GUILD_BANS",
                        "GUILD_EMOJIS_AND_STICKERS",
                        "GUILD_INTEGRATIONS",
                        "GUILD_WEBHOOKS",
                        "GUILD_INVITES",
                        "GUILD_VOICE_STATES",
                        "GUILD_PRESENCES",
                        "GUILD_MESSAGES",
                        "GUILD_MESSAGE_REACTIONS",
                        "GUILD_MESSAGE_TYPING",
                        "DIRECT_MESSAGES",
                        "DIRECT_MESSAGE_REACTIONS",
                        "DIRECT_MESSAGE_TYPING",
                        "MESSAGE_CONTENT",
                        "GUILD_SCHEDULED_EVENTS",
                        "AUTO_MODERATED_CONFIGURATION",
                        "AUTO_MODERATED_EXECUTION"
                    ]
                }
            },
            "triggerUrl": {
                "type": "string",
                "description": "Url pattern called when Discord calls the service with an interaction"
            },
            "memberStoreUrl": {
                "type": "string",
                "description": "Url pattern where the service stores member data"
            },
            "messageStoreUrl": {
                "type": "string",
                "description": "Url pattern where the service stores message data"
            }
        },
        "required": [
            "publicKey",
            "proxyAdapterConfig"
        ]
    },
    "proxyAdapterSource": "./adapter/DiscordProxyAdapter.ts"
};
const __default37 = {
    "name": "Temporary access service",
    "description": "Generates a token for temporary access to resources and then gives access",
    "moduleUrl": "./services/temporary-access.ts",
    "apis": [
        "access-token"
    ],
    "configSchema": {
        "type": "object",
        "properties": {
            "acquiredRole": {
                "type": "string",
                "description": "The role which use of the token grants to the request"
            },
            "expirySecs": {
                "type": "number",
                "description": "Number of seconds for which the token is valid"
            }
        }
    }
};
const service9 = new Service();
service9.post(async (msg, context)=>{
    const params = await msg.data?.asJson() ?? {};
    const reqQuery = msg.copy().setMethod("GET");
    const msgQuery = await context.makeRequest(reqQuery);
    if (!msgQuery.ok) return msgQuery;
    let query = await msgQuery.data.asString();
    if (!query) return msg.setStatus(400, 'No query');
    const contextUrl = msg.url.copy();
    contextUrl.setSubpathFromUrl(msgQuery.getHeader('location') || '');
    let error = null;
    query = query.replace(/\$\{([^}]*)\}/gi, (_, p1)=>{
        const quoted = context.adapter.quote(getProp(params, p1.split('.')) || '');
        if (quoted instanceof Error) {
            error = quoted;
            return '';
        } else {
            return quoted;
        }
    });
    if (error === null) {
        query = query.replace(/\$([0-9]+)/gi, (_, p1)=>{
            const idx = parseInt(p1);
            if (idx < (contextUrl.subPathElementCount || 0)) {
                const quoted = context.adapter.quote(contextUrl.subPathElements[idx]);
                if (quoted instanceof Error) {
                    error = quoted;
                    return '';
                } else {
                    return quoted;
                }
            } else {
                return '';
            }
        });
    }
    if (error !== null) return msg.setStatus(400, error.toString());
    context.logger.info(`Query: ${query}`);
    const result = await context.adapter.runQuery(query);
    if (typeof result === 'number') return msg.setStatus(result);
    msg.setDataJson(result);
    return msg;
});
const __default38 = {
    "name": "Query",
    "description": "Stores queries as text files and runs the query in the file parameterised with a POST body to produce the response",
    "moduleUrl": "./services/query.ts",
    "apis": [
        "store-transform"
    ],
    "adapterInterface": "IQueryAdapter",
    "isFilter": true,
    "configSchema": {
        "type": "object",
        "properties": {
            "outputMime": {
                "type": "string"
            },
            "store": {
                "type": "object",
                "description": "Configuration for the template store",
                "properties": {
                    "adapterSource": {
                        "type": "string",
                        "description": "Source url for adapter for query store"
                    },
                    "infraName": {
                        "type": "string",
                        "description": "Infra name for query store"
                    },
                    "adapterConfig": {
                        "type": "object",
                        "properties": {}
                    },
                    "extension": {
                        "type": "string",
                        "description": "Extension for query files"
                    },
                    "parentIfMissing": {
                        "type": "boolean",
                        "description": "Optional flag which for a pipeline on a path, sends all subpaths to that pipeline as well. Default true"
                    }
                },
                "required": [
                    "extension"
                ]
            }
        },
        "required": [
            "outputMime",
            "store"
        ]
    },
    "postPipeline": [
        "if (method !== 'POST') $METHOD store/$*"
    ],
    "privateServices": {
        "store": {
            "name": "'Query Store'",
            "source": "./services/file.rsm.json",
            "access": {
                "readRoles": "access.readRoles",
                "writeRoles": "access.writeRoles"
            },
            "adapterInterface": "IFileAdapter",
            "adapterSource": "store.adapterSource",
            "infraName": "store.infraName",
            "adapterConfig": "store.adapterConfig",
            "extensions": "[ store.extension ]",
            "parentIfMissing": "store.parentIfMissing === false ? false : true"
        }
    }
};
function repeat1(source, count) {
    if (count === 0) {
        return new Uint8Array();
    }
    if (count < 0) {
        throw new RangeError("bytes: negative repeat count");
    } else if (source.length * count / count !== source.length) {
        throw new Error("bytes: repeat count causes overflow");
    }
    const __int = Math.floor(count);
    if (__int !== count) {
        throw new Error("bytes: repeat count must be an integer");
    }
    const nb = new Uint8Array(source.length * count);
    let bp = copy2(source, nb);
    for(; bp < nb.length; bp *= 2){
        copy2(nb.slice(0, bp), nb, bp);
    }
    return nb;
}
function concat1(...buf) {
    let length = 0;
    for (const b of buf){
        length += b.length;
    }
    const output = new Uint8Array(length);
    let index = 0;
    for (const b1 of buf){
        output.set(b1, index);
        index += b1.length;
    }
    return output;
}
function copy2(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
var LogLevels;
(function(LogLevels) {
    LogLevels[LogLevels["NOTSET"] = 0] = "NOTSET";
    LogLevels[LogLevels["DEBUG"] = 10] = "DEBUG";
    LogLevels[LogLevels["INFO"] = 20] = "INFO";
    LogLevels[LogLevels["WARNING"] = 30] = "WARNING";
    LogLevels[LogLevels["ERROR"] = 40] = "ERROR";
    LogLevels[LogLevels["CRITICAL"] = 50] = "CRITICAL";
})(LogLevels || (LogLevels = {}));
Object.keys(LogLevels).filter((key)=>isNaN(Number(key)));
const byLevel = {
    [String(LogLevels.NOTSET)]: "NOTSET",
    [String(LogLevels.DEBUG)]: "DEBUG",
    [String(LogLevels.INFO)]: "INFO",
    [String(LogLevels.WARNING)]: "WARNING",
    [String(LogLevels.ERROR)]: "ERROR",
    [String(LogLevels.CRITICAL)]: "CRITICAL"
};
function getLevelByName(name) {
    switch(name){
        case "NOTSET":
            return LogLevels.NOTSET;
        case "DEBUG":
            return LogLevels.DEBUG;
        case "INFO":
            return LogLevels.INFO;
        case "WARNING":
            return LogLevels.WARNING;
        case "ERROR":
            return LogLevels.ERROR;
        case "CRITICAL":
            return LogLevels.CRITICAL;
        default:
            throw new Error(`no log level found for "${name}"`);
    }
}
function getLevelName(level) {
    const levelName = byLevel[level];
    if (levelName) {
        return levelName;
    }
    throw new Error(`no level name found for level: ${level}`);
}
class LogRecord {
    msg;
    #args;
    #datetime;
    level;
    levelName;
    loggerName;
    constructor(options){
        this.msg = options.msg;
        this.#args = [
            ...options.args
        ];
        this.level = options.level;
        this.loggerName = options.loggerName;
        this.#datetime = new Date();
        this.levelName = getLevelName(options.level);
    }
    get args() {
        return [
            ...this.#args
        ];
    }
    get datetime() {
        return new Date(this.#datetime.getTime());
    }
}
class Logger {
    #level;
    #handlers;
    #loggerName;
    constructor(loggerName, levelName, options = {}){
        this.#loggerName = loggerName;
        this.#level = getLevelByName(levelName);
        this.#handlers = options.handlers || [];
    }
    get level() {
        return this.#level;
    }
    set level(level) {
        this.#level = level;
    }
    get levelName() {
        return getLevelName(this.#level);
    }
    set levelName(levelName) {
        this.#level = getLevelByName(levelName);
    }
    get loggerName() {
        return this.#loggerName;
    }
    set handlers(hndls) {
        this.#handlers = hndls;
    }
    get handlers() {
        return this.#handlers;
    }
    #_log(level, msg, ...args) {
        if (this.level > level) {
            return msg instanceof Function ? undefined : msg;
        }
        let fnResult;
        let logMessage;
        if (msg instanceof Function) {
            fnResult = msg();
            logMessage = this.asString(fnResult);
        } else {
            logMessage = this.asString(msg);
        }
        const record = new LogRecord({
            msg: logMessage,
            args: args,
            level: level,
            loggerName: this.loggerName
        });
        this.#handlers.forEach((handler)=>{
            handler.handle(record);
        });
        return msg instanceof Function ? fnResult : msg;
    }
    asString(data) {
        if (typeof data === "string") {
            return data;
        } else if (data === null || typeof data === "number" || typeof data === "bigint" || typeof data === "boolean" || typeof data === "undefined" || typeof data === "symbol") {
            return String(data);
        } else if (data instanceof Error) {
            return data.stack;
        } else if (typeof data === "object") {
            return JSON.stringify(data);
        }
        return "undefined";
    }
    debug(msg, ...args) {
        return this.#_log(LogLevels.DEBUG, msg, ...args);
    }
    info(msg, ...args) {
        return this.#_log(LogLevels.INFO, msg, ...args);
    }
    warning(msg, ...args) {
        return this.#_log(LogLevels.WARNING, msg, ...args);
    }
    error(msg, ...args) {
        return this.#_log(LogLevels.ERROR, msg, ...args);
    }
    critical(msg, ...args) {
        return this.#_log(LogLevels.CRITICAL, msg, ...args);
    }
}
const { Deno: Deno2  } = globalThis;
const noColor1 = typeof Deno2?.noColor === "boolean" ? Deno2.noColor : true;
let enabled1 = !noColor1;
function code2(open, close) {
    return {
        open: `\x1b[${open.join(";")}m`,
        close: `\x1b[${close}m`,
        regexp: new RegExp(`\\x1b\\[${close}m`, "g")
    };
}
function run1(str, code) {
    return enabled1 ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}` : str;
}
function bold1(str) {
    return run1(str, code2([
        1
    ], 22));
}
function red1(str) {
    return run1(str, code2([
        31
    ], 39));
}
function yellow1(str) {
    return run1(str, code2([
        33
    ], 39));
}
function blue1(str) {
    return run1(str, code2([
        34
    ], 39));
}
new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))", 
].join("|"), "g");
class DenoStdInternalError4 extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert4(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError4(msg);
    }
}
"\r".charCodeAt(0);
"\n".charCodeAt(0);
class AbstractBufBase2 {
    buf;
    usedBufferBytes = 0;
    err = null;
    constructor(buf){
        this.buf = buf;
    }
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriterSync1 extends AbstractBufBase2 {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriterSync1 ? writer : new BufWriterSync1(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w;
    }
    flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p.length){
                nwritten += this.#writer.writeSync(p.subarray(nwritten));
            }
        } catch (e) {
            if (e instanceof Error) {
                this.err = e;
            }
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    writeSync(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = this.#writer.writeSync(data);
                } catch (e) {
                    if (e instanceof Error) {
                        this.err = e;
                    }
                    throw e;
                }
            } else {
                numBytesWritten = copy2(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy2(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
const DEFAULT_FORMATTER = "{levelName} {msg}";
class BaseHandler {
    level;
    levelName;
    formatter;
    constructor(levelName, options = {}){
        this.level = getLevelByName(levelName);
        this.levelName = levelName;
        this.formatter = options.formatter || DEFAULT_FORMATTER;
    }
    handle(logRecord) {
        if (this.level > logRecord.level) return;
        const msg = this.format(logRecord);
        return this.log(msg);
    }
    format(logRecord) {
        if (this.formatter instanceof Function) {
            return this.formatter(logRecord);
        }
        return this.formatter.replace(/{([^\s}]+)}/g, (match, p1)=>{
            const value = logRecord[p1];
            if (value == null) {
                return match;
            }
            return String(value);
        });
    }
    log(_msg) {}
    async setup() {}
    async destroy() {}
}
class ConsoleHandler extends BaseHandler {
    format(logRecord) {
        let msg = super.format(logRecord);
        switch(logRecord.level){
            case LogLevels.INFO:
                msg = blue1(msg);
                break;
            case LogLevels.WARNING:
                msg = yellow1(msg);
                break;
            case LogLevels.ERROR:
                msg = red1(msg);
                break;
            case LogLevels.CRITICAL:
                msg = bold1(red1(msg));
                break;
            default:
                break;
        }
        return msg;
    }
    log(msg) {
        console.log(msg);
    }
}
class WriterHandler extends BaseHandler {
    _writer;
    #encoder = new TextEncoder();
}
class FileHandler extends WriterHandler {
    _file;
    _buf;
    _filename;
    _mode;
    _openOptions;
    _encoder = new TextEncoder();
    #unloadCallback = (()=>{
        this.destroy();
    }).bind(this);
    constructor(levelName, options){
        super(levelName, options);
        this._filename = options.filename;
        this._mode = options.mode ? options.mode : "a";
        this._openOptions = {
            createNew: this._mode === "x",
            create: this._mode !== "x",
            append: this._mode === "a",
            truncate: this._mode !== "a",
            write: true
        };
    }
    async setup() {
        this._file = await Deno.open(this._filename, this._openOptions);
        this._writer = this._file;
        this._buf = new BufWriterSync1(this._file);
        addEventListener("unload", this.#unloadCallback);
    }
    handle(logRecord) {
        super.handle(logRecord);
        if (logRecord.level > LogLevels.ERROR) {
            this.flush();
        }
    }
    log(msg) {
        if (this._encoder.encode(msg).byteLength + 1 > this._buf.available()) {
            this.flush();
        }
        this._buf.writeSync(this._encoder.encode(msg + "\n"));
    }
    flush() {
        if (this._buf?.buffered() > 0) {
            this._buf.flush();
        }
    }
    destroy() {
        this.flush();
        this._file?.close();
        this._file = undefined;
        removeEventListener("unload", this.#unloadCallback);
        return Promise.resolve();
    }
}
const DEFAULT_LEVEL = "INFO";
const DEFAULT_CONFIG = {
    handlers: {
        default: new ConsoleHandler(DEFAULT_LEVEL)
    },
    loggers: {
        default: {
            level: DEFAULT_LEVEL,
            handlers: [
                "default"
            ]
        }
    }
};
const state = {
    handlers: new Map(),
    loggers: new Map(),
    config: DEFAULT_CONFIG
};
function getLogger(name) {
    if (!name) {
        const d = state.loggers.get("default");
        assert4(d != null, `"default" logger must be set for getting logger without name`);
        return d;
    }
    const result = state.loggers.get(name);
    if (!result) {
        const logger = new Logger(name, "NOTSET", {
            handlers: []
        });
        state.loggers.set(name, logger);
        return logger;
    }
    return result;
}
async function setup(config) {
    state.config = {
        handlers: {
            ...DEFAULT_CONFIG.handlers,
            ...config.handlers
        },
        loggers: {
            ...DEFAULT_CONFIG.loggers,
            ...config.loggers
        }
    };
    state.handlers.forEach((handler)=>{
        handler.destroy();
    });
    state.handlers.clear();
    const handlers = state.config.handlers || {};
    for(const handlerName in handlers){
        const handler = handlers[handlerName];
        await handler.setup();
        state.handlers.set(handlerName, handler);
    }
    state.loggers.clear();
    const loggers = state.config.loggers || {};
    for(const loggerName in loggers){
        const loggerConfig = loggers[loggerName];
        const handlerNames = loggerConfig.handlers || [];
        const handlers1 = [];
        handlerNames.forEach((handlerName)=>{
            const handler = state.handlers.get(handlerName);
            if (handler) {
                handlers1.push(handler);
            }
        });
        const levelName = loggerConfig.level || DEFAULT_LEVEL;
        const logger = new Logger(loggerName, levelName, {
            handlers: handlers1
        });
        state.loggers.set(loggerName, logger);
    }
}
await setup(DEFAULT_CONFIG);
const DEFAULT_BUFFER_SIZE = 32 * 1024;
async function* iterateReader1(r, options) {
    const bufSize = options?.bufSize ?? DEFAULT_BUFFER_SIZE;
    const b = new Uint8Array(bufSize);
    while(true){
        const result = await r.read(b);
        if (result === null) {
            break;
        }
        yield b.subarray(0, result);
    }
}
var DiffType1;
(function(DiffType) {
    DiffType["removed"] = "removed";
    DiffType["common"] = "common";
    DiffType["added"] = "added";
})(DiffType1 || (DiffType1 = {}));
BigInt(Number.MAX_SAFE_INTEGER);
const iter = iterateReader1;
const enc = new TextEncoder();
function getUint8Array(str) {
    return str instanceof Uint8Array ? str : enc.encode(str);
}
function hasPrefixFrom(a, prefix, offset) {
    for(let i = 0, max = prefix.length; i < max; i++){
        if (a[i + offset] !== prefix[i]) return false;
    }
    return true;
}
function noop(a) {}
const defaultCSVReaderOptions = {
    columnSeparator: ",",
    lineSeparator: "\n",
    quote: '"',
    onCell: noop,
    onRowEnd: noop,
    onEnd: noop,
    onError: noop,
    _readerIteratorBufferSize: 1024 * 1024,
    _columnBufferMinStepSize: 1024,
    _inputBufferIndexLimit: 1024,
    _columnBufferReserve: 64,
    _stats: {
        reads: 0,
        inputBufferShrinks: 0,
        columnBufferExpands: 0
    }
};
class CSVReader {
    decoder;
    onCell;
    onRowEnd;
    onEnd;
    onError;
    inputBufferIndexLimit;
    stats;
    columnSeparator;
    lineSeparator;
    quote;
    doubleQuote;
    minPossibleBufferReserve;
    columnBufferReserve;
    columnBufferStepSize;
    readerIterator;
    inputBuffer;
    inputBufferIndex;
    columnBuffer;
    columnBufferIndex;
    readerEmpty;
    emptyLine;
    inQuote;
    inColumn;
    inputBufferUnprocessed;
    paused;
    debug;
    currentPos;
    linesProcessed;
    lastLineStartPos;
    constructor(reader, options){
        this.decoder = new TextDecoder(options?.encoding);
        const mergedOptions = {
            ...defaultCSVReaderOptions,
            ...options
        };
        this.onCell = mergedOptions.onCell || noop;
        this.onRowEnd = mergedOptions.onRowEnd || noop;
        this.onEnd = mergedOptions.onEnd || noop;
        this.onError = mergedOptions.onError || noop;
        this.inputBufferIndexLimit = mergedOptions._inputBufferIndexLimit;
        this.stats = mergedOptions._stats;
        this.quote = getUint8Array(mergedOptions.quote);
        this.columnSeparator = getUint8Array(mergedOptions.columnSeparator);
        this.lineSeparator = getUint8Array(mergedOptions.lineSeparator);
        this.doubleQuote = repeat1(this.quote, 2);
        this.minPossibleBufferReserve = Math.max(this.columnSeparator.length, this.lineSeparator.length, this.doubleQuote.length, 1);
        this.columnBufferStepSize = Math.max(mergedOptions._columnBufferMinStepSize, this.minPossibleBufferReserve);
        this.columnBufferReserve = Math.max(mergedOptions._columnBufferReserve, this.minPossibleBufferReserve);
        this.readerIterator = iter(reader, {
            bufSize: mergedOptions._readerIteratorBufferSize
        });
        this.inputBuffer = new Uint8Array();
        this.inputBufferIndex = 0;
        this.columnBuffer = new Uint8Array(this.columnBufferStepSize);
        this.columnBufferIndex = 0;
        this.readerEmpty = false;
        this.emptyLine = true;
        this.inQuote = false;
        this.inColumn = false;
        this.inputBufferUnprocessed = 0;
        this.paused = true;
        this.currentPos = 0;
        this.linesProcessed = 0;
        this.lastLineStartPos = 0;
        const logger = getLogger("csv");
        if (logger.levelName === "DEBUG") {
            this.debug = (msg)=>logger.debug(msg);
        } else {
            this.debug = noop;
        }
    }
    read() {
        if (this.paused) {
            this.paused = false;
            this.parseCycle();
        }
    }
    pause() {
        this.paused = true;
    }
    processColumn() {
        const result = this.decoder.decode(this.columnBuffer.subarray(0, this.columnBufferIndex));
        this.columnBufferIndex = 0;
        this.onCell(result);
    }
    processRow() {
        this.onRowEnd();
    }
    hasNext(chars) {
        return hasPrefixFrom(this.inputBuffer, chars, this.inputBufferIndex);
    }
    skip(chars) {
        this.debug(`skip: ${chars.length}`);
        this.inputBufferIndex += chars.length;
        this.inputBufferUnprocessed -= chars.length;
        this.currentPos += chars.length;
    }
    shrinkInputBuffer() {
        this.stats.inputBufferShrinks++;
        this.debug("shrink input buffer");
        this.inputBuffer = this.inputBuffer.slice(this.inputBufferIndex);
        this.inputBufferIndex = 0;
        this.inputBufferUnprocessed = this.inputBuffer.length;
    }
    readChars(n) {
        this.columnBuffer.set(this.inputBuffer.subarray(this.inputBufferIndex, this.inputBufferIndex + n), this.columnBufferIndex);
        this.columnBufferIndex += n;
        this.inputBufferIndex += n;
        this.inputBufferUnprocessed -= n;
        this.currentPos += n;
    }
    async readMoreData() {
        this.stats.reads++;
        this.debug("read more data");
        const { done , value  } = await this.readerIterator.next();
        if (done) {
            this.readerEmpty = true;
        } else {
            this.inputBuffer = concat1(this.inputBuffer, value);
            this.inputBufferUnprocessed += value.length;
        }
    }
    expandColumnBuffer() {
        this.stats.columnBufferExpands++;
        const newColumn = new Uint8Array(this.columnBuffer.length + this.columnBufferStepSize);
        this.debug(`expand column buffer from ${this.columnBuffer.length} to ${newColumn.length}`);
        newColumn.set(this.columnBuffer);
        this.columnBuffer = newColumn;
    }
    countLine() {
        this.countLines(1, this.currentPos);
    }
    countLines(newLines, lastLineStartPos) {
        this.debug(`count lines: newLines=${newLines} lastLineStartPos=${lastLineStartPos}`);
        this.linesProcessed += newLines;
        this.lastLineStartPos = lastLineStartPos;
    }
    getCurrentPos() {
        const line = this.linesProcessed + 1;
        const ch = this.currentPos - this.lastLineStartPos + 1;
        return `line ${line}, character ${ch}`;
    }
    async parseCycle() {
        while(true){
            if (this.paused) {
                return;
            }
            if (!this.readerEmpty && this.inputBufferUnprocessed < this.minPossibleBufferReserve) {
                await this.readMoreData();
                continue;
            }
            if (this.inputBufferIndex >= this.inputBufferIndexLimit) {
                this.shrinkInputBuffer();
                continue;
            }
            if (this.columnBuffer.length - this.columnBufferIndex < this.columnBufferReserve) {
                this.expandColumnBuffer();
                continue;
            }
            if (!this.inColumn && this.inputBufferUnprocessed === 0) {
                this.debug("eof");
                if (!this.emptyLine) {
                    this.processColumn();
                    this.processRow();
                }
                this.onEnd();
                return;
            }
            if (!this.inColumn && this.hasNext(this.lineSeparator)) {
                this.debug("lineSeparator");
                if (!this.emptyLine) {
                    this.processColumn();
                    this.processRow();
                }
                this.skip(this.lineSeparator);
                this.countLine();
                this.emptyLine = true;
                continue;
            }
            if (!this.inColumn && this.hasNext(this.columnSeparator)) {
                this.debug("columnSeparator");
                this.processColumn();
                this.skip(this.columnSeparator);
                continue;
            }
            if (!this.inColumn) {
                this.inColumn = true;
                this.emptyLine = false;
                if (this.hasNext(this.quote)) {
                    this.debug("start quoted column");
                    this.inQuote = true;
                    this.skip(this.quote);
                } else {
                    this.debug("start unquoted column");
                }
                continue;
            }
            if (this.inColumn && this.inQuote && this.hasNext(this.doubleQuote)) {
                this.debug("double quote");
                this.columnBuffer.set(this.quote, this.columnBufferIndex);
                this.columnBufferIndex += this.quote.length;
                this.skip(this.doubleQuote);
                continue;
            }
            if (this.inColumn && this.inQuote && this.hasNext(this.quote)) {
                this.debug("end quoted column");
                this.inQuote = false;
                this.inColumn = false;
                this.skip(this.quote);
                if (this.inputBufferUnprocessed > 0 && !this.hasNext(this.lineSeparator) && !this.hasNext(this.columnSeparator)) {
                    const charCode = this.inputBuffer[this.inputBufferIndex];
                    const __char = charCode === 13 ? "\\r" : String.fromCharCode(charCode);
                    let msg = `Expected EOF, COLUMN_SEPARATOR, LINE_SEPARATOR; received ${__char} (${this.getCurrentPos()})`;
                    if (charCode === 13) {
                        msg += '\nPerhaps you need to add the setting lineSeparator: "\\r\\n"\nhttps://git.io/JDTDS';
                    }
                    this.onError(new Error(msg));
                    return;
                }
                continue;
            }
            if (this.inColumn && !this.inQuote && (this.inputBufferUnprocessed === 0 || this.hasNext(this.lineSeparator) || this.hasNext(this.columnSeparator))) {
                this.debug("end unquoted column");
                this.inColumn = false;
                continue;
            }
            if (this.inColumn && this.inputBufferUnprocessed > 0) {
                const slice = this.inputBuffer.subarray(this.inputBufferIndex);
                const limit = Math.min(slice.length - this.minPossibleBufferReserve, this.columnBuffer.length - this.columnBufferIndex);
                let readTillIndex = 1;
                let newLines = 0;
                let lastLineStartPos = -1;
                if (limit > 1) {
                    if (this.inQuote) {
                        const { till , lineSeparatorsFound , lastLineSeparatorEndIndex  } = findReadTillIndexQuoted(slice, limit, this.quote, this.lineSeparator);
                        readTillIndex = till;
                        newLines = lineSeparatorsFound;
                        lastLineStartPos = this.currentPos + lastLineSeparatorEndIndex;
                    } else {
                        const { till: till1 , type  } = findReadTillIndex(slice, limit, this.lineSeparator, this.columnSeparator, this.quote);
                        if (till1 === 0 && type === FindReadTillIndexType.QUOTE) {
                            this.onError(new Error(`Unexpected quote in unquoted field (${this.getCurrentPos()})`));
                            return;
                        }
                        readTillIndex = till1;
                    }
                }
                if (readTillIndex > 0) {
                    this.debug(`read char: ${readTillIndex}`);
                    this.readChars(readTillIndex);
                }
                if (newLines > 0) {
                    this.countLines(newLines, lastLineStartPos);
                }
                continue;
            }
            if (this.inQuote && this.inputBufferUnprocessed === 0) {
                this.onError(new Error(`Expected quote, received EOF (${this.getCurrentPos()})`));
                return;
            }
            this.onError(new Error(`unexpected (${this.getCurrentPos()})`));
            return;
        }
    }
}
class CSVStreamReader {
    reader;
    done;
    buffer;
    nextPromise;
    nextPromiseResolve;
    nextPromiseReject;
    constructor(reader, options){
        this.buffer = [];
        this.done = false;
        this.reader = new CSVReader(reader, {
            ...options,
            onCell: (value)=>this.onCell(value),
            onRowEnd: ()=>this.onRowEnd(),
            onEnd: ()=>this.onEnd(),
            onError: (err)=>this.onError(err)
        });
    }
    onCell(value) {
        this.process({
            done: false,
            value
        });
    }
    onRowEnd() {
        this.process({
            done: false,
            value: newLine
        });
    }
    onEnd() {
        this.done = true;
        this.process({
            done: true,
            value: undefined
        });
    }
    onError(err) {
        this.process(err);
    }
    process(result) {
        const cb = result instanceof Error ? this.nextPromiseReject : this.nextPromiseResolve;
        if (cb) {
            this.nextPromise = undefined;
            this.nextPromiseResolve = undefined;
            this.nextPromiseReject = undefined;
            cb(result);
        } else {
            this.buffer.push(result);
        }
        this.reader.pause();
    }
    next() {
        if (this.done && this.buffer.length === 0) {
            return Promise.resolve({
                done: true,
                value: undefined
            });
        }
        let promise = this.nextPromise;
        if (!promise) {
            if (this.buffer.length > 0) {
                const res = this.buffer.shift();
                if (res instanceof Error) {
                    return Promise.reject(res);
                } else {
                    return Promise.resolve(res);
                }
            }
            promise = new Promise((resolve, reject)=>{
                this.nextPromiseResolve = resolve;
                this.nextPromiseReject = reject;
                this.reader.read();
            });
        }
        if (this.nextPromiseResolve) {
            this.nextPromise = promise;
        }
        return promise;
    }
    [Symbol.asyncIterator]() {
        return this;
    }
}
const newLine = Symbol("newLine");
class CSVRowReader {
    reader;
    done;
    row;
    buffer;
    nextPromise;
    nextPromiseResolve;
    nextPromiseReject;
    constructor(reader, options){
        this.buffer = [];
        this.done = false;
        this.row = [];
        this.reader = new CSVReader(reader, {
            ...options,
            onCell: (value)=>this.onCell(value),
            onRowEnd: ()=>this.onRowEnd(),
            onEnd: ()=>this.onEnd(),
            onError: (err)=>this.process(err)
        });
    }
    onCell(cell) {
        this.row.push(cell);
    }
    onRowEnd() {
        const row = this.row;
        this.row = [];
        this.process({
            done: false,
            value: row
        });
    }
    onEnd() {
        this.done = true;
        this.process({
            done: true,
            value: undefined
        });
    }
    process(result) {
        const cb = result instanceof Error ? this.nextPromiseReject : this.nextPromiseResolve;
        if (cb) {
            this.nextPromise = undefined;
            this.nextPromiseResolve = undefined;
            this.nextPromiseReject = undefined;
            cb(result);
        } else {
            this.buffer.push(result);
        }
        this.reader.pause();
    }
    next() {
        if (this.done && this.buffer.length === 0) {
            return Promise.resolve({
                done: true,
                value: undefined
            });
        }
        let promise = this.nextPromise;
        if (!promise) {
            if (this.buffer.length > 0) {
                const res = this.buffer.shift();
                if (res instanceof Error) {
                    return Promise.reject(res);
                } else {
                    return Promise.resolve(res);
                }
            }
            promise = new Promise((resolve, reject)=>{
                this.nextPromiseResolve = resolve;
                this.nextPromiseReject = reject;
                this.reader.read();
            });
        }
        if (this.nextPromiseResolve) {
            this.nextPromise = promise;
        }
        return promise;
    }
    [Symbol.asyncIterator]() {
        return this;
    }
}
class RowIterator {
    onRequested;
    done;
    constructor(onRequested){
        this.onRequested = onRequested;
        this.done = false;
    }
    async readTillEnd() {
        if (this.done) {
            return;
        }
        for await (const _ of this){}
    }
    async next() {
        if (this.done) {
            return {
                done: true,
                value: null
            };
        }
        const { done , value  } = await this.onRequested();
        if (done || value === newLine) {
            this.done = true;
            return {
                done: true,
                value: null
            };
        } else {
            return {
                done: false,
                value: value
            };
        }
    }
    [Symbol.asyncIterator]() {
        return this;
    }
}
class CSVRowIteratorReader {
    reader;
    done;
    rowIterator;
    buffer;
    nextPromise;
    nextPromiseResolve;
    nextPromiseReject;
    constructor(reader, options){
        this.done = false;
        this.buffer = [];
        this.reader = new CSVReader(reader, {
            ...options,
            onCell: (value)=>this.onCell(value),
            onRowEnd: ()=>this.onRowEnd(),
            onEnd: ()=>this.onEnd(),
            onError: (err)=>this.onError(err)
        });
    }
    onCell(value) {
        this.process({
            done: false,
            value
        });
    }
    onRowEnd() {
        this.process({
            done: false,
            value: newLine
        });
    }
    onEnd() {
        this.done = true;
        this.process({
            done: true,
            value: undefined
        });
    }
    onError(err) {
        this.process(err);
    }
    process(result) {
        const cb = result instanceof Error ? this.nextPromiseReject : this.nextPromiseResolve;
        if (cb) {
            this.nextPromise = undefined;
            this.nextPromiseResolve = undefined;
            this.nextPromiseReject = undefined;
            cb(result);
        } else {
            this.buffer.push(result);
        }
        this.reader.pause();
    }
    onRequested() {
        let promise = this.nextPromise;
        if (!promise) {
            if (this.buffer.length > 0) {
                const res = this.buffer.shift();
                if (res instanceof Error) {
                    return Promise.reject(res);
                } else {
                    return Promise.resolve(res);
                }
            }
            promise = new Promise((resolve, reject)=>{
                this.nextPromiseResolve = resolve;
                this.nextPromiseReject = reject;
                this.reader.read();
            });
        }
        if (this.nextPromiseResolve) {
            this.nextPromise = promise;
        }
        return promise;
    }
    async next() {
        if (this.rowIterator) {
            await this.rowIterator.readTillEnd();
            this.rowIterator = undefined;
        }
        if (this.done) {
            return {
                done: true,
                value: undefined
            };
        }
        this.rowIterator = new RowIterator(()=>this.onRequested());
        return {
            done: false,
            value: this.rowIterator
        };
    }
    [Symbol.asyncIterator]() {
        return this;
    }
}
function readCSV(reader, options) {
    return new CSVRowIteratorReader(reader, options);
}
function findReadTillIndexQuoted(a, limit, quote, lineSeparator) {
    const s1 = quote[0];
    const s2 = lineSeparator[0];
    let result = limit;
    let lineSeparatorsFound = 0;
    let lastLineSeparatorEndIndex = -1;
    for(let i = 0; i < a.length; i++){
        if (i >= limit) {
            result = limit;
            break;
        }
        if (a[i] === s1) {
            let matched = 1;
            let j = i;
            while(matched < quote.length){
                j++;
                if (a[j] !== quote[j - i]) {
                    break;
                }
                matched++;
            }
            if (matched === quote.length) {
                result = i;
                break;
            }
        }
        if (a[i] === s2) {
            let matched1 = 1;
            let j1 = i;
            while(matched1 < lineSeparator.length){
                j1++;
                if (a[j1] !== lineSeparator[j1 - i]) {
                    break;
                }
                matched1++;
            }
            if (matched1 === lineSeparator.length) {
                lineSeparatorsFound++;
                lastLineSeparatorEndIndex = i + lineSeparator.length;
                i += lineSeparator.length - 1;
            }
        }
    }
    return {
        till: result,
        lineSeparatorsFound,
        lastLineSeparatorEndIndex
    };
}
var FindReadTillIndexType;
(function(FindReadTillIndexType) {
    FindReadTillIndexType[FindReadTillIndexType["LIMIT"] = 0] = "LIMIT";
    FindReadTillIndexType[FindReadTillIndexType["LINE_SEPARATOR"] = 1] = "LINE_SEPARATOR";
    FindReadTillIndexType[FindReadTillIndexType["COLUMN_SEPARATOR"] = 2] = "COLUMN_SEPARATOR";
    FindReadTillIndexType[FindReadTillIndexType["QUOTE"] = 3] = "QUOTE";
})(FindReadTillIndexType || (FindReadTillIndexType = {}));
function findReadTillIndex(a, limit, lineSeparator, columnSeparator, quote) {
    const s1 = lineSeparator[0];
    const s2 = columnSeparator[0];
    const s3 = quote[0];
    for(let i = 0; i < a.length; i++){
        if (i >= limit) {
            return {
                till: limit,
                type: FindReadTillIndexType.LIMIT
            };
        }
        if (a[i] === s1) {
            let matched = 1;
            let j = i;
            while(matched < lineSeparator.length){
                j++;
                if (a[j] !== lineSeparator[j - i]) {
                    break;
                }
                matched++;
            }
            if (matched === lineSeparator.length) {
                return {
                    till: i,
                    type: FindReadTillIndexType.LINE_SEPARATOR
                };
            }
        }
        if (a[i] === s2) {
            let matched1 = 1;
            let j1 = i;
            while(matched1 < columnSeparator.length){
                j1++;
                if (a[j1] !== columnSeparator[j1 - i]) {
                    break;
                }
                matched1++;
            }
            if (matched1 === columnSeparator.length) {
                return {
                    till: i,
                    type: FindReadTillIndexType.COLUMN_SEPARATOR
                };
            }
        }
        if (a[i] === s3) {
            let matched2 = 1;
            let j2 = i;
            while(matched2 < quote.length){
                j2++;
                if (a[j2] !== quote[j2 - i]) {
                    break;
                }
                matched2++;
            }
            if (matched2 === quote.length) {
                return {
                    till: i,
                    type: FindReadTillIndexType.QUOTE
                };
            }
        }
    }
    return {
        till: limit,
        type: FindReadTillIndexType.LIMIT
    };
}
const service10 = new Service();
class CSVState extends BaseStateClass {
    validate = null;
    load(_context, config) {
        const ajv = new __pika_web_default_export_for_treeshaking__1({
            strictSchema: false,
            allowUnionTypes: true
        });
        if (config.lineSchema) {
            this.validate = ajv.compile(config.lineSchema);
            _context.logger.info('TT Compiled validation func');
        }
        return Promise.resolve();
    }
}
const csvToJson = (mode)=>async (msg, context, config)=>{
        if (msg.getHeader('content-type') !== "text/csv") {
            return msg;
        }
        const readable = msg.data?.asReadable();
        if (!readable) return msg.setStatus(400, 'No data');
        const rdr = readerFromStreamReader(readable.getReader());
        const properties = config.lineSchema.properties;
        const required = config.lineSchema.required || [];
        const rowProps = Object.keys(properties);
        const errors = [];
        const warnings = [];
        const state = await context.state(CSVState, context, config);
        const validate = state.validate;
        const ignoreBlank = config.ignoreBlankLines === undefined ? true : config.ignoreBlankLines;
        let stream = null;
        let writer = null;
        let writeString = (_)=>{};
        if (mode !== "validate") {
            stream = new TransformStream();
            writer = stream.writable.getWriter();
            writeString = (data)=>writer.write(new TextEncoder().encode(data));
        }
        let rowIdx = 0;
        let blanks = 0;
        const process1 = async ()=>{
            try {
                if (mode === "json") {
                    writeString("[");
                }
                for await (const row of readCSV(rdr)){
                    let idx = 0;
                    let rowObj = {};
                    for await (let cell of row){
                        cell = cell.trim();
                        if (idx < rowProps.length) {
                            const subschema = properties[rowProps[idx]];
                            let val = null;
                            const fieldRequired = required.includes(rowProps[idx]);
                            if (cell === '' && !fieldRequired) {
                                idx++;
                                continue;
                            }
                            switch(subschema.type){
                                case "number":
                                    val = parseFloat(cell);
                                    if (isNaN(val)) {
                                        rowObj = null;
                                        if (mode === "validate") {
                                            errors.push(`row ${rowIdx} col ${idx}: ${cell} is not a number`);
                                        }
                                    }
                                    break;
                                case "integer":
                                    val = parseInt(cell);
                                    if (isNaN(val)) {
                                        rowObj = null;
                                        if (mode === "validate") {
                                            errors.push(`row ${rowIdx} col ${idx}: ${cell} is not an integer`);
                                        }
                                    }
                                    break;
                                case "boolean":
                                    val = cell.toLowerCase();
                                    if (val !== 'true' && val !== 'false') {
                                        rowObj = null;
                                        if (mode === "validate") {
                                            errors.push(`row ${rowIdx} col ${idx}: ${cell} is not true or false`);
                                        }
                                    } else {
                                        val = val === 'true';
                                    }
                                    break;
                                default:
                                    val = cell;
                            }
                            if (rowObj) rowObj[rowProps[idx]] = val;
                        } else if (mode === "validate" && idx === rowProps.length) {
                            warnings.push(`line ${rowIdx} too long (> ${rowProps.length} fields)`);
                        }
                        idx++;
                    }
                    const isBlank = rowObj && Object.keys(rowObj).length === 0;
                    if (isBlank) blanks++;
                    if (mode === "validate") {
                        if (idx < rowProps.length) {
                            warnings.push(`line ${rowIdx} too short (< ${rowProps.length} fields)`);
                        }
                        if (validate && rowObj && !validate(rowObj)) {
                            const errorMsg = (validate.errors || []).map((e)=>e.message).join('; ');
                            errors.push(`bad format line ${rowIdx}: ${errorMsg}`);
                        }
                    } else if (rowObj && !(ignoreBlank && isBlank)) {
                        if (mode === "ndjson") {
                            writeString(JSON.stringify(rowObj) + '\n');
                        } else {
                            writeString((rowIdx === 0 ? '' : ',') + JSON.stringify(rowObj));
                        }
                    }
                    if (mode === "validate" && errors.length > 100) {
                        errors.push('Aborted, over 100 errors');
                        break;
                    }
                    rowIdx++;
                }
                if (mode === "json") {
                    writeString("]");
                }
            } catch (err) {
                context.logger.error('Failure in CSV processing: ' + err.toString());
            } finally{
                writer?.close();
            }
        };
        try {
            if (mode === "validate") {
                await process1();
                let report = '';
                if (errors.length > 0) {
                    let report1 = errors.join('\n');
                    if (warnings.length) report1 += '\nWarnings:\n' + warnings.join('\n');
                    report1 += `${rowIdx} lines, ${errors.length} errors, ${warnings.length} warnings`;
                    return msg.setStatus(400, report1);
                } else {
                    report = `OK, ${rowIdx} lines validated`;
                    if (warnings.length) report += `, ${warnings.length} warnings\n` + warnings.join('\n');
                    return msg.setStatus(200, report);
                }
            } else {
                process1();
                return msg.setData(stream.readable, mode === "ndjson" ? "application/x-ndjson" : "application/json");
            }
        } catch (err) {
            writer?.close();
            return msg.setStatus(500, err.toString());
        }
    };
service10.postPath("ndjson", csvToJson("ndjson"));
service10.postPath("validate", csvToJson("validate"));
service10.postPath("json", csvToJson("json"));
const __default39 = {
    "name": "CSV converter",
    "description": "Convert CSV files to and from JSON or NDJSON",
    "moduleUrl": "./services/csvConverter.ts",
    "apis": [],
    "isFilter": true,
    "configSchema": {
        "type": "object",
        "properties": {
            "lineSchema": {
                "type": "object",
                "description": "A JSON Schema for a line of the CSV file, object type specifying fieldnames as properties",
                "properties": {}
            },
            "ignoreBlankLines": {
                "type": "boolean",
                "description": "Whether to skip output for lines which have empty values for all fields"
            }
        }
    },
    "exposedConfigProperties": [
        "lineSchema"
    ]
};
const service11 = new Service();
service11.getPath("tail", async (msg, { adapter , logger  })=>{
    logger.handlers[1].flush();
    const nLines = parseInt(msg.url.servicePathElements?.[0]);
    if (isNaN(nLines)) return msg.setStatus(400, 'Last path element must be number of lines to read');
    const lines = await adapter.tail(nLines);
    return msg.setData(lines.join('\n'), 'text/plain');
});
service11.getPath("search", async (msg, { adapter , logger  })=>{
    logger.handlers[1].flush();
    const nLines = parseInt(msg.url.servicePathElements?.[0]);
    const search = msg.url.servicePathElements?.[1];
    if (isNaN(nLines)) return msg.setStatus(400, 'Last path element must be number of lines to read');
    if (!search) return msg.setStatus(400, 'Must provide a string to search for');
    const lines = await adapter.search(nLines, search);
    return msg.setData(lines.join('\n'), 'text/plain');
});
const __default40 = {
    "name": "Log Reader Service",
    "description": "Queries a log store for log information",
    "moduleUrl": "./services/logReader.ts",
    "apis": [
        "view"
    ],
    "adapterInterface": "ILogReaderAdapter"
};
var LogLevels1;
(function(LogLevels) {
    LogLevels[LogLevels["NOTSET"] = 0] = "NOTSET";
    LogLevels[LogLevels["DEBUG"] = 10] = "DEBUG";
    LogLevels[LogLevels["INFO"] = 20] = "INFO";
    LogLevels[LogLevels["WARNING"] = 30] = "WARNING";
    LogLevels[LogLevels["ERROR"] = 40] = "ERROR";
    LogLevels[LogLevels["CRITICAL"] = 50] = "CRITICAL";
})(LogLevels1 || (LogLevels1 = {}));
Object.keys(LogLevels1).filter((key)=>isNaN(Number(key)));
const byLevel1 = {
    [String(LogLevels1.NOTSET)]: "NOTSET",
    [String(LogLevels1.DEBUG)]: "DEBUG",
    [String(LogLevels1.INFO)]: "INFO",
    [String(LogLevels1.WARNING)]: "WARNING",
    [String(LogLevels1.ERROR)]: "ERROR",
    [String(LogLevels1.CRITICAL)]: "CRITICAL"
};
function getLevelByName1(name) {
    switch(name){
        case "NOTSET":
            return LogLevels1.NOTSET;
        case "DEBUG":
            return LogLevels1.DEBUG;
        case "INFO":
            return LogLevels1.INFO;
        case "WARNING":
            return LogLevels1.WARNING;
        case "ERROR":
            return LogLevels1.ERROR;
        case "CRITICAL":
            return LogLevels1.CRITICAL;
        default:
            throw new Error(`no log level found for "${name}"`);
    }
}
function getLevelName1(level) {
    const levelName = byLevel1[level];
    if (levelName) {
        return levelName;
    }
    throw new Error(`no level name found for level: ${level}`);
}
class LogRecord1 {
    msg;
    #args;
    #datetime;
    level;
    levelName;
    loggerName;
    constructor(options){
        this.msg = options.msg;
        this.#args = [
            ...options.args
        ];
        this.level = options.level;
        this.loggerName = options.loggerName;
        this.#datetime = new Date();
        this.levelName = getLevelName1(options.level);
    }
    get args() {
        return [
            ...this.#args
        ];
    }
    get datetime() {
        return new Date(this.#datetime.getTime());
    }
}
class Logger1 {
    #level;
    #handlers;
    #loggerName;
    constructor(loggerName, levelName, options = {}){
        this.#loggerName = loggerName;
        this.#level = getLevelByName1(levelName);
        this.#handlers = options.handlers || [];
    }
    get level() {
        return this.#level;
    }
    set level(level) {
        this.#level = level;
    }
    get levelName() {
        return getLevelName1(this.#level);
    }
    set levelName(levelName) {
        this.#level = getLevelByName1(levelName);
    }
    get loggerName() {
        return this.#loggerName;
    }
    set handlers(hndls) {
        this.#handlers = hndls;
    }
    get handlers() {
        return this.#handlers;
    }
    #_log(level1, msg1, ...args1) {
        if (this.level > level1) {
            return msg1 instanceof Function ? undefined : msg1;
        }
        let fnResult1;
        let logMessage1;
        if (msg1 instanceof Function) {
            fnResult1 = msg1();
            logMessage1 = this.asString(fnResult1);
        } else {
            logMessage1 = this.asString(msg1);
        }
        const record1 = new LogRecord1({
            msg: logMessage1,
            args: args1,
            level: level1,
            loggerName: this.loggerName
        });
        this.#handlers.forEach((handler)=>{
            handler.handle(record1);
        });
        return msg1 instanceof Function ? fnResult1 : msg1;
    }
    asString(data) {
        if (typeof data === "string") {
            return data;
        } else if (data === null || typeof data === "number" || typeof data === "bigint" || typeof data === "boolean" || typeof data === "undefined" || typeof data === "symbol") {
            return String(data);
        } else if (data instanceof Error) {
            return data.stack;
        } else if (typeof data === "object") {
            return JSON.stringify(data);
        }
        return "undefined";
    }
    debug(msg, ...args) {
        return this.#_log(LogLevels1.DEBUG, msg, ...args);
    }
    info(msg, ...args) {
        return this.#_log(LogLevels1.INFO, msg, ...args);
    }
    warning(msg, ...args) {
        return this.#_log(LogLevels1.WARNING, msg, ...args);
    }
    error(msg, ...args) {
        return this.#_log(LogLevels1.ERROR, msg, ...args);
    }
    critical(msg, ...args) {
        return this.#_log(LogLevels1.CRITICAL, msg, ...args);
    }
}
const DEFAULT_FORMATTER1 = "{levelName} {msg}";
class BaseHandler1 {
    level;
    levelName;
    formatter;
    constructor(levelName, options = {}){
        this.level = getLevelByName1(levelName);
        this.levelName = levelName;
        this.formatter = options.formatter || DEFAULT_FORMATTER1;
    }
    handle(logRecord) {
        if (this.level > logRecord.level) return;
        const msg = this.format(logRecord);
        return this.log(msg);
    }
    format(logRecord) {
        if (this.formatter instanceof Function) {
            return this.formatter(logRecord);
        }
        return this.formatter.replace(/{([^\s}]+)}/g, (match, p1)=>{
            const value = logRecord[p1];
            if (value == null) {
                return match;
            }
            return String(value);
        });
    }
    log(_msg) {}
    setup() {}
    destroy() {}
}
class ConsoleHandler1 extends BaseHandler1 {
    format(logRecord) {
        let msg = super.format(logRecord);
        switch(logRecord.level){
            case LogLevels1.INFO:
                msg = blue(msg);
                break;
            case LogLevels1.WARNING:
                msg = yellow(msg);
                break;
            case LogLevels1.ERROR:
                msg = red(msg);
                break;
            case LogLevels1.CRITICAL:
                msg = bold(red(msg));
                break;
            default:
                break;
        }
        return msg;
    }
    log(msg) {
        console.log(msg);
    }
}
class WriterHandler1 extends BaseHandler1 {
    _writer;
    #encoder = new TextEncoder();
}
class FileHandler1 extends WriterHandler1 {
    _file;
    _buf;
    _filename;
    _mode;
    _openOptions;
    _encoder = new TextEncoder();
    #unloadCallback = (()=>{
        this.destroy();
    }).bind(this);
    constructor(levelName, options){
        super(levelName, options);
        this._filename = options.filename;
        this._mode = options.mode ? options.mode : "a";
        this._openOptions = {
            createNew: this._mode === "x",
            create: this._mode !== "x",
            append: this._mode === "a",
            truncate: this._mode !== "a",
            write: true
        };
    }
    setup() {
        this._file = Deno.openSync(this._filename, this._openOptions);
        this._writer = this._file;
        this._buf = new BufWriterSync(this._file);
        addEventListener("unload", this.#unloadCallback);
    }
    handle(logRecord) {
        super.handle(logRecord);
        if (logRecord.level > LogLevels1.ERROR) {
            this.flush();
        }
    }
    log(msg) {
        if (this._encoder.encode(msg).byteLength + 1 > this._buf.available()) {
            this.flush();
        }
        this._buf.writeSync(this._encoder.encode(msg + "\n"));
    }
    flush() {
        if (this._buf?.buffered() > 0) {
            this._buf.flush();
        }
    }
    destroy() {
        this.flush();
        this._file?.close();
        this._file = undefined;
        removeEventListener("unload", this.#unloadCallback);
    }
}
class RotatingFileHandler extends FileHandler1 {
    #maxBytes;
    #maxBackupCount;
    #currentFileSize = 0;
    constructor(levelName, options){
        super(levelName, options);
        this.#maxBytes = options.maxBytes;
        this.#maxBackupCount = options.maxBackupCount;
    }
    async setup() {
        if (this.#maxBytes < 1) {
            this.destroy();
            throw new Error("maxBytes cannot be less than 1");
        }
        if (this.#maxBackupCount < 1) {
            this.destroy();
            throw new Error("maxBackupCount cannot be less than 1");
        }
        await super.setup();
        if (this._mode === "w") {
            for(let i = 1; i <= this.#maxBackupCount; i++){
                if (await exists(this._filename + "." + i)) {
                    await Deno.remove(this._filename + "." + i);
                }
            }
        } else if (this._mode === "x") {
            for(let i1 = 1; i1 <= this.#maxBackupCount; i1++){
                if (await exists(this._filename + "." + i1)) {
                    this.destroy();
                    throw new Deno.errors.AlreadyExists("Backup log file " + this._filename + "." + i1 + " already exists");
                }
            }
        } else {
            this.#currentFileSize = (await Deno.stat(this._filename)).size;
        }
    }
    log(msg) {
        const msgByteLength = this._encoder.encode(msg).byteLength + 1;
        if (this.#currentFileSize + msgByteLength > this.#maxBytes) {
            this.rotateLogFiles();
            this.#currentFileSize = 0;
        }
        super.log(msg);
        this.#currentFileSize += msgByteLength;
    }
    rotateLogFiles() {
        this._buf.flush();
        Deno.close(this._file.rid);
        for(let i = this.#maxBackupCount - 1; i >= 0; i--){
            const source = this._filename + (i === 0 ? "" : "." + i);
            const dest = this._filename + "." + (i + 1);
            if (existsSync1(source)) {
                Deno.renameSync(source, dest);
            }
        }
        this._file = Deno.openSync(this._filename, this._openOptions);
        this._writer = this._file;
        this._buf = new BufWriterSync(this._file);
    }
}
const DEFAULT_LEVEL1 = "INFO";
const DEFAULT_CONFIG1 = {
    handlers: {
        default: new ConsoleHandler1(DEFAULT_LEVEL1)
    },
    loggers: {
        default: {
            level: DEFAULT_LEVEL1,
            handlers: [
                "default"
            ]
        }
    }
};
const state1 = {
    handlers: new Map(),
    loggers: new Map(),
    config: DEFAULT_CONFIG1
};
const handlers = {
    BaseHandler: BaseHandler1,
    ConsoleHandler: ConsoleHandler1,
    WriterHandler: WriterHandler1,
    FileHandler: FileHandler1,
    RotatingFileHandler
};
function getLogger1(name) {
    if (!name) {
        const d = state1.loggers.get("default");
        assert(d != null, `"default" logger must be set for getting logger without name`);
        return d;
    }
    const result = state1.loggers.get(name);
    if (!result) {
        const logger = new Logger1(name, "NOTSET", {
            handlers: []
        });
        state1.loggers.set(name, logger);
        return logger;
    }
    return result;
}
function setup1(config) {
    state1.config = {
        handlers: {
            ...DEFAULT_CONFIG1.handlers,
            ...config.handlers
        },
        loggers: {
            ...DEFAULT_CONFIG1.loggers,
            ...config.loggers
        }
    };
    state1.handlers.forEach((handler)=>{
        handler.destroy();
    });
    state1.handlers.clear();
    const handlers = state1.config.handlers || {};
    for(const handlerName in handlers){
        const handler = handlers[handlerName];
        handler.setup();
        state1.handlers.set(handlerName, handler);
    }
    state1.loggers.clear();
    const loggers = state1.config.loggers || {};
    for(const loggerName in loggers){
        const loggerConfig = loggers[loggerName];
        const handlerNames = loggerConfig.handlers || [];
        const handlers1 = [];
        handlerNames.forEach((handlerName)=>{
            const handler = state1.handlers.get(handlerName);
            if (handler) {
                handlers1.push(handler);
            }
        });
        const levelName = loggerConfig.level || DEFAULT_LEVEL1;
        const logger = new Logger1(loggerName, levelName, {
            handlers: handlers1
        });
        state1.loggers.set(loggerName, logger);
    }
}
setup1(DEFAULT_CONFIG1);
const formatter = (rec)=>{
    let severity = 'DEBUG';
    switch(rec.levelName){
        case "NOTSET":
            severity = "TRACE";
            break;
        case "INFO":
            severity = "INFO ";
            break;
        case "WARNING":
            severity = "WARN ";
            break;
        case "ERROR":
            severity = "ERROR";
            break;
        case "CRITICAL":
            severity = "FATAL";
            break;
    }
    let [tenant, username, traceId, spanId] = rec.args;
    if (!tenant) tenant = 'global';
    if (!username) username = '?';
    if (!traceId) traceId = 'x'.repeat(32);
    if (!spanId) spanId = 'x'.repeat(16);
    return `${severity} ${rec.datetime.toISOString()} ${traceId} ${spanId} ${tenant} ${username} ${rec.msg}`;
};
const schemaIServiceManifest = {
    type: "object",
    properties: {
        "name": {
            type: "string"
        },
        "description": {
            type: "string"
        },
        "moduleUrl": {
            type: "string"
        },
        "configSchema": {
            type: "object",
            properties: {}
        },
        "apis": {
            type: "array",
            items: {
                type: "string"
            }
        },
        "adapterInterface": {
            type: "string"
        },
        "privateServices": {
            type: "object"
        },
        "prePipeline": {
            type: "array"
        },
        "postPipeline": {
            type: "array"
        }
    },
    required: [
        "name",
        "description",
        "moduleUrl"
    ]
};
var TokenVerification;
class RestspaceLoader {
    async;
    constructor(context){
        this.context = context;
        this.async = true;
    }
    getSource(name, cb) {
        const msg = new Message(name, this.context.tenant, "GET", null);
        msg.startSpan(this.context.traceparent, this.context.tracestate);
        this.context.makeRequest(msg).then((res)=>{
            if (!res.ok) {
                res.data?.asString().then((s)=>cb(new Error(`${res.status} ${s}`), null));
            } else {
                res.data?.asString().then((s)=>cb(null, {
                        src: s || '',
                        path: name
                    }));
            }
        });
    }
    context;
}
class AuthUser {
    token = '';
    tokenExpiry;
    email = '';
    originalEmail = '';
    roles = '';
    password = '';
    exp;
    get rolesArray() {
        return this.roles.split(' ').filter((r)=>!!r).map((r)=>r.trim());
    }
    constructor(userObj){
        userObj && Object.assign(this, userObj);
    }
    getJwtPayload() {
        return {
            email: this.email,
            roles: this.roles
        };
    }
    hasRole(role) {
        return this.rolesArray.indexOf(role) >= 0;
    }
    addRole(role) {
        if (!this.rolesArray.includes(role)) {
            this.roles += (this.roles ? " " : "") + role;
        }
        return this;
    }
    authorizedForInner(reqRoles, path) {
        if (reqRoles.includes('all')) return true;
        if (!this.roles) return false;
        let userRoles = this.rolesArray;
        let authorized = reqRoles.some((reqRole)=>userRoles.includes(reqRole));
        if (path) {
            const pathMatches = reqRoles.filter((r)=>r.startsWith('{') && r.endsWith('}')).map((r)=>this[r.slice(1, -1)].toString()).filter((m)=>!!m);
            userRoles = userRoles.filter((r)=>!r.startsWith('{'));
            const pathEls = slashTrim(path).split('/');
            authorized = authorized || pathMatches.some((pathMatch)=>pathEls.includes(pathMatch));
        }
        return authorized;
    }
    authorizedFor(roleSpec, servicePath) {
        if (servicePath && !servicePath.startsWith('/')) servicePath = '/' + servicePath;
        let specParts = roleSpec.trim().split(' ');
        let specPath = '/';
        let rootReqRoles = [];
        while(specParts.length){
            const nextUrlIdx = specParts.findIndex((s)=>s.startsWith('/'));
            const reqRoles = nextUrlIdx < 0 ? specParts : specParts.slice(0, nextUrlIdx);
            if (specPath === '/') {
                rootReqRoles = reqRoles;
            } else if (servicePath && servicePath.startsWith(specPath)) {
                return this.authorizedForInner(reqRoles, servicePath);
            }
            if (reqRoles.length < specParts.length) {
                specPath = specParts[reqRoles.length];
                specParts = specParts.slice(reqRoles.length + 1);
            } else {
                specParts = [];
            }
        }
        return this.authorizedForInner(rootReqRoles, servicePath);
    }
    isAnon() {
        return userIsAnon(this);
    }
    async hashPassword() {
        this.password = await hash(this.password);
    }
    async matchPassword(pw) {
        return await compare(pw, this.password);
    }
    generateToken(expirySeconds) {
        const auth = config.authoriser;
        this.token = auth.generateToken();
        this.tokenExpiry = new Date();
        this.tokenExpiry.setSeconds(this.tokenExpiry.getSeconds() + expirySeconds);
        return this.token;
    }
    verifyToken(token) {
        const auth = config.authoriser;
        return auth.verifyToken(token, this);
    }
    passwordMask() {
        return this.password ? AuthUser.passwordMask : AuthUser.noPasswordMask;
    }
    passwordIsMaskOrEmpty() {
        return this.password === AuthUser.passwordMask || this.password === AuthUser.noPasswordMask || !this.password;
    }
    static passwordMask = '<hidden>';
    static noPasswordMask = '<no password>';
    static anon = new AuthUser({});
}
let catalogue = null;
const baseChord = {
    id: 'sys.base',
    newServices: [
        {
            "access": {
                "readRoles": "all",
                "writeRoles": "A"
            },
            "name": "Services Service",
            "source": "./services/services.rsm.json",
            "basePath": "/.well-known/restspace"
        }
    ]
};
const schemaIAdapterManifest = {
    type: "object",
    properties: {
        "name": {
            type: "string"
        },
        "description": {
            type: "string"
        },
        "moduleUrl": {
            type: "string"
        },
        "configSchema": {
            type: "object",
            properties: {}
        },
        "adapterInterfaces": {
            type: "array",
            items: {
                type: "string"
            }
        }
    },
    required: [
        "name",
        "description",
        "moduleUrl",
        "adapterInterfaces"
    ]
};
function applyServiceConfigTemplate(serviceConfig, configTemplate) {
    const transformObject = {
        ...configTemplate
    };
    delete transformObject.source;
    const outputConfig = transformation(transformObject, serviceConfig, new Url(configTemplate.source));
    outputConfig.source = configTemplate.source;
    return outputConfig;
}
class ServiceFactory {
    serviceManifestsBySource;
    adapterManifestsBySource;
    serviceConfigs;
    constructor(tenant){
        this.tenant = tenant;
        this.serviceManifestsBySource = {};
        this.adapterManifestsBySource = {};
        this.serviceConfigs = null;
    }
    async loadServiceManifests(serviceManifestSources) {
        config.logger.debug(`Start -- loading manifests`, this.tenant);
        const uniqueServiceManifestSources = serviceManifestSources.filter((ms, i)=>serviceManifestSources.indexOf(ms) === i);
        const getServiceManifestPromises = uniqueServiceManifestSources.map((source)=>config.modules.getServiceManifest(source));
        const serviceManifests = await Promise.all(getServiceManifestPromises);
        const errors = serviceManifests.filter((m)=>typeof m === 'string');
        if (errors.length) throw new Error('failed to load service manifests: ' + errors.join('; '));
        uniqueServiceManifestSources.forEach((source, i)=>this.serviceManifestsBySource[source] = serviceManifests[i]);
        const privateServiceManifests = await this.getPrivateServiceManifests(Object.keys(this.serviceManifestsBySource), Object.values(this.serviceManifestsBySource));
        const privateServiceErrors = privateServiceManifests.filter((m)=>typeof m === 'string');
        if (privateServiceErrors.length) throw new Error('failed to load manifests: ' + privateServiceErrors.join('; '));
    }
    async loadAdapterManifests() {
        const adapterManifestSources = Object.values(this.serviceConfigs).filter((sc)=>sc.adapterSource).map((sc)=>sc.adapterSource);
        const infraNames = Object.values(this.serviceConfigs).filter((sc)=>sc.infraName).map((sc)=>sc.infraName);
        const missingInfraNames = infraNames.filter((i)=>!config.server.infra[i]);
        if (missingInfraNames.length) {
            throw new Error(`tenant ${this.tenant} has infra names that don't exist: ${missingInfraNames.join(', ')}`);
        }
        const adapterInfraManifestSources = infraNames.map((i)=>config.server.infra[i].adapterSource);
        const allAdapterManifestSources = [
            ...adapterManifestSources,
            ...adapterInfraManifestSources
        ];
        const uniqueAdapterManifestSources = allAdapterManifestSources.filter((ms, i)=>allAdapterManifestSources.indexOf(ms) === i);
        const getAdapterManifestPromises = uniqueAdapterManifestSources.map((source)=>config.modules.getAdapterManifest(source));
        const adapterManifests = await Promise.all(getAdapterManifestPromises);
        const errors = adapterManifests.filter((m)=>typeof m === 'string');
        if (errors.length) throw new Error('failed to load adapter manifests: ' + errors.join('; '));
        uniqueAdapterManifestSources.forEach((source, i)=>this.adapterManifestsBySource[source] = adapterManifests[i]);
        config.logger.debug(`End -- loading manifests`, this.tenant);
    }
    async getPrivateServiceManifests(existingServiceSources, serviceManifests) {
        if (serviceManifests.length === 0) return [];
        const privateServiceSources = serviceManifests.flatMap((sc)=>sc.privateServices ? Object.values(sc.privateServices).map((ps)=>ps.source) : []).filter((s)=>!existingServiceSources.includes(s));
        const manifestsLayer0 = await Promise.all(privateServiceSources.map((pss)=>config.modules.getServiceManifest(pss)));
        if (manifestsLayer0.some((m)=>typeof m === 'string')) return manifestsLayer0;
        privateServiceSources.forEach((source, i)=>this.serviceManifestsBySource[source] = manifestsLayer0[i]);
        const manifestsOtherLayers = await this.getPrivateServiceManifests([
            ...existingServiceSources,
            ...privateServiceSources
        ], manifestsLayer0);
        return manifestsLayer0.concat(manifestsOtherLayers);
    }
    addPrivateServiceConfig(serviceConfig, manifest) {
        if (!manifest.privateServices) return serviceConfig;
        const privateServiceConfigs = {};
        Object.entries(manifest.privateServices).forEach(([name, configTemplate])=>{
            let innerServiceConfig = applyServiceConfigTemplate(serviceConfig, configTemplate);
            innerServiceConfig.basePath = name;
            const innerManifest = this.serviceManifestsBySource[innerServiceConfig.source];
            innerServiceConfig = this.addPrivateServiceConfig(innerServiceConfig, innerManifest);
            privateServiceConfigs[name] = innerServiceConfig;
        });
        const newServiceConfig = {
            ...serviceConfig,
            manifestConfig: {
                prePipeline: manifest.prePipeline,
                postPipeline: manifest.postPipeline,
                privateServiceConfigs
            }
        };
        return newServiceConfig;
    }
    async infraForAdapterInterface(adapterInterface) {
        let infraName = '';
        for (const [name, infra] of Object.entries(config.server.infra)){
            const adapterManifest = await config.modules.getAdapterManifest(infra.adapterSource);
            if (typeof adapterManifest === 'string') {
                config.logger.error('Failed to load adapter manifest: ' + adapterManifest);
            } else if (adapterManifest.adapterInterfaces.includes(adapterInterface)) {
                if (adapterManifest.moduleUrl?.startsWith('./')) {
                    return name;
                } else {
                    infraName = name;
                }
            }
        }
        return infraName;
    }
    async initService(serviceConfig, serviceContext) {
        const service = await config.modules.getService(serviceConfig.source);
        const manifest = this.serviceManifestsBySource[serviceConfig.source];
        serviceContext.manifest = manifest;
        await service.initFunc(serviceContext, serviceConfig);
    }
    async getMessageFunctionForService(serviceConfig, serviceContext, source) {
        const service = await config.modules.getService(serviceConfig.source);
        const manifest = this.serviceManifestsBySource[serviceConfig.source];
        serviceConfig = this.addPrivateServiceConfig(serviceConfig, manifest);
        const configValidator = config.modules.validateServiceConfig[serviceConfig.source];
        const serviceName = serviceConfig.name;
        if (!configValidator(serviceConfig)) {
            throw new Error(`failed to validate config for service ${serviceName}: ${getErrors(configValidator)}`);
        }
        let adapter = undefined;
        if (serviceConfig.adapterSource || serviceConfig.infraName) {
            const adapterConfig = {
                ...serviceConfig.adapterConfig
            } || {};
            let adapterSource = serviceConfig.adapterSource;
            if (serviceConfig.infraName) {
                const infra = config.server.infra[serviceConfig.infraName];
                adapterSource = infra.adapterSource;
                Object.assign(adapterConfig, infra);
            }
            const validator = config.modules.validateAdapterConfig[adapterSource];
            if (!validator(adapterConfig)) {
                throw new Error(`failed to validate adapter config for service ${serviceConfig.name}: ${getErrors(validator)}`);
            }
            adapter = await config.modules.getAdapter(adapterSource, serviceContext, adapterConfig);
            serviceContext = {
                ...serviceContext,
                manifest,
                adapter
            };
        } else {
            serviceContext = {
                ...serviceContext,
                manifest
            };
        }
        const serviceWrapper = new ServiceWrapper(service);
        const sourceServiceFunc = source === Source.External || source === Source.Outer ? serviceWrapper.external(source) : serviceWrapper.internal;
        serviceContext.manifest = structuredClone(serviceContext.manifest);
        const copyServiceConfig = structuredClone(serviceConfig);
        return (msg)=>Promise.resolve(sourceServiceFunc(msg, serviceContext, copyServiceConfig));
    }
    attachFilter(url, func, context) {
        const filterUrl = url.query['$filter']?.[0];
        if (filterUrl) {
            const url1 = new Url(filterUrl);
            const newFunc = async (msg)=>{
                const msg2 = await func(msg);
                msg2.setUrl(url1).setMethod('POST');
                return context.makeRequest(msg2, Source.Outer);
            };
            return newFunc;
        } else {
            return func;
        }
    }
    async getMessageFunctionByUrl(url, serviceContext, stateByBasePath, source) {
        if (this.serviceConfigs['()'] && source === Source.External) {
            const newServiceContext = {
                ...serviceContext,
                makeRequest: (msg)=>serviceContext.makeRequest(msg, Source.Outer)
            };
            return this.getMessageFunctionForService(this.serviceConfigs['()'], newServiceContext, source);
        }
        const pathParts = [
            ...url.pathElements
        ];
        let exactPath = '/' + pathParts.join('/') + '.';
        let serviceConfig = this.serviceConfigs[exactPath];
        if (serviceConfig) return this.getMessageFunctionForService(serviceConfig, serviceContext, source);
        while(true){
            exactPath = '/' + pathParts.join('/');
            serviceConfig = this.serviceConfigs[exactPath];
            if (serviceConfig) {
                serviceContext.state = stateByBasePath(exactPath);
                const innerFunc = await this.getMessageFunctionForService(serviceConfig, serviceContext, source);
                return await this.attachFilter(url, innerFunc, serviceContext);
            } else {
                if (pathParts.length === 0) break;
                pathParts.pop();
            }
        }
        return Promise.resolve((msg)=>Promise.resolve(msg.method === 'OPTIONS' ? config.server.setServerCors(msg).setStatus(204) : config.server.setServerCors(msg).setStatus(404, 'Not found')));
    }
    getServiceConfigByApi(api) {
        const apiManifests = Object.entries(this.serviceManifestsBySource).filter(([, m])=>(m.apis || []).some((mApi)=>mApi === api));
        if (apiManifests.length === 0) return undefined;
        const [manifestSource, ] = apiManifests[0];
        if (!manifestSource) return undefined;
        return Object.values(this.serviceConfigs).find((config)=>config.source === manifestSource);
    }
    async getServiceAndConfigByApi(api) {
        const serviceConfig = this.getServiceConfigByApi(api);
        if (!serviceConfig) return null;
        return [
            await config.modules.getService(serviceConfig.source),
            serviceConfig
        ];
    }
    tenant;
}
class ServiceWrapper {
    constructor(service){
        this.service = service;
        this.internal = async (msg, context, serviceConfig)=>{
            msg.url.basePathElements = serviceConfig.basePath.split('/').filter((s)=>s !== '');
            let newMsg = msg.copy();
            try {
                const { manifestConfig  } = serviceConfig;
                const prePipeline = pipelineConcat(manifestConfig?.prePipeline || serviceConfig?.prePipeline);
                const postPipeline = pipelineConcat(manifestConfig?.postPipeline || serviceConfig?.postPipeline);
                newMsg = await this.prePostPipeline("pre", newMsg, prePipeline, manifestConfig?.privateServiceConfigs);
                newMsg.applyServiceRedirect();
                context.metadataOnly = newMsg.url.isDirectory && newMsg.url.query.hasOwnProperty("$metadataOnly");
                if (newMsg.ok && !newMsg.isRedirect) newMsg = await this.service.func(newMsg, context, serviceConfig);
                if (newMsg.ok && !newMsg.isRedirect) newMsg = await this.prePostPipeline("post", newMsg, postPipeline, manifestConfig?.privateServiceConfigs);
            } catch (err) {
                if (err.message === 'Not found') {
                    newMsg.setStatus(404, 'Not found');
                } else {
                    config.logger.error(`Service: ${serviceConfig.name} error: ${err}`, ...msg.loggerArgs());
                    newMsg.setStatus(500, 'Internal Server Error');
                }
            }
            if (newMsg && !newMsg.ok) {
                config.logger.warning(`Request error for ${msg.method}: ${msg.url}: ${newMsg.status} ${newMsg?.data?.asStringSync() || ''}`, ...msg.loggerArgs());
            }
            newMsg.setHeader('X-Restspace-Service', serviceConfig.name);
            if (newMsg.data && !newMsg.data.wasMimeHandled) {
                const handler = mimeHandlers[upTo(newMsg.data.mimeType, ';')];
                if (handler) {
                    newMsg = await handler(newMsg, msg.url, (innerMsg)=>Promise.resolve(this.internal(innerMsg, context, serviceConfig)));
                    if (newMsg.data) newMsg.data.wasMimeHandled = true;
                }
            }
            return newMsg;
        };
        this.external = (source)=>async (msg, context, serviceConfig)=>{
                const origin = msg.getHeader('origin');
                const [isPublic, isPermitted] = await this.isPermitted(msg, serviceConfig);
                if (!isPermitted) {
                    config.logger.warning(`Unauthorized for ${msg.url}`, ...msg.loggerArgs());
                    return this.setCors(msg, origin).setStatus(401, "Unauthorized");
                }
                msg.authenticated = true;
                let msgOut = await this.internal(msg, context, serviceConfig);
                if (source === Source.Outer) return msgOut;
                msgOut = this.setCors(msgOut, origin);
                msgOut = this.checkMatch(msgOut);
                msgOut = this.setCache(msgOut, serviceConfig, isPublic);
                return msgOut;
            };
    }
    async prePostPipeline(prePost, msg, pipelineSpec, privateServiceConfigs) {
        if (pipelineSpec) {
            let handler = handleOutgoingRequest;
            if (privateServiceConfigs) handler = handleOutgoingRequestFromPrivateServices(prePost, privateServiceConfigs, msg.tenant);
            return await pipeline(msg, pipelineSpec, msg.url, false, handler);
        }
        return msg;
    }
    internal;
    async isPermitted(msg, { access  }) {
        if (!msg.user) return [
            false,
            false
        ];
        let roleSet;
        let isPublic;
        switch(await this.service.authType(msg)){
            case AuthorizationType.read:
                roleSet = access.readRoles;
                isPublic = access.readRoles === 'all';
                break;
            case AuthorizationType.write:
                roleSet = access.writeRoles;
                isPublic = access.writeRoles === 'all';
                break;
            case AuthorizationType.create:
                roleSet = access.createRoles || access.writeRoles;
                isPublic = access.createRoles === 'all';
                break;
            case AuthorizationType.none:
            default:
                roleSet = "all";
                isPublic = true;
                break;
        }
        const authUser = new AuthUser(msg.user);
        return [
            isPublic,
            authUser.authorizedFor(roleSet, msg.url.servicePath)
        ];
    }
    setCors(data, origin) {
        if (origin) {
            data.setHeader('Access-Control-Allow-Origin', origin);
            data.setHeader('Access-Control-Allow-Headers', 'Origin,X-Requested-With,Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,X-Restspace-Request-Mode');
            data.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET, HEAD, POST, PUT, PATCH, DELETE');
            data.setHeader('Access-Control-Allow-Credentials', 'true');
            data.setHeader('Access-Control-Expose-Headers', 'X-Restspace-Service');
        }
        return data;
    }
    getEtag(msg) {
        const dateModified = msg?.data?.dateModified || new Date(0);
        const size = msg?.data?.size || 0;
        return `${dateModified.getTime()}-${size}`;
    }
    checkMatch(msg) {
        if (!msg.ok) return msg;
        const ifMatch = msg.getHeader("If-Match");
        const ifNoneMatch = msg.getHeader("If-None-Match");
        if (ifMatch || ifNoneMatch) {
            const etags = (ifMatch || ifNoneMatch).split(',').map((etag)=>etag.trim());
            const msgETag = this.getEtag(msg);
            const matches = etags.includes(msgETag);
            if (matches && ifNoneMatch) {
                return msg.setStatus(304, "Not Modified");
            } else if (!matches && ifMatch) {
                if (msg.method === "GET" || msg.method === "HEAD") {
                    if (msg.getHeader("Range")) {
                        return msg.setStatus(416, "Range Not Satisfiable");
                    }
                } else {
                    return msg.setStatus(412, "Precondition Failed");
                }
            }
        }
        return msg;
    }
    setCache(msg, { caching  }, isPublic) {
        if (msg.method !== 'GET' || msg.url.isDirectory) {
            msg.setHeader("Cache-Control", "no-store");
            return msg;
        }
        caching = caching || {};
        const cacheControl = [];
        cacheControl.push(isPublic ? 'public' : 'private');
        if (!caching.cache) {
            cacheControl.push('no-cache');
            msg.setHeader("Pragma", "no-cache");
        } else {
            msg.removeHeader("Pragma");
        }
        if (caching.maxAge) {
            cacheControl.push('max-age=' + caching.maxAge);
            const expiry = new Date();
            expiry.setSeconds(expiry.getSeconds() + caching.maxAge);
            msg.setHeader("Expires", expiry.toUTCString());
        }
        if (cacheControl.length) {
            msg.setHeader("Cache-Control", cacheControl.join(', '));
        }
        if (caching.sendETag && msg.ok && msg.data && msg.data.dateModified) {
            msg.setHeader("ETag", this.getEtag(msg));
        }
        return msg;
    }
    external;
    service;
}
class NunjucksTemplateAdapter {
    env;
    constructor(context){
        this.context = context;
        this.env = new __default8.Environment(new RestspaceLoader(context));
        this.env.addGlobal('$this', function() {
            delete this.ctx['$url'];
            return this.ctx;
        });
        this.env.addFilter("dateFormat", (dateStr, format)=>{
            if (dateStr === undefined || dateStr === null) return '';
            return dayjs_min(dateStr).format(format);
        });
        this.env.addFilter("authorizedFor", (user, roles)=>{
            return new AuthUser(user).authorizedFor(roles);
        });
        this.env.addFilter("pathPattern", function(pattern, decode) {
            return resolvePathPatternWithUrl(pattern, this.ctx._url, undefined, undefined, decode);
        });
    }
    fillTemplate(data, template, url) {
        return new Promise((resolve)=>{
            this.env.renderString(template, {
                ...data,
                _url: url
            }, (err, res)=>{
                if (err) {
                    resolve(`template error: ${err}`);
                } else {
                    resolve(res);
                }
            });
        });
    }
    context;
}
const deleteManifestProperties = [
    'exposedConfigProperties'
];
const service12 = new Service();
const service13 = new AuthService();
const service14 = new Service();
const service15 = new Service();
function mapLegalChanges(msg, oldValues, newUser) {
    const currentUserObj = msg.user || AuthUser.anon;
    const current = new AuthUser(currentUserObj);
    const isRegistration = !oldValues || oldValues.isAnon();
    const isSelfChange = !isRegistration && oldValues.email === current.email;
    if (newUser && newUser.passwordIsMaskOrEmpty()) newUser.password = oldValues.password;
    if (msg.internalPrivilege || current.hasRole("A")) {
        return newUser;
    }
    if (newUser === null) {
        return isSelfChange ? newUser : "can't delete another user";
    }
    if (isSelfChange) {
        if (newUser.roles !== oldValues.roles || newUser.email !== oldValues.email) {
            return "user can't change their role or email";
        } else {
            return newUser;
        }
    }
    if (isRegistration) {
        if (newUser.roles !== 'U') {
            return "registration must set role to U only";
        } else {
            return newUser;
        }
    }
    return 'not an allowable change';
}
async function validateChange(msg, context) {
    if (!msg.ok || msg.method !== 'DELETE' && !msg.data || context.prePost !== "pre" || msg.internalPrivilege || msg.url.isDirectory) {
        msg.internalPrivilege = false;
        return msg;
    }
    let newUser;
    try {
        const newUserObj = msg.method === 'DELETE' ? null : await msg.data.asJson();
        newUser = msg.method === 'DELETE' ? null : new AuthUser(newUserObj);
    } catch  {
        return msg.setStatus(400, 'Json misformatted');
    }
    let currUserMsg = msg.copy().setMethod("GET");
    currUserMsg.url.pathElements.shift();
    currUserMsg.url.isRelative = false;
    currUserMsg.internalPrivilege = true;
    currUserMsg = await context.makeRequest(currUserMsg);
    currUserMsg.internalPrivilege = false;
    let currUser;
    if (currUserMsg.status === 404) {
        currUser = AuthUser.anon;
    } else if (!currUserMsg.ok) {
        msg.data = currUserMsg.data;
        return msg.setStatus(currUserMsg.status);
    } else {
        const currUserObj = await currUserMsg.data.asJson();
        currUser = new AuthUser(currUserObj);
    }
    if (newUser && !newUser.passwordIsMaskOrEmpty()) {
        try {
            context.logger.info(`user ${newUser.email} setting password to ${newUser.password.substr(0, 3)}...`);
            await newUser.hashPassword();
        } catch  {
            return msg.setStatus(500);
        }
    }
    const updatedUser = mapLegalChanges(msg, currUser, newUser);
    if (typeof updatedUser === 'string') {
        context.logger.warning(`illegal user change: ${updatedUser} user: ${JSON.stringify(newUser)}`);
        return msg.setStatus(403, 'illegal user action');
    }
    msg.setDataJson(updatedUser);
    return msg;
}
const service16 = new Service();
const service17 = new Service();
class TemporaryAccessState extends BaseStateClass {
    validTokenExpiries = [];
    tokenBaseUrls = {};
}
const service18 = new Service();
class Modules {
    adapterConstructors;
    serviceManifests;
    adapterManifests;
    services;
    validateServiceManifest;
    validateAdapterManifest;
    validateAdapterConfig;
    validateServiceConfig;
    constructor(ajv){
        this.ajv = ajv;
        this.adapterConstructors = {};
        this.serviceManifests = {};
        this.adapterManifests = {};
        this.services = {};
        this.validateAdapterConfig = {};
        this.validateServiceConfig = {};
        this.validateServiceManifest = ajv.compile(schemaIServiceManifest);
        this.validateAdapterManifest = ajv.compile(schemaIAdapterManifest);
        this.adapterConstructors = {
            "./adapter/LocalFileAdapter.ts": __default9,
            "./adapter/S3FileAdapter.ts": __default11,
            "./adapter/NunjucksTemplateAdapter.ts": NunjucksTemplateAdapter,
            "./adapter/SimpleProxyAdapter.ts": SimpleProxyAdapter,
            "./adapter/AWS4ProxyAdapter.ts": AWS4ProxyAdapter,
            "./adapter/ElasticProxyAdapter.ts": ElasticProxyAdapter,
            "./adapter/ElasticDataAdapter.ts": ElasticDataAdapter,
            "./adapter/ElasticQueryAdapter.ts": ElasticQueryAdapter,
            "./adapter/FileLogReaderAdapter.ts": FileLogReaderAdapter
        };
        this.adapterManifests = {
            "./adapter/LocalFileAdapter.ram.json": __default10,
            "./adapter/S3FileAdapter.ram.json": __default12,
            "./adapter/NunjucksTemplateAdapter.ram.json": __default13,
            "./adapter/SimpleProxyAdapter.ram.json": __default14,
            "./adapter/AWS4ProxyAdapter.ram.json": __default15,
            "./adapter/ElasticProxyAdapter.ram.json": __default16,
            "./adapter/ElasticDataAdapter.ram.json": __default17,
            "./adapter/ElasticQueryAdapter.ram.json": __default18,
            "./adapter/FileLogReaderAdapter.ram.json": __default19
        };
        Object.entries(this.adapterManifests).forEach(([url, v])=>{
            v.source = url;
            this.validateAdapterConfig[url] = this.ajv.compile(this.adapterManifests[url].configSchema || {});
        });
        this.services = {
            "./services/services.ts": service12,
            "./services/auth.ts": service13,
            "./services/data.ts": service,
            "./services/dataset.ts": service1,
            "./services/file.ts": service2,
            "./services/lib.ts": service3,
            "./services/pipeline.ts": service14,
            "./services/pipeline-store.ts": service15,
            "./services/static-site-filter.ts": service4,
            "./services/user-filter.ts": service16,
            "./services/template.ts": service5,
            "./services/proxy.ts": service6,
            "./services/email.ts": service7,
            "./services/account.ts": service17,
            "./services/discord.ts": service8,
            "./services/temporary-access.ts": service18,
            "./services/query.ts": service9,
            "./services/csvConverter.ts": service10,
            "./services/logReader.ts": service11
        };
        this.serviceManifests = {
            "./services/services.rsm.json": __default20,
            "./services/auth.rsm.json": __default21,
            "./services/data.rsm.json": __default22,
            "./services/dataset.rsm.json": __default23,
            "./services/file.rsm.json": __default24,
            "./services/lib.rsm.json": __default25,
            "./services/pipeline.rsm.json": __default26,
            "./services/pipeline-store.rsm.json": __default27,
            "./services/static-site-filter.rsm.json": __default28,
            "./services/static-site.rsm.json": __default29,
            "./services/user-data.rsm.json": __default30,
            "./services/user-filter.rsm.json": __default31,
            "./services/template.rsm.json": __default32,
            "./services/proxy.rsm.json": __default33,
            "./services/email.rsm.json": __default34,
            "./services/account.rsm.json": __default35,
            "./services/discord.rsm.json": __default36,
            "./services/temporary-access.rsm.json": __default37,
            "./services/query.rsm.json": __default38,
            "./services/csvConverter.rsm.json": __default39,
            "./services/logReader.rsm.json": __default40
        };
        Object.entries(this.serviceManifests).forEach(([url, v])=>{
            v.source = url;
            this.ensureServiceConfigValidator(url);
        });
    }
    async getConfigAdapter(tenant) {
        const configStoreAdapterSpec = {
            ...config.server.infra[config.server.configStore]
        };
        configStoreAdapterSpec.basePath = "/";
        const context = makeServiceContext(tenant, nullState);
        const configAdapter = await config.modules.getAdapter(configStoreAdapterSpec.adapterSource, context, configStoreAdapterSpec);
        return configAdapter;
    }
    async getAdapterConstructor(url) {
        if (!this.adapterConstructors[url]) {
            try {
                const module = await import(url);
                this.adapterConstructors[url] = module.default;
            } catch (err) {
                throw new Error(`failed to load adapter at ${url}: ${err}`);
            }
        }
        return this.adapterConstructors[url];
    }
    async getAdapterManifest(url) {
        if (!this.adapterManifests[url]) {
            try {
                const manifestJson = await Deno.readTextFile(url);
                const manifest = JSON.parse(manifestJson);
                manifest.source = url;
                this.adapterManifests[url] = manifest;
            } catch (err) {
                return `failed to load manifest at ${url}: ${err}`;
            }
            if (!this.validateAdapterManifest(this.adapterManifests[url])) {
                return `bad format manifest at ${url}: ${getErrors(this.validateAdapterManifest)}`;
            }
            if (!this.validateAdapterConfig[url]) {
                this.validateAdapterConfig[url] = this.ajv.compile(this.adapterManifests[url].configSchema || {});
            }
        }
        return this.adapterManifests[url];
    }
    async getAdapter(url, context, config) {
        if (url.split('?')[0].endsWith('.ram.json')) {
            const manifest = await this.getAdapterManifest(url);
            if (typeof manifest === 'string') throw new Error(manifest);
            url = manifest.moduleUrl;
        }
        const constr = await this.getAdapterConstructor(url);
        return new constr(context, config);
    }
    ensureServiceConfigValidator(url) {
        if (!this.validateServiceConfig[url]) {
            try {
                let configSchema = schemaIServiceConfig;
                const serviceManifest = this.serviceManifests[url];
                if (serviceManifest.configSchema) {
                    configSchema = assignProperties(serviceManifest.configSchema, schemaIServiceConfig);
                    let resolvedUrl = url;
                    if (resolvedUrl.startsWith('.')) resolvedUrl = 'https://restspace.io/builtin-services' + resolvedUrl.substring(1);
                    configSchema.$id = resolvedUrl;
                }
                this.validateServiceConfig[url] = this.ajv.compile(configSchema);
            } catch (err) {
                throw new Error(`Failed to compile service config validator for ${url}`, err);
            }
        }
    }
    async getServiceManifest(url) {
        if (!this.serviceManifests[url]) {
            try {
                const manifestJson = await Deno.readTextFile(url);
                const manifest = JSON.parse(manifestJson);
                manifest.source = url;
                this.serviceManifests[url] = manifest;
            } catch (err) {
                return `failed to load manifest at ${url}: ${err}`;
            }
            if (!this.validateServiceManifest(this.serviceManifests[url])) {
                return `bad format manifest at ${url}: ${(this.validateServiceManifest.errors || []).map((e)=>e.message).join('; ')}`;
            }
            this.ensureServiceConfigValidator(url);
        }
        return this.serviceManifests[url];
    }
    async getService(url) {
        if (url === undefined) {
            return Service.Identity;
        }
        if (url.split('?')[0].endsWith('.rsm.json')) {
            const manifest = await this.getServiceManifest(url);
            if (typeof manifest === 'string') throw new Error(manifest);
            url = manifest.moduleUrl;
            if (url === undefined) return Service.Identity;
        }
        if (!this.services[url]) {
            try {
                config.logger.debug(`Start -- loading service at ${url}`);
                const module = await import(url);
                this.services[url] = module.default;
                config.logger.debug(`End -- loading service at ${url}`);
            } catch (err) {
                throw new Error(`failed to load module at ${url}: ${err}`);
            }
        }
        return this.services[url];
    }
    ajv;
}
(function(TokenVerification) {
    TokenVerification["noMatch"] = "noMatch";
    TokenVerification["expired"] = "expired";
    TokenVerification["ok"] = "ok";
    TokenVerification["used"] = "used";
})(TokenVerification || (TokenVerification = {}));
class Authoriser {
    key = null;
    anonPathRoots = [];
    async ensureKey() {
        if (!this.key) {
            this.key = await crypto.subtle.generateKey({
                name: "HMAC",
                hash: "SHA-512"
            }, true, [
                "sign",
                "verify"
            ]);
        }
    }
    registerAnonPathRoots(pathRoots) {
        if (this.anonPathRoots.length > 0) {
            throw new Error('Cant specify anonymous auth path roots more than once');
        }
        this.anonPathRoots = pathRoots;
    }
    generateToken() {
        return crypto.randomUUID();
    }
    verifyToken(token, user) {
        const tokenMatch = user.token === token;
        if (!tokenMatch) return TokenVerification.noMatch;
        let notExpired = false;
        if (user.tokenExpiry) {
            const tokenExpiryDate = new Date(user.tokenExpiry);
            notExpired = tokenExpiryDate.getTime() > new Date().getTime();
        } else {
            return TokenVerification.used;
        }
        if (tokenMatch && notExpired) {
            return TokenVerification.ok;
        } else {
            return TokenVerification.expired;
        }
    }
    async getJwt(user, expirySecs) {
        await this.ensureKey();
        return await create1({
            alg: "HS512",
            typ: "JWT"
        }, {
            ...user.getJwtPayload(),
            exp: getNumericDate(expirySecs || config.jwtExpiryMins * 60)
        }, this.key);
    }
    async getImpersonationJwt(user, newEmail, newRoles) {
        await this.ensureKey();
        const impersonationJwtPayload = user.getJwtPayload();
        if (newRoles) impersonationJwtPayload.roles = newRoles;
        impersonationJwtPayload.email = newEmail;
        if (newEmail !== (user.originalEmail || user.email)) {
            impersonationJwtPayload.originalEmail = user.email;
        }
        impersonationJwtPayload.exp = getNumericDate(config.jwtExpiryMins * 60);
        return await create1({
            alg: "HS512",
            typ: "JWT"
        }, {
            ...impersonationJwtPayload
        }, this.key);
    }
    async verifyJwtHeader(authHeader, authCookie, path) {
        const isAnonPath = this.anonPathRoots.filter((root)=>path.startsWith(root)).length > 0;
        if (isAnonPath) {
            return 'anon';
        }
        let jwToken = '';
        if (authHeader) {
            const hdrParts = authHeader.split(' ');
            if (hdrParts.length < 2) return '';
            jwToken = hdrParts[1];
        } else if (authCookie) {
            jwToken = authCookie;
        } else {
            return '';
        }
        await this.ensureKey();
        let payload;
        try {
            payload = await verify2(jwToken, this.key);
        } catch (err) {
            config.logger.error('jwt verify error: ' + err);
            return '';
        }
        return payload;
    }
}
const ajv2 = new __pika_web_default_export_for_treeshaking__1({
    allErrors: true,
    strictSchema: false,
    allowUnionTypes: true
});
const config = {
    server: {},
    modules: new Modules(ajv2),
    tenants: {},
    logger: getLogger1(),
    fixRelativeToRoot: (pathUrl)=>pathUrl.startsWith('.') ? resolve2(pathUrl) : pathUrl,
    ajv: ajv2,
    jwtExpiryMins: 30,
    getParam: (key)=>Deno.env.get(key),
    authoriser: new Authoriser(),
    validateChordService: ajv2.compile(schemaIChordServiceConfig),
    validateChord: ajv2.compile({
        type: "object",
        properties: {
            id: {
                type: "string"
            },
            newServices: {
                type: "array",
                items: {
                    schemaIChordServiceConfig
                }
            }
        }
    }),
    requestExternal: (msg)=>msg.requestExternal()
};
const setupLogging = async (level)=>{
    await setup1({
        handlers: {
            console: new handlers.ConsoleHandler(level, {
                formatter
            }),
            file: new handlers.RotatingFileHandler(level, {
                maxBytes: 512 * 1024,
                maxBackupCount: 5,
                filename: './main.log',
                formatter
            })
        },
        loggers: {
            default: {
                level,
                handlers: [
                    'console',
                    'file'
                ]
            }
        }
    });
    config.logger = getLogger1();
};
class Tenant {
    serviceFactory;
    authService;
    authServiceConfig;
    servicesConfig;
    chordMap;
    _state;
    state;
    get primaryDomain() {
        const name = this.name === "main" ? '' : this.name;
        return this.domains[0] || name + '.' + config.server.mainDomain;
    }
    get isEmpty() {
        return Object.keys(this.rawServicesConfig).length === 0;
    }
    constructor(name, rawServicesConfig, domains){
        this.name = name;
        this.rawServicesConfig = rawServicesConfig;
        this.domains = domains;
        this.servicesConfig = null;
        this.chordMap = {};
        this._state = {};
        this.state = (basePath)=>async (cons, context, config)=>{
                if (this._state[basePath] === undefined) {
                    const newState = new cons();
                    this._state[basePath] = newState;
                    await newState.load(context, config);
                }
                if (!(this._state[basePath] instanceof cons)) throw new Error('Changed type of state attached to service');
                return this._state[basePath];
            };
        this.serviceFactory = new ServiceFactory(name);
    }
    getSources(serviceRecord) {
        return Array.isArray(serviceRecord) ? serviceRecord.map((serv)=>serv.source) : Object.values(serviceRecord).map((serv)=>serv.source);
    }
    extractSources() {
        return [
            ...this.getSources(this.rawServicesConfig.services),
            ...[
                ...Object.values(this.rawServicesConfig?.chords || {}),
                baseChord
            ].flatMap((chord)=>[
                    ...this.getSources(chord.newServices || [])
                ])
        ];
    }
    async applyChord(services, chordKey, chord) {
        this.chordMap[chordKey] = {};
        for (const service of chord.newServices || []){
            if (!config.validateChordService(service)) {
                throw new Error(`Chord ${chord['id']} service ${service['name'] || '<unnamed>'} was misformatted: ${getErrors(config.validateChordService)}`);
            }
            if (services[service.basePath]) {
                const matchService = {
                    ...service
                };
                delete matchService.name;
                delete matchService.localDir;
                if (!deepEqualIfPresent(services[service.basePath], matchService)) {
                    throw new Error(`chord ${chord.id} chord key ${chordKey} fails to match existing service on ${service.basePath}`);
                }
            } else {
                const newService = this.applyDefaults(service);
                if (!(newService.infraName || newService.adapterSource)) {
                    const manifest = this.serviceFactory.serviceManifestsBySource[newService.source];
                    if (manifest.adapterInterface) {
                        const infraName = await this.serviceFactory.infraForAdapterInterface(manifest.adapterInterface);
                        if (!infraName) {
                            throw new Error(`chord ${chord.id} chord key ${chordKey} service ${service.name} requires infraName or adapterSource property to be manually set`);
                        }
                        newService.infraName = infraName;
                    }
                }
                services[service.basePath] = newService;
            }
            this.chordMap[chordKey][service.name] = service.basePath;
        }
    }
    applyDefaults(service) {
        const defaults = this.serviceFactory.serviceManifestsBySource[service.source].defaults;
        if (!defaults) return service;
        const defaultedService = structuredClone(defaults);
        mergeDeep(defaultedService, service);
        return defaultedService;
    }
    async buildServicesConfig(rawServicesConfig) {
        const services = {
            ...rawServicesConfig.services
        };
        Object.keys(services).forEach((k)=>services[k] = this.applyDefaults(services[k]));
        const servicesConfig = {
            services,
            authServicePath: rawServicesConfig.authServicePath
        };
        await this.applyChord(servicesConfig.services, "base", baseChord);
        for (const [chordKey, chord] of Object.entries(rawServicesConfig.chords || {})){
            await this.applyChord(servicesConfig.services, chordKey, chord);
        }
        Object.keys(servicesConfig.services).forEach((keyPath)=>servicesConfig.services[keyPath].basePath = keyPath);
        return servicesConfig;
    }
    async init() {
        await this.serviceFactory.loadServiceManifests(this.extractSources());
        this.servicesConfig = await this.buildServicesConfig(this.rawServicesConfig);
        this.serviceFactory.serviceConfigs = this.servicesConfig.services;
        await this.serviceFactory.loadAdapterManifests();
        await Promise.all(Object.values(this.serviceFactory.serviceConfigs).map((config)=>{
            const context = makeServiceContext(this.name, this.state(config.basePath));
            return this.serviceFactory.initService(config, context).catch((reason)=>{
                throw new Error(`Service ${config.name} failed to initialize: ${reason}`);
            });
        })).catch((reason)=>{
            config.logger.error(`Failed to init all services, ${reason}`, this.name);
            throw new Error(`${reason}`);
        });
        const res = await this.serviceFactory.getServiceAndConfigByApi("auth");
        if (res) {
            const [authService, authServiceConfig] = res;
            this.authService = authService;
            this.authServiceConfig = authServiceConfig;
        }
    }
    async unload() {
        await Promise.allSettled(Object.values(this._state).map((cls)=>cls.unload()));
    }
    getMessageFunctionByUrl(url, source) {
        return this.serviceFactory.getMessageFunctionByUrl(url, makeServiceContext(this.name, nullState), this.state, source);
    }
    getMessageFunctionForService(serviceConfig, source, prePost) {
        return this.serviceFactory.getMessageFunctionForService(serviceConfig, makeServiceContext(this.name, this.state(serviceConfig.basePath), prePost), source);
    }
    async attachUser(msg) {
        if (this.authService) {
            msg = await this.authService.setUserFunc(msg, makeServiceContext(this.name, this.state(this.authServiceConfig.basePath)), this.authServiceConfig);
        }
        if (!msg.user) {
            msg.user = AuthUser.anon;
            msg.authenticated = false;
        }
        return msg;
    }
    name;
    rawServicesConfig;
    domains;
}
const tenantLoads = {};
const tenantLoadTimeoutMs = 5000;
const getTenant = async (requestTenant)=>{
    const tenantLoad = tenantLoads[requestTenant];
    if (tenantLoad !== undefined) {
        await tenantLoads[requestTenant];
    }
    if (!config.tenants[requestTenant]) {
        let resolveLoad = null;
        let timeoutHandle = null;
        try {
            config.logger.debug(`Start -- load tenant ${requestTenant}`, requestTenant);
            tenantLoads[requestTenant] = new Promise((resolve)=>resolveLoad = resolve);
            timeoutHandle = setTimeout(()=>{
                if (resolveLoad) {
                    resolveLoad();
                }
                config.logger.error(`Timeout loading services for tenant ${requestTenant}`, requestTenant);
                config.tenants[requestTenant] = new Tenant(requestTenant, {
                    services: {}
                }, []);
                timeoutHandle = null;
            }, tenantLoadTimeoutMs);
            const tenantAdapter = await config.modules.getConfigAdapter(requestTenant);
            const servicesRes = await tenantAdapter.read('services.json');
            if (!servicesRes.ok) {
                throw new Error('Could not read services.json');
            }
            const servicesConfig = await servicesRes.asJson();
            const tenantDomains = Object.entries(config.server.domainMap).filter(([, ten])=>ten === requestTenant).map(([dom, ])=>dom);
            config.tenants[requestTenant] = new Tenant(requestTenant, servicesConfig, tenantDomains);
            await config.tenants[requestTenant].init();
            config.logger.info(`Loaded tenant ${requestTenant} successfully`, requestTenant);
        } catch (err) {
            config.logger.error(`Failed to load services for tenant ${requestTenant}: ${err}`, requestTenant);
            config.tenants[requestTenant] = new Tenant(requestTenant, {
                services: {}
            }, []);
            throw err;
        } finally{
            if (timeoutHandle !== null) clearTimeout(timeoutHandle);
            if (resolveLoad) resolveLoad();
        }
    }
    return config.tenants[requestTenant];
};
service12.getPath('catalogue', (msg)=>{
    if (catalogue === null) {
        catalogue = {
            services: {},
            adapters: {},
            infra: {}
        };
        for (const [name, serviceManifest] of Object.entries(config.modules.serviceManifests)){
            const manifest = {
                ...serviceManifest
            };
            deleteManifestProperties.forEach((prop)=>delete manifest[prop]);
            manifest.source = name;
            catalogue.services[manifest.name] = manifest;
        }
        for (const [name1, adapterManifest] of Object.entries(config.modules.adapterManifests)){
            const manifest1 = adapterManifest;
            manifest1.source = name1;
            catalogue.adapters[manifest1.name] = manifest1;
        }
        for (const [name2, infra] of Object.entries(config.server.infra)){
            catalogue.infra[name2] = {
                adapterSource: infra.adapterSource,
                preconfigured: Object.keys(infra).filter((k)=>k !== 'adapterSource')
            };
        }
    }
    const baseSchema = schemaIServiceConfig;
    baseSchema.properties.source.enum = Object.values(catalogue.services).map((serv)=>serv.source);
    return Promise.resolve(msg.setDataJson({
        baseSchema: schemaIServiceConfig,
        catalogue
    }));
});
service12.getPath('services', async (msg, context)=>{
    const tenant = config.tenants[context.tenant];
    const manifestData = {};
    for (const serv of Object.values(tenant.servicesConfig.services)){
        if (!manifestData[serv.source]) {
            const manifest = await config.modules.getServiceManifest(serv.source);
            if (typeof manifest === 'string') return msg.setStatus(500, 'Server error');
            manifestData[serv.source] = {
                exposedConfigProperties: manifest.exposedConfigProperties || [],
                apis: manifest.apis
            };
        }
    }
    const services = {};
    Object.entries(tenant.servicesConfig.services).forEach(([basePath, service])=>{
        const sanitisedService = {};
        const exposedProperties = schemaIServiceConfigExposedProperties.concat(manifestData[service.source].exposedConfigProperties || []);
        Object.entries(service).filter(([k])=>exposedProperties.includes(k)).forEach(([k, v])=>sanitisedService[k] = v);
        sanitisedService['apis'] = manifestData[service.source].apis;
        services[basePath] = sanitisedService;
    });
    return msg.setDataJson(services);
});
const getRaw = (msg, context)=>{
    const tenant = config.tenants[context.tenant];
    return Promise.resolve(msg.setDataJson(tenant.rawServicesConfig));
};
service12.getPath('raw', getRaw);
service12.getPath('raw.json', getRaw);
const rebuildConfig = async (rawServicesConfig, tenant)=>{
    let newTenant;
    try {
        newTenant = new Tenant(tenant, rawServicesConfig, config.tenants[tenant].domains);
        await newTenant.init();
    } catch (err) {
        return [
            400,
            `Bad config for tenant ${tenant}: ${err}`
        ];
    }
    try {
        await config.tenants[tenant].unload();
    } catch (err1) {
        config.logger.error(`Failed to unload tenant ${tenant} successfully, resources may have been leaked`, tenant);
    }
    config.tenants[tenant] = newTenant;
    (async ()=>{
        try {
            const configAdapter = await config.modules.getConfigAdapter(tenant);
            await configAdapter.write('services.json', MessageBody.fromObject(rawServicesConfig));
        } catch (err) {
            config.logger.error(`Failed to write back tenant config: ${tenant}`, tenant);
        }
    })();
    return [
        0,
        ''
    ];
};
class PipelineStep {
    condition;
    spec;
    rename;
    tryMode;
    method;
    constructor(step){
        this.step = step;
        this.condition = null;
        this.spec = '';
        this.rename = '';
        this.tryMode = false;
        this.method = '';
        let pos = 0;
        step = step.trim();
        let [match, posNew] = matchFirst(step, pos, [
            "try"
        ]);
        if (match === "try") {
            this.tryMode = true;
            pos = posNew;
        }
        let conditionPart;
        [conditionPart, posNew] = PipelineCondition.scan(step, pos);
        this.condition = conditionPart;
        if (posNew > 0) pos = posNew;
        if (step[pos] === ':') {
            [match, posNew] = [
                " :",
                pos + 1
            ];
        } else {
            [match, posNew] = scanFirst(step, pos, [
                " :"
            ]);
        }
        if (match === " :") {
            this.spec = step.substring(pos, posNew - 2).trim();
            this.rename = upTo(step, " ", posNew);
        } else {
            this.spec = step.substring(pos).trim();
        }
    }
    test(msg, mode, context) {
        return !(this.condition && !this.condition.satisfies(msg, mode, context));
    }
    execute(msg, context) {
        const sendMsg = (msg)=>{
            if (context.targetHost && !msg.url.domain) {
                msg.url.domain = context.targetHost.domain;
                msg.url.scheme = context.targetHost.scheme;
            }
            if (context.targetHost && msg.url.domain === context.targetHost.domain) {
                Object.assign(msg.headers, context.targetHeaders);
            }
            msg.startSpan();
            return context.concurrencyLimiter(()=>context.handler(msg));
        };
        const innerExecute = async ()=>{
            try {
                let outMsg = msg;
                if (this.spec) {
                    const newMsg_s = await msg.divertToSpec(this.spec, "POST", context.callerUrl, context.callerMethod, msg.headers);
                    if (Array.isArray(newMsg_s)) {
                        const newMsgs = new AsyncQueue(newMsg_s.length);
                        newMsg_s.forEach((msg, i)=>sendMsg(msg).then((outMsg)=>{
                                let prename = '';
                                if (this.rename.startsWith('.')) {
                                    prename = outMsg.name;
                                }
                                if (this.rename) {
                                    outMsg.name = prename + resolvePathPatternWithUrl(this.rename, outMsg.url, undefined, msg.name);
                                } else {
                                    outMsg.name = prename + i.toString();
                                }
                                newMsgs.enqueue(outMsg);
                            }));
                        return newMsgs;
                    } else {
                        outMsg = await sendMsg(newMsg_s);
                    }
                }
                if (this.rename) {
                    let prename = '';
                    if (this.rename.startsWith('.')) {
                        prename = outMsg.name;
                    }
                    outMsg.name = prename + resolvePathPatternWithUrl(this.rename, outMsg.url, undefined, outMsg.name);
                }
                if (this.tryMode) {
                    outMsg.enterConditionalMode();
                }
                if (context.trace) {
                    if (outMsg.data && isJson(outMsg.data.mimeType)) {
                        context.traceOutputs[context.path.join('.')] = await outMsg.data.asJson();
                    }
                }
                return outMsg;
            } catch (err) {
                config.logger.error(`error executing pipeline element: ${this.step}, ${err}`, ...context.callerLoggerArgs || []);
                return msg.setStatus(500, 'Internal Server Error');
            }
        };
        return innerExecute();
    }
    step;
}
function makeServiceContext(tenantName, state, prePost) {
    const context = {
        tenant: tenantName,
        makeRequest: (msg, source)=>source === Source.External ? handleIncomingRequest(msg) : handleOutgoingRequest(msg, source),
        runPipeline: (msg, pipelineSpec, contextUrl)=>{
            pipeline(msg, pipelineSpec, contextUrl);
        },
        prePost,
        logger: config.logger,
        getAdapter: (url, adapterConfig)=>{
            return config.modules.getAdapter(url, context, adapterConfig);
        },
        state
    };
    return context;
}
const putRaw = async (msg, context)=>{
    const rawServicesConfig = await msg?.data?.asJson();
    const [status, message] = await rebuildConfig(rawServicesConfig, context.tenant);
    if (status) return msg.setStatus(status, message);
    return msg.setStatus(200);
};
service12.putPath('raw', putRaw);
service12.putPath('raw.json', putRaw);
const putChords = async (msg, context)=>{
    const chords = await msg?.data?.asJson();
    if (typeof chords !== 'object') return msg.setStatus(400, 'Chords should be an object labelled by chord id');
    const tenant = config.tenants[context.tenant];
    const tenantChords = {
        ...tenant.rawServicesConfig.chords || {}
    };
    for (const chord of Object.values(chords)){
        if (!config.validateChord(chord)) {
            const errors = getErrors(config.validateChord);
            return msg.setStatus(400, chord['id'] ? `Chord ${chord['id']} was misformatted: ${errors}` : 'A chord was misformatted');
        }
        tenantChords[chord.id] = chord;
    }
    const newRawConfig = {
        services: {
            ...tenant.rawServicesConfig.services
        },
        authServicePath: tenant.rawServicesConfig.authServicePath,
        chords: tenantChords
    };
    const [status, message] = await rebuildConfig(newRawConfig, context.tenant);
    return msg.setStatus(status || 200, message);
};
service12.putPath('chords', putChords);
service12.putPath('chords.json', putChords);
const getChordMap = (msg, context)=>{
    const tenant = config.tenants[context.tenant];
    return Promise.resolve(msg.setDataJson(tenant.chordMap));
};
service12.getPath('chord-map', getChordMap);
service12.getPath('chord-map.json', getChordMap);
const openApi = async (msg, context)=>{
    const tenant = config.tenants[context.tenant];
    const spec = {
        openApi: "3.0.3",
        info: {
            title: tenant.name,
            description: 'Restspace API',
            version: "1.0.0"
        },
        paths: {},
        components: {},
        externalDocs: {
            description: "Services documentation",
            url: "https://restspace.io/docs/services"
        }
    };
    const manifestData = {};
    for (const serv of Object.values(tenant.servicesConfig.services)){
        if (!manifestData[serv.source]) {
            const manifest = await config.modules.getServiceManifest(serv.source);
            if (typeof manifest === 'string') return msg.setStatus(500, 'Server error');
            let apiPattern = "store";
            if (manifest.apis?.includes('store-transform')) apiPattern = "storeTransform";
            else if (manifest.apis?.includes('transform')) apiPattern = "transform";
            else if (manifest.apis?.includes('view')) apiPattern = "view";
            else if (manifest.apis?.includes('operation')) apiPattern = "operation";
            switch(apiPattern){
                case "store":
                    spec.paths[serv.basePath + '/{servicePath}'] = {
                        description: manifest.description,
                        get: {
                            description: "read the item at this servicePath",
                            responses: {
                                "200": {
                                    description: "returns the item"
                                },
                                "404": {
                                    description: "there is no item at this servicePath"
                                }
                            }
                        },
                        post: {
                            description: "write the item at this servicePath, and get the written item as a response",
                            responses: {
                                "200": {
                                    description: "The item was updated successfully, response is the item as updated"
                                },
                                "201": {
                                    description: "The item was created successfully, response is the item as created"
                                }
                            }
                        },
                        put: {
                            description: "write the item at this servicePath, and get the written item as a response",
                            responses: {
                                "200": {
                                    description: "The item was updated successfully, response is the item as updated"
                                },
                                "201": {
                                    description: "The item was created successfully, response is the item as created"
                                }
                            }
                        },
                        parameters: {
                            name: "servicePath",
                            in: "path",
                            description: "multi-segment folder path",
                            required: true,
                            schema: {
                                type: "array",
                                items: {
                                    type: "string"
                                },
                                style: "simple",
                                "x-multiSegment": true
                            }
                        }
                    };
                    break;
            }
        }
    }
    return msg.setDataJson(spec);
};
service12.getPath('openApi', openApi);
var PipelineElementType;
(function(PipelineElementType) {
    PipelineElementType[PipelineElementType["parallelizer"] = 0] = "parallelizer";
    PipelineElementType[PipelineElementType["serializer"] = 1] = "serializer";
    PipelineElementType[PipelineElementType["subpipeline"] = 2] = "subpipeline";
    PipelineElementType[PipelineElementType["step"] = 3] = "step";
    PipelineElementType[PipelineElementType["mode"] = 4] = "mode";
    PipelineElementType[PipelineElementType["initializer"] = 5] = "initializer";
    PipelineElementType[PipelineElementType["transform"] = 6] = "transform";
})(PipelineElementType || (PipelineElementType = {}));
var PipelineParallelizer;
(function(PipelineParallelizer) {
    PipelineParallelizer[PipelineParallelizer["dup"] = 0] = "dup";
    PipelineParallelizer[PipelineParallelizer["split"] = 1] = "split";
    PipelineParallelizer[PipelineParallelizer["unzip"] = 2] = "unzip";
    PipelineParallelizer[PipelineParallelizer["jsonSplit"] = 3] = "jsonSplit";
})(PipelineParallelizer || (PipelineParallelizer = {}));
var PipelineSerializer;
(function(PipelineSerializer) {
    PipelineSerializer[PipelineSerializer["jsonObject"] = 0] = "jsonObject";
    PipelineSerializer[PipelineSerializer["zip"] = 1] = "zip";
    PipelineSerializer[PipelineSerializer["multipart"] = 2] = "multipart";
})(PipelineSerializer || (PipelineSerializer = {}));
function parsePipelineElement(el) {
    if (Array.isArray(el)) {
        return [
            PipelineElementType.subpipeline,
            el
        ];
    } else if (typeof el === 'object') {
        return PipelineTransform.isValid(el) ? [
            PipelineElementType.transform,
            new PipelineTransform(el)
        ] : [
            null,
            null
        ];
    } else {
        el = el.trim();
        if (PipelineMode.isValid(el)) return [
            PipelineElementType.mode,
            new PipelineMode(el)
        ];
        if (PipelineParallelizer[el] !== undefined) return [
            PipelineElementType.parallelizer,
            PipelineParallelizer[el]
        ];
        if (PipelineSerializer[el] !== undefined) return [
            PipelineElementType.serializer,
            PipelineSerializer[el]
        ];
        const initializerContext = pipelineInitializerIntoContext(el);
        if (initializerContext) return [
            PipelineElementType.initializer,
            initializerContext
        ];
        try {
            return [
                PipelineElementType.step,
                new PipelineStep(el)
            ];
        } catch  {
            return [
                null,
                null
            ];
        }
    }
}
function testPipeline(pipeline, msg, mode, context) {
    if (pipeline.length === 0) return false;
    for (const item of pipeline){
        const [elType, el] = parsePipelineElement(item);
        if (elType == PipelineElementType.step) {
            return el.test(msg, mode, context);
        }
    }
    return true;
}
function runPipeline(pipeline, msgs, parentMode, context) {
    return msgs.flatMap((msg)=>runPipelineOne(pipeline, msg, parentMode, context));
}
function processStepSucceeded(mode, endedMsgs, stepResult) {
    if (mode.succeed === PipelineAction.end) {
        return stepResult.then((msg_s)=>{
            if (msg_s instanceof AsyncQueue) {
                return msg_s.flatMap((msg)=>{
                    endedMsgs.push(msg);
                    return msg;
                });
            } else {
                endedMsgs.push(msg_s);
                return msg_s;
            }
        });
    } else {
        return stepResult.then((msg_s)=>{
            if (msg_s instanceof Message && (msg_s.isRedirect || !msg_s.ok)) {
                endedMsgs.push(msg_s);
            }
            return msg_s;
        });
    }
}
function processStepFailed(mode, endedMsgs, msg) {
    if (mode.fail === PipelineAction.stop) {
        return null;
    } else if (mode.fail === PipelineAction.next) {
        return msg;
    } else if (mode.fail === PipelineAction.end) {
        endedMsgs.push(msg);
        return msg;
    }
}
function runPipelineOne(pipeline, msg, parentMode, context) {
    let mode = new PipelineMode(parentMode);
    const [elType, el] = parsePipelineElement(pipeline[0]);
    if (elType == PipelineElementType.mode) {
        mode = el;
        pipeline = pipeline.slice(1);
    }
    if (mode.mode == "parallel") {
        return runDistributePipelineOne(pipeline, msg, context);
    }
    let pos = 0;
    let msgs = new AsyncQueue(1).enqueue(msg);
    const endedMsgs = [];
    let depth = context.path.length;
    while(pos < pipeline.length){
        context.path[depth] = pos;
        try {
            const [elType1, el1] = parsePipelineElement(pipeline[pos]);
            let succeeded = false;
            switch(elType1){
                case PipelineElementType.mode:
                    {
                        const newMode = el1;
                        if (!mode.allowedMidstreamChangeTo(newMode)) throw new Error('Cannot change in midstream to mode ' + newMode.toString());
                        mode = newMode;
                        break;
                    }
                case PipelineElementType.step:
                    {
                        const step = el1;
                        const fixedMode = mode;
                        const contextCopy = copyPipelineContext(context);
                        msgs = msgs.flatMap(async (msg)=>{
                            if (endedMsgs.includes(msg)) return msg;
                            succeeded = step.test(msg, fixedMode, contextCopy);
                            if (succeeded) {
                                const stepResult = step.execute(msg, contextCopy);
                                if (!stepResult) return null;
                                return await processStepSucceeded(fixedMode, endedMsgs, stepResult);
                            } else {
                                return processStepFailed(fixedMode, endedMsgs, msg);
                            }
                        });
                        if (step.tryMode) {
                            mode = new PipelineMode("conditional");
                        }
                        break;
                    }
                case PipelineElementType.transform:
                    {
                        const transform = el1;
                        const contextCopy1 = copyPipelineContext(context);
                        msgs = msgs.flatMap((msg)=>{
                            if (endedMsgs.includes(msg)) return msg;
                            return transform.execute(msg, contextCopy1);
                        });
                        break;
                    }
                case PipelineElementType.subpipeline:
                    {
                        const fixedModeSubpipeline = mode;
                        msgs = msgs.flatMap((msg)=>{
                            if (endedMsgs.includes(msg)) return msg;
                            succeeded = testPipeline(el1, msg, fixedModeSubpipeline, context);
                            if (succeeded) {
                                const stepResult = runPipeline(el1, new AsyncQueue(1).enqueue(msg), mode, context);
                                return processStepSucceeded(fixedModeSubpipeline, endedMsgs, Promise.resolve(stepResult));
                            } else {
                                return processStepFailed(fixedModeSubpipeline, endedMsgs, msg);
                            }
                        });
                        break;
                    }
                case PipelineElementType.parallelizer:
                    {
                        const op = el1;
                        switch(op){
                            case PipelineParallelizer.unzip:
                                msgs = msgs.flatMap((msg)=>{
                                    if (endedMsgs.includes(msg)) return msg;
                                    return unzip(msg);
                                });
                                break;
                            case PipelineParallelizer.jsonSplit:
                                msgs = msgs.flatMap((msg)=>{
                                    if (endedMsgs.includes(msg)) return msg;
                                    return jsonSplit(msg);
                                });
                                break;
                        }
                        break;
                    }
                case PipelineElementType.serializer:
                    switch(el1){
                        case PipelineSerializer.zip:
                            msgs = AsyncQueue.fromPromises(zip(msgs));
                            break;
                        case PipelineSerializer.jsonObject:
                            msgs = AsyncQueue.fromPromises(jsonObject(msgs));
                            break;
                    }
                    break;
                default:
                    throw new Error(`unrecognized pipeline element ${JSON.stringify(pipeline[pos])}`);
            }
        } catch (err) {
            config.logger.error(`pipeline error stage = '${pipeline[pos]}': ${err}`, ...context.callerLoggerArgs || []);
            context.path.pop();
            return msgs.flatMap(()=>err);
        }
        pos++;
    }
    context.path.pop();
    msgs = msgs.flatMap((msg)=>msg.exitConditionalMode());
    if (mode.tee) {
        const runTeedPipeline = async ()=>{
            for await (const _ of msgs){}
        };
        if (mode.teeWait) {
            const result = new AsyncQueue(1);
            runTeedPipeline().then(()=>result.enqueue(msg));
            return result;
        } else {
            runTeedPipeline();
            return new AsyncQueue(1).enqueue(msg);
        }
    }
    return msgs;
}
function runDistributePipelineOne(pipeline, msg, context) {
    let pos = 0;
    const msgs = new AsyncQueue(pipeline.length);
    const depth = context.path.length;
    while(pos < pipeline.length){
        context.path[depth] = pos;
        try {
            const [elType, el] = parsePipelineElement(pipeline[pos]);
            const newMsg = msg.copyWithData();
            let succeeded = false;
            switch(elType){
                case PipelineElementType.step:
                    {
                        const step = el;
                        succeeded = step.test(newMsg, PipelineMode.parallel(), context);
                        if (succeeded) {
                            const stepResult = step.execute(newMsg, context);
                            msgs.enqueue(stepResult);
                        } else {
                            msgs.enqueue(null);
                        }
                        break;
                    }
                case PipelineElementType.subpipeline:
                    succeeded = testPipeline(el, newMsg, PipelineMode.parallel(), context);
                    if (succeeded) {
                        const msgsOut = runPipeline(el, new AsyncQueue(1).enqueue(newMsg), new PipelineMode("parallel"), context);
                        msgs.enqueue(msgsOut);
                    } else {
                        msgs.enqueue(null);
                    }
                    break;
                case PipelineElementType.transform:
                    {
                        const transform = el;
                        msgs.enqueue(transform.execute(msg, context));
                        break;
                    }
                default:
                    throw new Error('No operators allowed in parallel sub pipeline');
            }
        } catch (err) {
            context.path.pop();
            msgs.close();
            config.logger.error(`pipeline error stage = '${pipeline[pos]}' ${err}`, ...context.callerLoggerArgs || []);
            return new AsyncQueue(1).enqueue(err);
        }
        pos++;
    }
    context.path.pop();
    return msgs;
}
function createInitialContext(pipeline, handler, callerMsg, contextUrl, external) {
    const context = {
        handler,
        callerUrl: contextUrl || callerMsg.url,
        callerMethod: callerMsg.method,
        callerLoggerArgs: callerMsg.loggerArgs(),
        external,
        path: [],
        concurrencyLimiter: limitConcurrency(12)
    };
    let stepIdx = 0;
    for(; stepIdx < pipeline.length; stepIdx++){
        const [elType, el] = parsePipelineElement(pipeline[stepIdx]);
        if (elType !== PipelineElementType.initializer) break;
        Object.assign(context, el);
    }
    if (context.targetHost) {
        context.targetHeaders = {};
        if (callerMsg.getHeader('authorization')) {
            context.targetHeaders['authorization'] = callerMsg.getHeader('authorization');
        }
    } else {
        context.targetHost = new Url();
        context.targetHost.domain = callerMsg.url.domain;
        context.targetHost.scheme = callerMsg.url.scheme;
    }
    return [
        context,
        pipeline.slice(stepIdx)
    ];
}
async function pipeline(msg, pipeline, contextUrl, external, handler = handleOutgoingRequest) {
    const [context, mainPipeline] = createInitialContext(pipeline, handler, msg, contextUrl, external);
    const asq = runPipeline(mainPipeline, new AsyncQueue(1).enqueue(msg), new PipelineMode("parallel"), context);
    let lastMsg = null;
    for await (const outMsg of asq){
        lastMsg = outMsg;
    }
    if (lastMsg) {
        lastMsg.url = msg.url;
        Object.assign(lastMsg.headers, context.outputHeaders || {});
        if (context.trace) {
            lastMsg.setDataJson(context.traceOutputs);
        }
        return lastMsg;
    }
    return msg.copy().setStatus(204, '');
}
const tenantFromHostname = (hostname)=>{
    const domainParts = hostname.split('.');
    if (config.server.tenancy === 'single') {
        return '';
    } else if (config.server.domainMap && config.server.domainMap[hostname]) {
        return config.server.domainMap[hostname];
    } else {
        const mainDomain = [];
        mainDomain.unshift(domainParts.pop());
        mainDomain.unshift(domainParts.pop());
        if (mainDomain.join('.').toLowerCase() !== config.server.mainDomain.toLowerCase()) {
            return null;
        }
        return domainParts.join('.');
    }
};
const handleIncomingRequest = async (msg)=>{
    const originalMethod = msg.method;
    try {
        const tenantName = tenantFromHostname(msg.getHeader('host') || 'none');
        if (tenantName === null) return msg.setStatus(404, 'Not found');
        const tenant = await getTenant(tenantName || 'main');
        msg.tenant = tenant.name;
        msg = await tenant.attachUser(msg);
        config.logger.info(`${" ".repeat(msg.depth)}Request ${msg.method} ${msg.url}`, ...msg.loggerArgs());
        const messageFunction = await tenant.getMessageFunctionByUrl(msg.url, Source.External);
        const msgOut = await messageFunction(msg.callDown());
        msgOut.depth = msg.depth;
        config.logger.info(`${" ".repeat(msg.depth)}Respnse ${msg.method} ${msg.url}`, ...msg.loggerArgs());
        msgOut.callUp();
        if (!msgOut.ok) {
            config.logger.info(`${" ".repeat(msg.depth)}Respnse ${msgOut.status} ${await msgOut.data?.asString()} ${msg.method} ${msg.url}`, ...msgOut.loggerArgs());
        }
        return msgOut;
    } catch (err) {
        config.logger.warning(`request processing failed: ${err}`, ...msg.loggerArgs());
        return originalMethod === 'OPTIONS' ? config.server.setServerCors(msg).setStatus(204) : msg.setStatus(500, 'Server error');
    }
};
const handleOutgoingRequest = async (msg, source = Source.Internal)=>{
    const originalMethod = msg.method;
    let tenantName = '';
    try {
        if (msg.url.domain === '' || msg.url.domain === undefined) {
            tenantName = msg.tenant;
            if (msg.url.isRelative) throw new Error(`Cannot request a relative url ${msg.url}`);
        } else {
            tenantName = tenantFromHostname(msg.url.domain);
        }
        let msgOut;
        let tenant;
        if (tenantName !== null) {
            try {
                tenant = await getTenant(tenantName || 'main');
                if (tenant.isEmpty) tenantName = null;
            } catch  {
                tenantName = null;
            }
        }
        if (tenantName !== null) {
            config.logger.info(`${" ".repeat(msg.depth)}Request ${msg.method} ${msg.url}`, ...msg.loggerArgs());
            msg.tenant = tenantName;
            const messageFunction = await tenant.getMessageFunctionByUrl(msg.url, source);
            msgOut = await messageFunction(msg.callDown());
            msgOut.depth = msg.depth;
            config.logger.info(`${" ".repeat(msgOut.depth)}Respnse ${msg.method} ${msg.url}`, ...msg.loggerArgs());
            msgOut.callUp();
        } else {
            config.logger.info(`Request external ${msg.method} ${msg.url}`, ...msg.loggerArgs());
            msgOut = await config.requestExternal(msg);
            config.logger.info(`Respnse external ${msg.method} ${msg.url}`, ...msg.loggerArgs());
        }
        if (!msgOut.ok) {
            config.logger.info(` - Status ${msgOut.status} ${await msgOut.data?.asString()} ${msg.method} ${msg.url}`, ...msgOut.loggerArgs());
        }
        return msgOut;
    } catch (err) {
        config.logger.warning(`request processing failed: ${err}`, ...msg.loggerArgs());
        return originalMethod === 'OPTIONS' && tenantName ? config.server.setServerCors(msg).setStatus(204) : msg.setStatus(500, 'Server error');
    }
};
const handleOutgoingRequestFromPrivateServices = (prePost, privateServices, tenantName)=>async (msg)=>{
        if (msg.url.isRelative) {
            const privateServiceName = msg.url.pathElements[0];
            const serviceConfig = privateServices[privateServiceName];
            if (!serviceConfig) return msg.setStatus(404, 'Not found');
            msg.url.basePathElements = [
                privateServiceName
            ];
            const tenant = config.tenants[tenantName || 'main'];
            const messageFunction = await tenant.getMessageFunctionForService(serviceConfig, Source.Internal, prePost);
            const msgOut = await messageFunction(msg.callDown());
            msgOut.depth = msg.depth;
            msgOut.callUp();
            return msgOut;
        } else {
            return handleOutgoingRequest(msg);
        }
    };
async function setJwt(msg, user, expiryMins) {
    const jwt = await config.authoriser.getJwt(user, expiryMins * 60);
    const timeToExpirySecs = expiryMins * 60;
    const cookieOptions = new CookieOptions({
        httpOnly: true,
        maxAge: timeToExpirySecs
    });
    if (msg.url.scheme === 'https://') {
        cookieOptions.sameSite = SameSiteValue.none;
        cookieOptions.secure = true;
    }
    msg.setCookie('rs-auth', jwt, cookieOptions);
    return timeToExpirySecs;
}
async function login(msg, userUrlPattern, context, config) {
    const userSpec = await msg.data.asJson();
    const fullUser = await getUserFromEmail(context, userUrlPattern, msg, userSpec.email, true);
    if (!fullUser) {
        return msg.setStatus(404, 'no user record');
    }
    const user = new AuthUser(fullUser);
    const match = await user.matchPassword(userSpec.password);
    if (!match) {
        return msg.setStatus(400, 'bad password');
    }
    try {
        const timeToExpirySecs = await setJwt(msg, user, config.sessionTimeoutMins || 30);
        fullUser.password = user.passwordMask();
        fullUser.exp = new Date().getTime() + timeToExpirySecs * 1000;
        return msg.setDataJson(fullUser);
    } catch (err) {
        context.logger.error('get jwt error: ' + err);
        return msg.setStatus(500, 'internal error');
    }
}
function logout(msg) {
    msg.deleteCookie('rs-auth');
    return Promise.resolve(msg);
}
service13.postPath('login', async (msg, context, config)=>{
    const newMsg = await login(msg, config.userUrlPattern, context, config);
    if (config.loginPage && msg.getHeader('referer')) {
        let redirUrl = msg.url.copy();
        try {
            redirUrl = new Url(msg.getHeader('referer'));
        } catch  {}
        if (redirUrl.path !== config.loginPage) return newMsg;
        if (newMsg.ok) {
            if (redirUrl.query['redirect'].length) {
                context.logger.info(`authenticationService redirect from ${msg.url} by query arg to ${redirUrl}`);
                newMsg.redirect(new Url(redirUrl.query['redirect'][0]), true);
            } else {
                redirUrl.query = {
                    ...redirUrl.query,
                    'result': [
                        'succeed'
                    ]
                };
                context.logger.info(`authenticationService redirect from ${msg.url} to add suceed query to ${redirUrl}`);
                newMsg.redirect(redirUrl, true);
            }
        } else {
            redirUrl.query = {
                ...redirUrl.query,
                'result': [
                    'fail'
                ]
            };
            context.logger.info(`authenticationService redirect from ${msg.url} to add fail query to ${redirUrl}`);
            newMsg.redirect(redirUrl, true);
        }
    }
    return newMsg;
});
service13.postPath('logout', (msg)=>logout(msg));
service13.getPath('user', async (msg, context, config)=>{
    if (!msg.user || userIsAnon(msg.user)) {
        return msg.setStatus(401, 'Unauthorized');
    }
    const user = await getUserFromEmail(context, config.userUrlPattern, msg, msg.user.email);
    if (user) {
        user.exp = msg.user.exp;
        return msg.setDataJson(user);
    } else {
        return msg.setStatus(404, "No such user");
    }
});
service13.getPath('timeout', (msg, _context, config)=>msg.setData((config.sessionTimeoutMins || 30).toString(), "text/plain"));
service13.setUser(async (msg, _context, { sessionTimeoutMins  })=>{
    const authCookie = msg.getCookie('rs-auth') || msg.getHeader('authorization');
    if (!authCookie) return msg;
    let authResult = '';
    if (msg.method !== "OPTIONS") {
        authResult = await config.authoriser.verifyJwtHeader(msg.getHeader('authorization'), authCookie, msg.url.path);
    }
    authResult = authResult || 'anon';
    if (typeof authResult === "string") {
        msg.user = new AuthUser({});
    } else {
        msg.user = new AuthUser({
            ...authResult,
            exp: (authResult.exp || 0) * 1000
        });
        const refreshTime = (msg.user.exp || 0) - (sessionTimeoutMins || 30) * 60 * 1000 / 2;
        const nowTime = new Date().getTime();
        if (nowTime > refreshTime) {
            const timeToExpirySecs = await setJwt(msg, msg.user, sessionTimeoutMins || 30);
            const newExpiryTime = nowTime + timeToExpirySecs * 1000;
            msg.user.exp = newExpiryTime;
            config.logger.info(`refreshed to ${new Date(newExpiryTime)}`, ...msg.loggerArgs());
        }
    }
    return msg;
});
service14.all((msg, context, config)=>{
    let runPipeline = config.pipeline;
    if (msg.url.query["$to-step"]) {
        const toStep = parseInt(msg.url.query["$to-step"][0]);
        if (!isNaN(toStep) && toStep < config.pipeline.length - 1) {
            runPipeline = config.pipeline.slice(0, toStep + 1);
        }
    }
    return pipeline(msg, runPipeline, msg.url, false, (msg)=>context.makeRequest(msg, config.reauthenticate ? Source.Outer : Source.Internal));
});
service15.all(async (msg, context)=>{
    const reqForStore = msg.getHeader('X-Restspace-Request-Mode') === 'manage' && msg.method !== 'POST';
    if (reqForStore) return msg;
    const getFromStore = msg.copy().setMethod('GET').setHeader("X-Restspace-Request-Mode", "manage");
    const msgPipelineSpec = await context.makeRequest(getFromStore);
    if (msg.url.isDirectory || !msgPipelineSpec.ok) return msgPipelineSpec;
    let pipelineSpec = await msgPipelineSpec.data.asJson();
    if (msg.url.query["$to-step"]) {
        const toStep = parseInt(msg.url.query["$to-step"][0]);
        if (!isNaN(toStep) && toStep < pipelineSpec.length - 1) {
            pipelineSpec = pipelineSpec.slice(0, toStep + 1);
        }
    }
    const pipelineUrl = msg.url.copy();
    pipelineUrl.setSubpathFromUrl(msgPipelineSpec.getHeader('location') || '');
    return pipeline(msg, pipelineSpec, pipelineUrl, false, (msg)=>context.makeRequest(msg));
});
service16.get(async (msg, context)=>{
    if (context.prePost !== "post" || !msg.ok || !msg.data || msg.data.mimeType === 'application/schema+json' || msg.url.isDirectory) return msg;
    if (msg.url.query['test'] !== undefined) {
        msg.data = undefined;
        return msg;
    }
    const originalMime = msg.data.mimeType;
    let user;
    try {
        const userObj = await msg.data.asJson();
        user = new AuthUser(userObj);
    } catch  {
        if (!msg.ok) return msg;
        return msg.setStatus(500, 'User data misformatted');
    }
    if (!msg.internalPrivilege) {
        user.password = user.passwordMask();
    } else {
        msg.internalPrivilege = false;
    }
    msg.setDataJson(user);
    msg.data.mimeType = originalMime;
    return msg;
});
service16.put(validateChange);
service16.post(validateChange);
service16.delete(validateChange);
const sendTokenUrl = async (msg, context, serviceConfig, subservice)=>{
    if (msg.url.servicePathElements.length < 1) return msg.setStatus(400, 'Missing email');
    const user = await getUserFromEmail(context, serviceConfig.userUrlPattern, msg, msg.url.servicePathElements[0], true);
    if (!user) return msg.setStatus(400, 'No such user');
    user.token = await config.authoriser.generateToken();
    const expiry = new Date().getTime() + (subservice.tokenExpiryMins || 30) * 1000 * 60;
    user.tokenExpiry = new Date(expiry);
    const saveOutMsg = await saveUser(context, serviceConfig.userUrlPattern, msg, user, true);
    if (!saveOutMsg.ok) return saveOutMsg;
    const returnPageUrl = new Url(subservice.returnPageUrl);
    if (!returnPageUrl.domain) {
        returnPageUrl.scheme = msg.url.scheme;
        returnPageUrl.domain = config.tenants[context.tenant].primaryDomain;
    }
    returnPageUrl.query = {
        token: [
            user.token
        ],
        email: [
            user.email
        ]
    };
    user['returnPageUrl'] = returnPageUrl.toString();
    const templateMsg = msg.copy().setMethod('POST').setUrl(subservice.emailTemplateUrl).setDataJson(user);
    const emailMsg = await context.makeRequest(templateMsg);
    if (!emailMsg.ok) return emailMsg;
    emailMsg.url = Url.fromPathPattern(serviceConfig.emailSendUrlPattern, msg.url, {
        email: user.email
    });
    emailMsg.method = 'POST';
    const outMsg = await context.makeRequest(emailMsg);
    return outMsg;
};
const tokenUserUpdate = async (msg, context, serviceConfig, updateUser)=>{
    if (msg.url.servicePathElements.length < 1) return msg.setStatus(400, 'Missing email');
    const json = await msg.data.asJson();
    let user = await getUserFromEmail(context, serviceConfig.userUrlPattern, msg, msg.url.servicePathElements[0], true);
    if (!user) return msg.setStatus(400, 'No such user');
    const verification = await config.authoriser.verifyToken(json.token, user);
    if (verification !== TokenVerification.ok) {
        let statusMsg = 'Unknown';
        switch(verification){
            case TokenVerification.noMatch:
                statusMsg = 'Bad token';
                break;
            case TokenVerification.expired:
                statusMsg = 'Expired';
                break;
            case TokenVerification.used:
                statusMsg = 'Token used';
                break;
        }
        return msg.setStatus(401, statusMsg);
    }
    user = await updateUser(user, json);
    delete user.tokenExpiry;
    const outMsg = await saveUser(context, serviceConfig.userUrlPattern, msg, user, true);
    outMsg.setData(null, '');
    return outMsg;
};
const tokenPasswordSchema = {
    type: 'object',
    properties: {
        token: {
            type: 'string'
        },
        password: {
            type: 'string'
        }
    }
};
const tokenVerifySchema = {
    type: "object",
    properties: {
        token: {
            type: "string"
        }
    }
};
service17.postPath('reset-password', (msg, context, config)=>{
    if (!config.passwordReset) return Promise.resolve(msg.setStatus(404, 'Not found'));
    return sendTokenUrl(msg, context, config, config.passwordReset);
});
service17.postPath('token-update-password', (msg, context, config)=>{
    return tokenUserUpdate(msg, context, config, async (userData, posted)=>{
        const user = new AuthUser(userData);
        user.password = posted['password'];
        await user.hashPassword();
        return user;
    });
}, tokenPasswordSchema);
service17.postPath('verify-email', (msg, context, config)=>{
    if (!config.emailConfirm) return Promise.resolve(msg.setStatus(404, 'Not found'));
    return sendTokenUrl(msg, context, config, config.emailConfirm);
});
service17.postPath('confirm-email', (msg, context, config)=>{
    return tokenUserUpdate(msg, context, config, (userData, _posted)=>{
        const user = new AuthUser(userData);
        user.emailVerified = new Date();
        return Promise.resolve(user);
    });
}, tokenVerifySchema);
service18.all(async (msg, context, config)=>{
    const state = await context.state(TemporaryAccessState, context, config);
    const expireTokens = ()=>{
        const now = new Date();
        while(state.validTokenExpiries.length > 0 && state.validTokenExpiries[0][0] < now){
            delete state.tokenBaseUrls[state.validTokenExpiries[0][1]];
            state.validTokenExpiries.shift();
        }
    };
    const key = msg.url.servicePathElements[0];
    expireTokens();
    if (key && state.tokenBaseUrls[key]) {
        msg.url = new Url('/' + msg.url.servicePathElements.slice(1).join('/'));
        if (!msg.url.toString().startsWith(state.tokenBaseUrls[key])) {
            return msg.setStatus(403, "Attempt to access a url outside the base url for which this token is valid");
        }
        msg.user = new AuthUser(msg.user || AuthUser.anon).addRole(config.acquiredRole);
        return context.makeRequest(msg, Source.External);
    } else if (msg.method === 'GET') {
        if (!(msg.user && new AuthUser(msg.user).authorizedFor(config.acquiredRole))) {
            return msg.setStatus(401, "Cannot generate a temporary access token with an acquired role for which the user is not authorized");
        }
        const newToken = crypto.randomUUID();
        const now = new Date();
        const expiry = new Date().setTime(now.getTime() + 1000 * config.expirySecs);
        state.validTokenExpiries.push([
            new Date(expiry),
            newToken
        ]);
        state.tokenBaseUrls[newToken] = '/' + msg.url.servicePath;
        return msg.setText(newToken);
    } else {
        return msg.setStatus(404, "Not found");
    }
});
const getServerConfig = async (serverConfigLocation)=>{
    if (!serverConfigLocation) throw new Error('Missing server config location');
    try {
        const serverConfigText = await Deno.readTextFile(serverConfigLocation);
        const serverConfig = JSON.parse(serverConfigText);
        serverConfig.setServerCors = makeServerCorsSetter();
        return serverConfig;
    } catch (err) {
        throw new Error(`Failed to load server config: ${err}`);
    }
};
const makeServerCorsSetter = ()=>(msg)=>{
        const origin = msg.getHeader('origin');
        if (origin) {
            msg.setHeader('Access-Control-Allow-Origin', origin);
            msg.setHeader('Access-Control-Allow-Headers', 'Origin,X-Requested-With,Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,X-Restspace-Request-Mode');
            msg.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET, HEAD, POST, PUT, PATCH, DELETE');
            msg.setHeader('Access-Control-Allow-Credentials', 'true');
            msg.setHeader('Access-Control-Expose-Headers', 'X-Restspace-Service');
        }
        return msg;
    };
config.server = await getServerConfig(Deno.args[0]);
const port = parseInt(Deno.args[1]) || 3100;
if (isNaN(port)) {
    console.log(`Port argument ${Deno.args[1]} is not a number`);
    Deno.exit(1);
}
const logLevel = Deno.args.length > 2 ? Deno.args[2] : "INFO";
await setupLogging(logLevel);
const listener = Deno.listen({
    port
});
console.log(`receiving requests from http://localhost:${port}/`);
for await (const conn1 of listener){
    (async ()=>{
        try {
            for await (const { request , respondWith  } of Deno.serveHttp(conn1)){
                try {
                    const msgIn = Message.fromRequest(request, '');
                    if (config.server.incomingAlwaysHttps) msgIn.url.scheme = "https://";
                    if (msgIn.getHeader("upgrade") === "websocket") {
                        const { socket , response  } = Deno.upgradeWebSocket(request);
                        msgIn.websocket = socket;
                        await handleIncomingRequest(msgIn);
                        await respondWith(response);
                    }
                    const msgOut = await handleIncomingRequest(msgIn);
                    await respondWith(msgOut.toResponse());
                } catch (err) {
                    console.error('Request loop error: ' + err.toString());
                }
            }
        } catch (err1) {
            console.error(err1);
        }
    })();
}
