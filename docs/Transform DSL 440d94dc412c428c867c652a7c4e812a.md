# Transform DSL

JSON as a data representation language lacks an equivalent standard to XSLT in XML: a way of expressing a transformation of JSON within JSON itself. Restspace therefore has had to create it’s own way of doing this in order to allow data within a pipeline to be transformed before being passed to the next step.

## Transforms by Example

### Simplest transform

Here is possibly the simplest transform:

```jsx
{
  "b": "a"
}
```

Transforms take an *input* object and express how this is transformed to an *output* object.

Generally the shape of the transform is more or less the shape of the output. Here the output has one property, `b`. The values of the properties of the transform can be values, arrays or objects like any JSON data. When the value is a string, the string is evaluated as a Javascript expression. In the context of this expression, all the top-level properties of the input object are available as variables. So here the expression `a` just evaluates to the property `a` on the input object. So if the input was

```jsx
{
  "a": "hello"
}
```

The output would be

```jsx
{
  "b": "hello"
}
```

### Expressions

```jsx
// input
{
  "a": "hello"
}
// transform
{
  "b": "a.substring(1)",
  "c": "'goodbye'"
}
// output
{
  "b": "ello",
  "c": "goodbye"
}
```

Here you can see how to create multiple properties on the output using the shape of the transform, and how to use Javascript expressions in the transform values.

### Structure

```jsx
// input
{
  "a": "hello",
  "b": 1000,
  "c": {
    "x": true,
    "y": 99
  }
}
// transform
{
  "obj": {
    "a": "a",
    "q": "c.x"
  },
  "list": [ "98", "c.y", "100" ]
}
// output
{
  "obj": {
    "a": "hello",
    "q": true
  },
  "list": [ 98, 99, 100 ]
}
```

This shows how (generally) the structure of the transform is reflected on the output, and that every expression in the transform has the top-level properties of the input available as variables.

### Whole output

```jsx
// input
{
	"a": "'hello'",
  "b": {
    "x": "99"
	}
}
// transform
{
  "$": "b",
  "y": "'goodbye'",
  "z": {
		"$": "a"
	}
}
// output
{
  "x": 99,
  "y": "goodbye",
  "z": "hello"
}
```

Some property names are special: the `$` property name means assign the value to the *whole* output object rather than a specific property. When `$` is nested, it works at the level of its nesting i.e. it’s value is assigned to the output object corresponding to transform object on which it’s found.

`$` is assigned before the assignments of any of the specific properties of the output object, and as can be seen these property assignments are ‘superimposed’ on the value of the `$` property.

### Whole input

```jsx
// input
{
  "a": 99
}
// transform
{
	"b": "$"
}
// output
{
	"b": {
		"a": 99
	}
}
```

Similarly you can use `$` as part of an expression to mean the whole input object. The `$` here always refers to the whole top-level input object.

### Modifying input

```jsx
// input
{
	"a": 99,
	"b": "hello",
	"c": {
		"d": 1,
		"e": 2
	}
}
// transform
{
	"$": "$",
	"a": "100",
	"c": {
		"$": "$.c",
		"e": "undefined",
		"f": "3"
	}
}
// output
{
	"a": 100,
	"b": "hello",
	"c": {
		"d": 1,
		"f": 3
	}
}
```

Combining these two provides a commonly-used trick where you copy the whole input to the whole output before making any changes in order to modify the data object rather than create a new object from scratch. As seen above, because the copy is done before the modifications, this behaves as you would expect.

This example also illustrates how to copy input to output on a subobject. As the whole input `$` represents the top-level input always, you need to specify the path to the subobject. The whole output represents the current nested output object.

Also we see how to remove a property from a copied input: simply put `"undefined"` as the value.

### Variables

```jsx
// input
{
  "s1": "'hello'",
	"s2": "'goodbye'"
}
// transform
{
	"$x": "s1.substring(1,2)",
	"sa": "$x + 'xyz'",
	"sb": "$x + 'abc'"
}
// output
{
	"sa": "exyz",
	"sb": "eabc"
}
```

Another special kind of property name in transforms is that any property starting with an `$` is a variable. (This can be avoided by using `$$` as an escape string). Variables are not set as properties on the output object but are instead held in memory for the lifetime of the transform (or of the pipeline when the transform is within a pipeline) in a globally available scope, available to all expressions (at whatever level of nesting). Variables are set up before any other property expressions are calculated as can be seen in this example. Note that within a parallel execution flow in a pipeline, you can see variables set both within and outside the pipeline, however the variables set within the pipeline can have a different value for each parallel execution.

### Special functions

```jsx
// input
{
	"val": [ 1, 2, 3 ]
}
// transform
{
	"$": [
		"expressionMap()",
		"val",
		"$ * 2"
	]
}
// output
[ 2, 4, 6 ]
```

The Transform DSL allows for special functions which are not Javascript builtins to be used. This example shows the use of `expressionMap`. It also shows the use of array function syntax. Special functions are available for use in any value expression, however it can be awkward to use them because of complicated quote escapes. Array function syntax simplifies this. Any array whose first element is a string which is the name of a special function followed by `()` signifies array function syntax is being used. Instead of the value of the array being the array itself with its elements evaluated, the value is the result of the special function called with the arguments which are the values in the rest of the array.

In the example above, `expressionMap` is called to apply the expression in the second argument to all the elements of the list in the first argument.

Most special function arguments are treated like any other value in the Transform DSL, and they are evaluated before being passed in to the function. However in some cases, (such as the second argument of `expressionMap`) the evaluation is postponed to be done within the function itself.

| Name | Arguments | Description |
| --- | --- | --- |
| transformMap | array, transform | `transform` is a transform object to be applied to every element of array in order to get the result |
| expressionReduce | array, init, **expression** | `expression` is an expression which is not evaluated before passing into the function but is evaluated for each element of the array. `$` in this expression refers to the current array element, and `$previous` to the result of the last expression or the init parameter for the first array element. |
| expressionMap | array, **expression** | `expression` is an expression which is not evaluated before passing into the function but is evaluated for each element of the array. `$` in this expression refers to the current array element. The output is the array of evaluation results. |
| expressionFilter | array, **expression** | `expression` is an expression which is not evaluated before passing into the function but is evaluated for each element of the array. ‘$’ in this expression refers to the current array element. The output is the elements of the array where the expression is truthy. |
| expressionFind | array, **expression** | `expression` is an expression which is not evaluated before passing into the function but is evaluated for each element of the array. ‘$’ in this expression refers to the current array element. The output is the first element of the array where the expression is truthy. |
| expressionSort | array, **expression** | `expression` is an expression which is not evaluated before passing into the function but is evaluated for each element of the array. ‘$’ in this expression refers to the current array element. The output is the array sorted by ordering on the expression value. |
| expressionGroup | array, **expression** | `expression` is an expression which is not evaluated before passing into the function but is evaluated for each element of the array. The output is an object where the keys are unique values of this expression across all items, and for each key, the value is a list of items for which the expression evaluates to the key. |
| expressionMax | array, **expression** | `expression` is an expression which is not evaluated before passing into the function but is evaluated for each element of the array. The output is the maximum value of the expression (from Math.max) |
| expressionMin | array, **expression** | `expression` is an expression which is not evaluated before passing into the function but is evaluated for each element of the array. The output is the minimum value of the expression (from Math.min) |
| unique | array | The result is the array with any duplicated elements removed |
| pathCombine | string, … | The result is a string which combines all the arguments as partial url paths in order into one url path with correct separators |
| pathPattern | string, boolean?, string? | Makes the substitutions into the supplied path pattern string using the `url`, `data` and `name` parameters supplied when calling the transform. In a pipeline context, the `url` will be the url on which the pipeline was originally called, the `data` will be the JSON value of the body of the response of the last pipeline request, and `name` will be the name of assigned to the last pipeline request. The boolean? value indicates whether the url segments should be url decoded before insertion (by default, they are not). See [Path Pattern](https://www.notion.so/Path-Pattern-9ea2dc091c3949489c6c540ebea0352e?pvs=21). The optional final string argument lets you explicitly supply the `url` to the function. |
| path | string, object | Returns the property value or list of values pointed to by the first argument which is a [Restspace Json Path](https://www.notion.so/JSON-Path-38cca37a26e8455a928e687e12451249?pvs=21). |
| newDate | any, … | As the `new` operator is not allowed in transform expressions, this creates a new Date object. With no arguments, this is the current date/time. With a single numeric argument, this is used as the milliseconds from epoch to derive a date. With a single string argument. the string is parsed as a text representation of a date. If more than one argument is given, these are interpreted in order as year, month (0-11), day of month, hour, minutes, seconds and milliseconds. All the time arguments are optional. |
| formatDate | date, string? | `string?` is an optional date format descriptor for the [dayjs library](https://day.js.org/docs/en/display/format). The function returns a string representation of the date based on this format descriptor or else the ISO8601 format if no format string is provided. |
| propsToList | object, string? | Turns the property values of `object` into a list, adding to each value in the list a property named `string?` (or `$key` if no parameter is provided) set to the corresponding property name. |
| literal | object | Simply passes back the input object unchanged. This allows using the array function syntax to have a simple JSON object be included in the transform whose values will not be evaluated if strings. |
| merge | object0, object1, … | copies the properties of `object0` then the properties of `object1` etc onto an empty object and returns this. |
| parseInt | string, number? | parses `string` as an integer number and returns this, using the radix given in `number?` or base 10 as default |
| parseFloat | string | parses `string` as a floating-point decimal in base 10 and returns the result |
| uuid |  | returns a random UUID string |
| canonicalise | string | Strips non-alphanumeric characters and spaces, converts accented to non-accented characters, makes lowercase |
| stripHtml | string, boolean? | Removes all HTML tags. If the optional flag is set, it will insert a newline where there is a closing `</p>` tag followed by an opening `<p>` tag. |
| regexp | string, string? | creates a new RegExp, passing the two arguments into the constructor. First arg is pattern, second arg flags: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/RegExp](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/RegExp) |

### Path properties

```jsx
// input
{
	"list": [ 1, 2, 3 ]
}
// transform
{
	"$": "$",
	"a.b": "'hello'",
	"list[item]": "item.value + 1", // adds one to every item in list
	"list[0]": "7" // then this sets the first item to 7
}
// output
{
	"list": [ 7, 3, 4 ],
	"a": {
		"b": "hello"
	}
}
```

Transform DSL allows special property names which are paths. You can see how these behave above. `a.b` sets property b on object a, creating object a if it doesn’t exist. You can use array indexes like `list[0]` to directly set the list item at a literal position.

You can also use a declarative syntax to modify an entire list (or object) which already exists in the output object. In this case, we first use `"$": "$"` to set the whole output item to the whole input item (a common trick). Setting the whole output is done before any other properties are set on the output. Because we know the `list` property already exists on the output, we can then iterate over every item in `list`, using a variable named `item` for the array index in `list[item]` . For every item in `list` the properties of that item can also be referred to in the expression. Every item in the list is set to the value of the expression. `item` can also be referred to in the expression, it is an object with two properties: `index` is the array index and `value` is the whole current value at that index.

### Multiple and object indices

```json
// input
{
    "a": "xyz",
    "b": { 
	    "a": [ { "a": 1 }, { "a": 2 }, { "a": 3 } ],
	    "b": [ { "a": 4 }, { "a": 5 }, { "a": 6 } ]
	  }
}
// transform
{
    "$": "$",
    "b{prop}.[item]": "prop.key + a"
}
// output
{
		"a": "xyz",
		"b": {
			"a": [ "a1", "a2", "a3" ],
			"b": [ "b4", "b5", "b6" ]
		}
}
```

This demonstrates modifying an existing object using a path property with both an object index and a list index. One point about this is that the transform creates two nested loops in this case, the outer one over the object properties and the inner one over the list items. You can see how the `prop` property index can be referred to: it has two properties `value`, like the list index `item` and `key` for the property name. All list index objects are available when evaluating as you can see here.

## Reference

### Expression evaluation and limitations

Expressions are evaluated using an NPM package called [bcx-expression-evaluator](https://www.npmjs.com/package/bcx-expression-evaluator). Importantly, this package is not a full Javascript implementation. It is limited in various ways which should remove the possibility of expressions being able to escape the sandbox in which they are being evaluated, enabling malicious transform expressions to breach security. The following limitations are applied:

- Function literals are not supported
- `new` is not supported
- references on empty values return `undefined` not an error
- regular expressions are not supported
- `typeof`, `instanceof` and `delete` are not supported
- assignment destructuring and spread operator is not supported.